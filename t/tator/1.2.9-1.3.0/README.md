# Comparing `tmp/tator-1.2.9.tar.gz` & `tmp/tator-1.3.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "tator-1.2.9.tar", last modified: Mon May 13 02:29:36 2024, max compression
+gzip compressed data, was "tator-1.3.0.tar", last modified: Fri May 31 21:44:48 2024, max compression
```

## Comparing `tator-1.2.9.tar` & `tator-1.3.0.tar`

### file list

```diff
@@ -1,295 +1,307 @@
-drwxrwxr-x   0 ubuntu    (1000) ubuntu    (1000)        0 2024-05-13 02:29:36.017160 tator-1.2.9/
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)      106 2024-05-13 02:19:40.000000 tator-1.2.9/MANIFEST.in
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)      321 2024-05-13 02:29:36.013160 tator-1.2.9/PKG-INFO
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)      667 2024-05-13 02:19:40.000000 tator-1.2.9/README.md
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)       51 2024-05-13 02:19:40.000000 tator-1.2.9/pyproject.toml
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)       38 2024-05-13 02:29:36.017160 tator-1.2.9/setup.cfg
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     3752 2024-05-13 02:19:40.000000 tator-1.2.9/setup.py
-drwxrwxr-x   0 ubuntu    (1000) ubuntu    (1000)        0 2024-05-13 02:29:35.973159 tator-1.2.9/tator/
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)      600 2024-05-13 02:19:40.000000 tator-1.2.9/tator/__init__.py
-drwxrwxr-x   0 ubuntu    (1000) ubuntu    (1000)        0 2024-05-13 02:29:35.977159 tator-1.2.9/tator/extractor/
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)        0 2024-05-13 02:19:40.000000 tator-1.2.9/tator/extractor/__init__.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     3621 2024-05-13 02:19:40.000000 tator-1.2.9/tator/extractor/__main__.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1562 2024-05-13 02:19:40.000000 tator-1.2.9/tator/extractor/env_launcher.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)    12298 2024-05-13 02:19:40.000000 tator-1.2.9/tator/extractor/extractor.py
-drwxrwxr-x   0 ubuntu    (1000) ubuntu    (1000)        0 2024-05-13 02:29:35.977159 tator-1.2.9/tator/openapi/
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)       61 2024-05-13 02:19:40.000000 tator-1.2.9/tator/openapi/__init__.py
-drwxrwxr-x   0 ubuntu    (1000) ubuntu    (1000)        0 2024-05-13 02:29:35.977159 tator-1.2.9/tator/openapi/tator_openapi/
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    12670 2024-05-13 02:29:34.000000 tator-1.2.9/tator/openapi/tator_openapi/__init__.py
-drwxrwxr-x   0 ubuntu    (1000) ubuntu    (1000)        0 2024-05-13 02:29:35.977159 tator-1.2.9/tator/openapi/tator_openapi/api/
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)      150 2024-05-13 02:29:34.000000 tator-1.2.9/tator/openapi/tator_openapi/api/__init__.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)  2015800 2024-05-13 02:29:34.000000 tator-1.2.9/tator/openapi/tator_openapi/api/tator_api.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    26204 2024-05-13 02:29:34.000000 tator-1.2.9/tator/openapi/tator_openapi/api_client.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    13489 2024-05-13 02:29:34.000000 tator-1.2.9/tator/openapi/tator_openapi/configuration.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3713 2024-05-13 02:29:34.000000 tator-1.2.9/tator/openapi/tator_openapi/exceptions.py
-drwxrwxr-x   0 ubuntu    (1000) ubuntu    (1000)        0 2024-05-13 02:29:36.001160 tator-1.2.9/tator/openapi/tator_openapi/models/
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    12080 2024-05-13 02:29:34.000000 tator-1.2.9/tator/openapi/tator_openapi/models/__init__.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     8289 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/affiliation.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4305 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/affiliation_spec.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3513 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/affiliation_update.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     8842 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/algorithm.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3019 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/algorithm_manifest.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3697 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/algorithm_manifest_spec.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3905 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/algorithm_parameter.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     8339 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/algorithm_spec.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5083 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/announcement.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     6017 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/applet.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4903 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/applet_spec.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4398 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/archive_config.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4121 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/attribute_combinator_spec.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    10923 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/attribute_filter_spec.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    12585 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/attribute_operation_spec.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    14330 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/attribute_type.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3743 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/attribute_type_delete.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3763 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/attribute_type_spec.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5270 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/attribute_type_update.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    15184 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/attribute_type_update_attribute_type_update.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     8054 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/audio_definition.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     6819 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/autocomplete_service.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     6295 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/auxiliary_file_definition.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3705 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/bad_request_response.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5353 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/bookmark.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3479 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/bookmark_spec.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3495 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/bookmark_update.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     8573 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/bucket.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    10945 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/bucket_gcp_config.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4117 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/bucket_oci_config.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     6268 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/bucket_oci_native_config.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     6022 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/bucket_s3_config.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     7814 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/bucket_spec.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     7376 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/bucket_update.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5847 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/change_log.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3855 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/change_log_description_of_change.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3754 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/change_log_description_of_change_new.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5300 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/clone_media_spec.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     6715 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/color_map.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3762 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/concat_definition.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4324 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/create_list_response.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4228 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/create_response.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4548 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/credentials.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3485 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/download_info.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3223 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/download_info_spec.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3850 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/email_attachment_spec.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5904 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/email_spec.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     9514 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/encode_config.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     7681 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/favorite.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     6659 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/favorite_spec.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4165 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/favorite_update.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4001 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/feed_definition.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     9920 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/file.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     6208 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/file_spec.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     6170 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/file_type.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5066 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/file_type_spec.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4304 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/file_type_update.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     7650 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/file_update.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3854 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/fill.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5778 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/float_array_query.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4789 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/generic_file.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3653 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/generic_file_spec.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3741 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/get_cloned_media_response.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     6521 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/image_definition.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     9423 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/invitation.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4364 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/invitation_spec.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4424 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/invitation_update.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     7272 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/job.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     6531 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/job_cluster.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     6056 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/job_cluster_spec.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5756 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/job_node.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     6287 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/job_spec.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     6072 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/job_spec_failure_email_spec.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     6316 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/leaf.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     6786 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/leaf_bulk_update.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4398 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/leaf_id_query.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5040 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/leaf_spec.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4165 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/leaf_suggestion.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     6760 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/leaf_type.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5066 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/leaf_type_spec.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4306 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/leaf_type_update.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5245 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/leaf_update.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3816 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/live_definition.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4001 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/live_update_definition.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    20648 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/localization.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     9814 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/localization_bulk_delete.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    10180 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/localization_bulk_update.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3743 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/localization_delete.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     6826 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/localization_id_query.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    15764 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/localization_spec.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    11602 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/localization_type.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    11084 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/localization_type_spec.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     8114 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/localization_type_update.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    15159 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/localization_update.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    18930 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/media.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    10699 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/media_bulk_update.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    10188 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/media_files.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5974 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/media_id_query.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3141 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/media_next.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3141 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/media_prev.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    15998 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/media_spec.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5697 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/media_stats.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    14738 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/media_type.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    14015 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/media_type_spec.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    11297 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/media_type_update.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    16079 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/media_update.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     8877 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/membership.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5693 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/membership_spec.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4593 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/membership_update.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3057 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/message_response.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5004 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/multi_definition.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3077 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/not_found_response.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3904 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/notify_spec.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     6630 2024-05-13 02:29:32.000000 tator-1.2.9/tator/openapi/tator_openapi/models/organization.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5620 2024-05-13 02:29:33.000000 tator-1.2.9/tator/openapi/tator_openapi/models/organization_spec.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5486 2024-05-13 02:29:33.000000 tator-1.2.9/tator/openapi/tator_openapi/models/organization_update.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3234 2024-05-13 02:29:33.000000 tator-1.2.9/tator/openapi/tator_openapi/models/password_reset_spec.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    13571 2024-05-13 02:29:33.000000 tator-1.2.9/tator/openapi/tator_openapi/models/project.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     9161 2024-05-13 02:29:33.000000 tator-1.2.9/tator/openapi/tator_openapi/models/project_spec.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     8503 2024-05-13 02:29:33.000000 tator-1.2.9/tator/openapi/tator_openapi/models/project_update.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     8779 2024-05-13 02:29:33.000000 tator-1.2.9/tator/openapi/tator_openapi/models/resolution_config.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4639 2024-05-13 02:29:33.000000 tator-1.2.9/tator/openapi/tator_openapi/models/s3_storage_config.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     8248 2024-05-13 02:29:33.000000 tator-1.2.9/tator/openapi/tator_openapi/models/section.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     7300 2024-05-13 02:29:33.000000 tator-1.2.9/tator/openapi/tator_openapi/models/section_spec.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     7182 2024-05-13 02:29:33.000000 tator-1.2.9/tator/openapi/tator_openapi/models/section_update.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    12378 2024-05-13 02:29:33.000000 tator-1.2.9/tator/openapi/tator_openapi/models/state.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     8124 2024-05-13 02:29:33.000000 tator-1.2.9/tator/openapi/tator_openapi/models/state_bulk_delete.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    11740 2024-05-13 02:29:33.000000 tator-1.2.9/tator/openapi/tator_openapi/models/state_bulk_update.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3701 2024-05-13 02:29:33.000000 tator-1.2.9/tator/openapi/tator_openapi/models/state_delete.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     6810 2024-05-13 02:29:33.000000 tator-1.2.9/tator/openapi/tator_openapi/models/state_id_query.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3465 2024-05-13 02:29:33.000000 tator-1.2.9/tator/openapi/tator_openapi/models/state_merge_update.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     8846 2024-05-13 02:29:33.000000 tator-1.2.9/tator/openapi/tator_openapi/models/state_spec.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4604 2024-05-13 02:29:33.000000 tator-1.2.9/tator/openapi/tator_openapi/models/state_trim_update.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    13336 2024-05-13 02:29:33.000000 tator-1.2.9/tator/openapi/tator_openapi/models/state_type.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    12260 2024-05-13 02:29:33.000000 tator-1.2.9/tator/openapi/tator_openapi/models/state_type_spec.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     6953 2024-05-13 02:29:33.000000 tator-1.2.9/tator/openapi/tator_openapi/models/state_type_update.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     9375 2024-05-13 02:29:33.000000 tator-1.2.9/tator/openapi/tator_openapi/models/state_update.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     7383 2024-05-13 02:29:33.000000 tator-1.2.9/tator/openapi/tator_openapi/models/temporary_file.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5689 2024-05-13 02:29:33.000000 tator-1.2.9/tator/openapi/tator_openapi/models/temporary_file_spec.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     2925 2024-05-13 02:29:33.000000 tator-1.2.9/tator/openapi/tator_openapi/models/token.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3363 2024-05-13 02:29:33.000000 tator-1.2.9/tator/openapi/tator_openapi/models/transcode.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    10987 2024-05-13 02:29:33.000000 tator-1.2.9/tator/openapi/tator_openapi/models/transcode_spec.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4532 2024-05-13 02:29:33.000000 tator-1.2.9/tator/openapi/tator_openapi/models/upload_completion_spec.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4597 2024-05-13 02:29:33.000000 tator-1.2.9/tator/openapi/tator_openapi/models/upload_info.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3883 2024-05-13 02:29:33.000000 tator-1.2.9/tator/openapi/tator_openapi/models/upload_part.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     7129 2024-05-13 02:29:33.000000 tator-1.2.9/tator/openapi/tator_openapi/models/user.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     8946 2024-05-13 02:29:33.000000 tator-1.2.9/tator/openapi/tator_openapi/models/user_spec.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     9465 2024-05-13 02:29:33.000000 tator-1.2.9/tator/openapi/tator_openapi/models/user_update.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     7988 2024-05-13 02:29:33.000000 tator-1.2.9/tator/openapi/tator_openapi/models/version.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5820 2024-05-13 02:29:33.000000 tator-1.2.9/tator/openapi/tator_openapi/models/version_spec.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5694 2024-05-13 02:29:33.000000 tator-1.2.9/tator/openapi/tator_openapi/models/version_update.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4827 2024-05-13 02:29:33.000000 tator-1.2.9/tator/openapi/tator_openapi/models/video_clip.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    10920 2024-05-13 02:29:33.000000 tator-1.2.9/tator/openapi/tator_openapi/models/video_definition.py
--rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    13483 2024-05-13 02:29:34.000000 tator-1.2.9/tator/openapi/tator_openapi/rest.py
-drwxrwxr-x   0 ubuntu    (1000) ubuntu    (1000)        0 2024-05-13 02:29:36.001160 tator-1.2.9/tator/transcode/
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)        0 2024-05-13 02:19:40.000000 tator-1.2.9/tator/transcode/__init__.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     7730 2024-05-13 02:19:40.000000 tator-1.2.9/tator/transcode/__main__.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2105 2024-05-13 02:19:40.000000 tator-1.2.9/tator/transcode/black.mp4
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2175 2024-05-13 02:19:40.000000 tator-1.2.9/tator/transcode/create_media.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)      993 2024-05-13 02:19:40.000000 tator-1.2.9/tator/transcode/delete_media.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     9452 2024-05-13 02:19:40.000000 tator-1.2.9/tator/transcode/determine_transcode.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2286 2024-05-13 02:19:40.000000 tator-1.2.9/tator/transcode/make_fragment_info.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     5922 2024-05-13 02:19:40.000000 tator-1.2.9/tator/transcode/make_thumbnails.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     3559 2024-05-13 02:19:40.000000 tator-1.2.9/tator/transcode/prepare.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)    19361 2024-05-13 02:19:40.000000 tator-1.2.9/tator/transcode/transcode.py
-drwxrwxr-x   0 ubuntu    (1000) ubuntu    (1000)        0 2024-05-13 02:29:36.009160 tator-1.2.9/tator/util/
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2061 2024-05-13 02:19:40.000000 tator-1.2.9/tator/util/__init__.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2012 2024-05-13 02:19:40.000000 tator-1.2.9/tator/util/_download_file.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     7264 2024-05-13 02:19:40.000000 tator-1.2.9/tator/util/_upload_file.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2119 2024-05-13 02:19:40.000000 tator-1.2.9/tator/util/chunked_create.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)      955 2024-05-13 02:19:40.000000 tator-1.2.9/tator/util/chunked_file_list.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     4482 2024-05-13 02:19:40.000000 tator-1.2.9/tator/util/clone_leaf_list.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1544 2024-05-13 02:19:40.000000 tator-1.2.9/tator/util/clone_leaf_type.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     7453 2024-05-13 02:19:40.000000 tator-1.2.9/tator/util/clone_localization_list.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2510 2024-05-13 02:19:40.000000 tator-1.2.9/tator/util/clone_localization_type.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)    11130 2024-05-13 02:19:40.000000 tator-1.2.9/tator/util/clone_media_list.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1999 2024-05-13 02:19:40.000000 tator-1.2.9/tator/util/clone_media_type.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2099 2024-05-13 02:19:40.000000 tator-1.2.9/tator/util/clone_membership.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1647 2024-05-13 02:19:40.000000 tator-1.2.9/tator/util/clone_section.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     6572 2024-05-13 02:19:40.000000 tator-1.2.9/tator/util/clone_state_list.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2486 2024-05-13 02:19:40.000000 tator-1.2.9/tator/util/clone_state_type.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2140 2024-05-13 02:19:40.000000 tator-1.2.9/tator/util/clone_version.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     4507 2024-05-13 02:19:40.000000 tator-1.2.9/tator/util/concat.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1464 2024-05-13 02:19:40.000000 tator-1.2.9/tator/util/download_attachment.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     4887 2024-05-13 02:19:40.000000 tator-1.2.9/tator/util/download_media.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2002 2024-05-13 02:19:40.000000 tator-1.2.9/tator/util/download_temporary_file.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2963 2024-05-13 02:19:40.000000 tator-1.2.9/tator/util/find_single_change.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1072 2024-05-13 02:19:40.000000 tator-1.2.9/tator/util/full_state_graphic.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1405 2024-05-13 02:19:40.000000 tator-1.2.9/tator/util/get_api.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2448 2024-05-13 02:19:40.000000 tator-1.2.9/tator/util/get_images.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     3224 2024-05-13 02:19:40.000000 tator-1.2.9/tator/util/get_paginator.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1371 2024-05-13 02:19:40.000000 tator-1.2.9/tator/util/get_parser.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     4282 2024-05-13 02:19:40.000000 tator-1.2.9/tator/util/import_media.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1732 2024-05-13 02:19:40.000000 tator-1.2.9/tator/util/live_stream.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1989 2024-05-13 02:19:40.000000 tator-1.2.9/tator/util/md5sum.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     3194 2024-05-13 02:19:40.000000 tator-1.2.9/tator/util/media_manipulation.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)    17899 2024-05-13 02:19:40.000000 tator-1.2.9/tator/util/media_util.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     8461 2024-05-13 02:19:40.000000 tator-1.2.9/tator/util/multi_stream.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2322 2024-05-13 02:19:40.000000 tator-1.2.9/tator/util/register_algorithm.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2027 2024-05-13 02:19:40.000000 tator-1.2.9/tator/util/register_applet.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     3512 2024-05-13 02:19:40.000000 tator-1.2.9/tator/util/tator-symbol.gif
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     5653 2024-05-13 02:19:40.000000 tator-1.2.9/tator/util/tator-symbol.png
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)      530 2024-05-13 02:19:40.000000 tator-1.2.9/tator/util/to_dataframe.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2055 2024-05-13 02:19:40.000000 tator-1.2.9/tator/util/update_applet.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1551 2024-05-13 02:19:40.000000 tator-1.2.9/tator/util/upload_attachment.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2008 2024-05-13 02:19:40.000000 tator-1.2.9/tator/util/upload_generic_file.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     3446 2024-05-13 02:19:40.000000 tator-1.2.9/tator/util/upload_media.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1663 2024-05-13 02:19:40.000000 tator-1.2.9/tator/util/upload_temporary_file.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)      160 2024-05-13 02:19:40.000000 tator-1.2.9/tator/version.py
-drwxrwxr-x   0 ubuntu    (1000) ubuntu    (1000)        0 2024-05-13 02:29:35.977159 tator-1.2.9/tator.egg-info/
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)      321 2024-05-13 02:29:35.000000 tator-1.2.9/tator.egg-info/PKG-INFO
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)    11849 2024-05-13 02:29:35.000000 tator-1.2.9/tator.egg-info/SOURCES.txt
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)        1 2024-05-13 02:29:35.000000 tator-1.2.9/tator.egg-info/dependency_links.txt
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)      144 2024-05-13 02:29:35.000000 tator-1.2.9/tator.egg-info/requires.txt
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)        6 2024-05-13 02:29:35.000000 tator-1.2.9/tator.egg-info/top_level.txt
-drwxrwxr-x   0 ubuntu    (1000) ubuntu    (1000)        0 2024-05-13 02:29:36.013160 tator-1.2.9/test/
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     4892 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_a_float_array.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)    13689 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_algorithm.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     9519 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_algorithm_launch.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     6577 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_applet.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1538 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_archive_date.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)      945 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_attachment.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     6437 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_attribute_type_addition.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2760 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_attribute_type_deletion.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)    12411 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_attribute_type_mutation.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1142 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_attributes.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)    23752 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_change_log.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     4174 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_chunked_create.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)      568 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_clone_leaf_type.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1517 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_clone_localization_type.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     7222 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_clone_media.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)      576 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_clone_media_type.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1209 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_clone_membership.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)      797 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_clone_section.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1083 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_clone_state_type.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)      797 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_clone_version.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     3601 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_collection.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     6149 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_download_media.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2123 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_extract.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)    13655 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_file.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     3140 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_file_type.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)      585 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_get_clip.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)      531 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_getframe.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1774 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_import_media.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2558 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_job_cancel.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1772 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_job_cluster.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     3364 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_leaf.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1593 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_leaf_type.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     3031 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_local_transcode.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     9223 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_localization.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)    17733 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_localization_graphic.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2321 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_localization_type.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)    10371 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_media.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1423 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_media_type.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1524 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_multi.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     4902 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_pagination.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2456 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_poly.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)      397 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_project_thumbnail.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     9537 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_search.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     9393 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_state.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1854 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_state_graphic.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1970 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_state_type.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1597 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_stategraphic.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1469 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_temporary_file.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     3884 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_tracks.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     5369 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_transcode.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1923 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_util_media_manipulation.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     3174 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_util_media_util.py
--rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)      912 2024-05-13 02:19:40.000000 tator-1.2.9/test/test_version.py
+drwxrwxr-x   0 ubuntu    (1000) ubuntu    (1000)        0 2024-05-31 21:44:48.558846 tator-1.3.0/
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1060 2024-05-31 18:20:52.000000 tator-1.3.0/LICENSE.md
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)      106 2024-05-31 18:20:52.000000 tator-1.3.0/MANIFEST.in
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)      327 2024-05-31 21:44:48.558846 tator-1.3.0/PKG-INFO
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)      667 2024-05-31 18:20:52.000000 tator-1.3.0/README.md
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)       51 2024-05-31 18:20:52.000000 tator-1.3.0/pyproject.toml
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)       38 2024-05-31 21:44:48.558846 tator-1.3.0/setup.cfg
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     3752 2024-05-31 18:20:52.000000 tator-1.3.0/setup.py
+drwxrwxr-x   0 ubuntu    (1000) ubuntu    (1000)        0 2024-05-31 21:44:48.518848 tator-1.3.0/tator/
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)      600 2024-05-31 18:20:52.000000 tator-1.3.0/tator/__init__.py
+drwxrwxr-x   0 ubuntu    (1000) ubuntu    (1000)        0 2024-05-31 21:44:48.518848 tator-1.3.0/tator/extractor/
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)        0 2024-05-31 18:20:52.000000 tator-1.3.0/tator/extractor/__init__.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     3621 2024-05-31 18:20:52.000000 tator-1.3.0/tator/extractor/__main__.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1562 2024-05-31 18:20:52.000000 tator-1.3.0/tator/extractor/env_launcher.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)    12298 2024-05-31 18:20:52.000000 tator-1.3.0/tator/extractor/extractor.py
+drwxrwxr-x   0 ubuntu    (1000) ubuntu    (1000)        0 2024-05-31 21:44:48.518848 tator-1.3.0/tator/openapi/
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)       61 2024-05-31 18:20:52.000000 tator-1.3.0/tator/openapi/__init__.py
+drwxrwxr-x   0 ubuntu    (1000) ubuntu    (1000)        0 2024-05-31 21:44:48.518848 tator-1.3.0/tator/openapi/tator_openapi/
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    13362 2024-05-31 21:44:47.000000 tator-1.3.0/tator/openapi/tator_openapi/__init__.py
+drwxrwxr-x   0 ubuntu    (1000) ubuntu    (1000)        0 2024-05-31 21:44:48.518848 tator-1.3.0/tator/openapi/tator_openapi/api/
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)      150 2024-05-31 21:44:47.000000 tator-1.3.0/tator/openapi/tator_openapi/api/__init__.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)  2196513 2024-05-31 21:44:47.000000 tator-1.3.0/tator/openapi/tator_openapi/api/tator_api.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    26204 2024-05-31 21:44:47.000000 tator-1.3.0/tator/openapi/tator_openapi/api_client.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    13489 2024-05-31 21:44:47.000000 tator-1.3.0/tator/openapi/tator_openapi/configuration.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3713 2024-05-31 21:44:47.000000 tator-1.3.0/tator/openapi/tator_openapi/exceptions.py
+drwxrwxr-x   0 ubuntu    (1000) ubuntu    (1000)        0 2024-05-31 21:44:48.542847 tator-1.3.0/tator/openapi/tator_openapi/models/
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    12772 2024-05-31 21:44:47.000000 tator-1.3.0/tator/openapi/tator_openapi/models/__init__.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     8289 2024-05-31 21:44:44.000000 tator-1.3.0/tator/openapi/tator_openapi/models/affiliation.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4305 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/affiliation_spec.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3513 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/affiliation_update.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    10957 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/algorithm.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3019 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/algorithm_manifest.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3697 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/algorithm_manifest_spec.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3905 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/algorithm_parameter.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    10220 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/algorithm_spec.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5083 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/announcement.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     8102 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/applet.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     6926 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/applet_spec.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4398 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/archive_config.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4121 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/attribute_combinator_spec.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    16321 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/attribute_filter_spec.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    17983 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/attribute_operation_spec.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    14338 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/attribute_type.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4168 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/attribute_type_delete.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4188 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/attribute_type_spec.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5695 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/attribute_type_update.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    15192 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/attribute_type_update_attribute_type_update.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     8054 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/audio_definition.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     6819 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/autocomplete_service.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     6295 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/auxiliary_file_definition.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3705 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/bad_request_response.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5353 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/bookmark.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3479 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/bookmark_spec.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3495 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/bookmark_update.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     8581 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/bucket.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    10945 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/bucket_gcp_config.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4117 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/bucket_oci_config.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     6268 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/bucket_oci_native_config.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     6022 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/bucket_s3_config.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     7822 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/bucket_spec.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     7384 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/bucket_update.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5847 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/change_log.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3855 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/change_log_description_of_change.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3754 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/change_log_description_of_change_new.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5300 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/clone_media_spec.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     6715 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/color_map.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3762 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/concat_definition.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4324 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/create_list_response.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4228 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/create_response.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4548 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/credentials.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3485 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/download_info.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3223 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/download_info_spec.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3850 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/email_attachment_spec.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5904 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/email_spec.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     9514 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/encode_config.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     7681 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/favorite.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     6659 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/favorite_spec.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4165 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/favorite_update.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4001 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/feed_definition.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     9920 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/file.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     6208 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/file_spec.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     6170 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/file_type.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5066 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/file_type_spec.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4304 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/file_type_update.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     7650 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/file_update.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3854 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/fill.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5778 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/float_array_query.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4789 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/generic_file.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3653 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/generic_file_spec.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3741 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/get_cloned_media_response.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5695 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/hosted_template.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5388 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/hosted_template_spec.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     6521 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/image_definition.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3567 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/inline_response200.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3614 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/inline_response2001.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3593 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/inline_response2002.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     9423 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/invitation.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4364 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/invitation_spec.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4424 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/invitation_update.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     7826 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/job.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     6531 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/job_cluster.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     6056 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/job_cluster_spec.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5756 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/job_node.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     6287 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/job_spec.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     6072 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/job_spec_failure_email_spec.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     6316 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/leaf.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     6786 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/leaf_bulk_update.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4398 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/leaf_id_query.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5040 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/leaf_spec.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4165 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/leaf_suggestion.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     6760 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/leaf_type.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5066 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/leaf_type_spec.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4306 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/leaf_type_update.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5245 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/leaf_update.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3816 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/live_definition.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4001 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/live_update_definition.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    21236 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/localization.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    11118 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/localization_bulk_delete.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    14958 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/localization_bulk_update.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4989 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/localization_delete.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     8524 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/localization_id_query.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    16360 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/localization_spec.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    11602 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/localization_type.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    11084 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/localization_type_spec.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     8114 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/localization_type_update.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    18353 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/localization_update.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    18930 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/media.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    10699 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/media_bulk_update.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    10188 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/media_files.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5974 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/media_id_query.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3141 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/media_next.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3141 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/media_prev.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    16521 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/media_spec.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5697 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/media_stats.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    14738 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/media_type.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    14015 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/media_type_spec.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    11297 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/media_type_update.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    16079 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/media_update.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     8877 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/membership.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5693 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/membership_spec.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4593 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/membership_update.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3057 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/message_response.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5004 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/multi_definition.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3077 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/not_found_response.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3904 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/notify_spec.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     6630 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/organization.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5620 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/organization_spec.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5486 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/organization_update.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3784 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/parameter.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3234 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/password_reset_spec.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    13571 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/project.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     9161 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/project_spec.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     8503 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/project_update.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     8779 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/resolution_config.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4639 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/s3_storage_config.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    11795 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/section.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3265 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/section_bulk_update.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3639 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/section_bulk_update_path_substitution.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     9497 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/section_spec.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    10079 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/section_update.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    12952 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/state.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     9364 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/state_bulk_delete.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    13082 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/state_bulk_update.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4933 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/state_delete.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     6810 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/state_id_query.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3465 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/state_merge_update.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     9428 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/state_spec.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4604 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/state_trim_update.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    13336 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/state_type.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    12260 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/state_type_spec.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     6953 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/state_type_update.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    12527 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/state_update.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     7383 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/temporary_file.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5689 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/temporary_file_spec.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     2925 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/token.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3363 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/transcode.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    11544 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/transcode_spec.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4532 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/upload_completion_spec.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4597 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/upload_info.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     3883 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/upload_part.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     7129 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/user.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     8946 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/user_spec.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     9465 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/user_update.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     7988 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/version.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5820 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/version_spec.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     5694 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/version_update.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)     4827 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/video_clip.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    10920 2024-05-31 21:44:45.000000 tator-1.3.0/tator/openapi/tator_openapi/models/video_definition.py
+-rw-r--r--   0 ubuntu    (1000) ubuntu    (1000)    13483 2024-05-31 21:44:47.000000 tator-1.3.0/tator/openapi/tator_openapi/rest.py
+drwxrwxr-x   0 ubuntu    (1000) ubuntu    (1000)        0 2024-05-31 21:44:48.546847 tator-1.3.0/tator/transcode/
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)        0 2024-05-31 18:20:52.000000 tator-1.3.0/tator/transcode/__init__.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     8582 2024-05-31 18:20:52.000000 tator-1.3.0/tator/transcode/__main__.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2105 2024-05-31 18:20:52.000000 tator-1.3.0/tator/transcode/black.mp4
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2504 2024-05-31 18:20:52.000000 tator-1.3.0/tator/transcode/create_media.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)      993 2024-05-31 18:20:52.000000 tator-1.3.0/tator/transcode/delete_media.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     9452 2024-05-31 18:20:52.000000 tator-1.3.0/tator/transcode/determine_transcode.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2286 2024-05-31 18:20:52.000000 tator-1.3.0/tator/transcode/make_fragment_info.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     6187 2024-05-31 18:20:52.000000 tator-1.3.0/tator/transcode/make_thumbnails.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     3559 2024-05-31 18:20:52.000000 tator-1.3.0/tator/transcode/prepare.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)    19962 2024-05-31 18:20:52.000000 tator-1.3.0/tator/transcode/transcode.py
+drwxrwxr-x   0 ubuntu    (1000) ubuntu    (1000)        0 2024-05-31 21:44:48.550846 tator-1.3.0/tator/util/
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2061 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/__init__.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2012 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/_download_file.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     7442 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/_upload_file.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2119 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/chunked_create.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)      955 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/chunked_file_list.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     4482 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/clone_leaf_list.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1544 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/clone_leaf_type.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     7453 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/clone_localization_list.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2510 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/clone_localization_type.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)    11130 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/clone_media_list.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1999 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/clone_media_type.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2099 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/clone_membership.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1647 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/clone_section.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     6572 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/clone_state_list.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2486 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/clone_state_type.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2140 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/clone_version.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     4507 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/concat.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1464 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/download_attachment.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     4887 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/download_media.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2002 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/download_temporary_file.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2963 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/find_single_change.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1072 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/full_state_graphic.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1405 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/get_api.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2448 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/get_images.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     3224 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/get_paginator.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1371 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/get_parser.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     4511 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/import_media.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     4853 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/import_resumable.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1732 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/live_stream.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1989 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/md5sum.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     3194 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/media_manipulation.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)    17899 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/media_util.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     8461 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/multi_stream.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2322 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/register_algorithm.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2027 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/register_applet.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     5900 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/resumable_upload.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     3512 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/tator-symbol.gif
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     5653 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/tator-symbol.png
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)      530 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/to_dataframe.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2055 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/update_applet.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1551 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/upload_attachment.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2008 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/upload_generic_file.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     3680 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/upload_media.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1663 2024-05-31 18:20:52.000000 tator-1.3.0/tator/util/upload_temporary_file.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)      160 2024-05-31 18:20:52.000000 tator-1.3.0/tator/version.py
+drwxrwxr-x   0 ubuntu    (1000) ubuntu    (1000)        0 2024-05-31 21:44:48.518848 tator-1.3.0/tator.egg-info/
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)      327 2024-05-31 21:44:48.000000 tator-1.3.0/tator.egg-info/PKG-INFO
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)    12419 2024-05-31 21:44:48.000000 tator-1.3.0/tator.egg-info/SOURCES.txt
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)        1 2024-05-31 21:44:48.000000 tator-1.3.0/tator.egg-info/dependency_links.txt
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)      144 2024-05-31 21:44:48.000000 tator-1.3.0/tator.egg-info/requires.txt
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)        6 2024-05-31 21:44:48.000000 tator-1.3.0/tator.egg-info/top_level.txt
+drwxrwxr-x   0 ubuntu    (1000) ubuntu    (1000)        0 2024-05-31 21:44:48.558846 tator-1.3.0/test/
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     4892 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_a_float_array.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)    13802 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_algorithm.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     9519 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_algorithm_launch.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     6691 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_applet.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1538 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_archive_date.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)      945 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_attachment.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     6434 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_attribute_type_addition.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2760 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_attribute_type_deletion.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)    12411 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_attribute_type_mutation.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1142 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_attributes.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)    22827 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_change_log.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     4174 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_chunked_create.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)      568 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_clone_leaf_type.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1517 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_clone_localization_type.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     7222 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_clone_media.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)      576 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_clone_media_type.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1209 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_clone_membership.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)      797 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_clone_section.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1083 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_clone_state_type.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)      797 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_clone_version.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     3601 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_collection.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     6149 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_download_media.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2123 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_extract.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)    13655 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_file.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     3140 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_file_type.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)      585 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_get_clip.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)      531 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_getframe.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1737 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_hosted_template.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2905 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_import_media.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2558 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_job_cancel.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1772 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_job_cluster.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     3364 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_leaf.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1593 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_leaf_type.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     3051 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_local_transcode.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)    10604 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_localization.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)    17733 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_localization_graphic.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2321 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_localization_type.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)    11307 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_media.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1423 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_media_type.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1524 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_multi.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     4902 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_pagination.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     2543 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_poly.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)      397 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_project_thumbnail.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     9537 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_search.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)    10653 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_state.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1854 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_state_graphic.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1970 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_state_type.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1597 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_stategraphic.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1469 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_temporary_file.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     4098 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_tracks.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     5369 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_transcode.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     1923 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_util_media_manipulation.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)     3174 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_util_media_util.py
+-rw-rw-r--   0 ubuntu    (1000) ubuntu    (1000)      912 2024-05-31 18:20:52.000000 tator-1.3.0/test/test_version.py
```

### Comparing `tator-1.2.9/README.md` & `tator-1.3.0/README.md`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/setup.py` & `tator-1.3.0/setup.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/__init__.py` & `tator-1.3.0/tator/__init__.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/extractor/__main__.py` & `tator-1.3.0/tator/extractor/__main__.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/extractor/env_launcher.py` & `tator-1.3.0/tator/extractor/env_launcher.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/extractor/extractor.py` & `tator-1.3.0/tator/extractor/extractor.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/__init__.py` & `tator-1.3.0/tator/openapi/tator_openapi/__init__.py`

 * *Files 1% similar despite different names*

```diff
@@ -10,15 +10,15 @@
     The version of the OpenAPI document: v1
     Generated by: https://openapi-generator.tech
 """
 
 
 from __future__ import absolute_import
 
-__version__ = "1.2.9"
+__version__ = "1.3.0"
 
 # import apis into sdk package
 from tator.openapi.tator_openapi.api.tator_api import TatorApi
 
 # import ApiClient
 from tator.openapi.tator_openapi.api_client import ApiClient
 from tator.openapi.tator_openapi.configuration import Configuration
@@ -87,15 +87,20 @@
 from tator.openapi.tator_openapi.models.file_type_update import FileTypeUpdate
 from tator.openapi.tator_openapi.models.file_update import FileUpdate
 from tator.openapi.tator_openapi.models.fill import Fill
 from tator.openapi.tator_openapi.models.float_array_query import FloatArrayQuery
 from tator.openapi.tator_openapi.models.generic_file import GenericFile
 from tator.openapi.tator_openapi.models.generic_file_spec import GenericFileSpec
 from tator.openapi.tator_openapi.models.get_cloned_media_response import GetClonedMediaResponse
+from tator.openapi.tator_openapi.models.hosted_template import HostedTemplate
+from tator.openapi.tator_openapi.models.hosted_template_spec import HostedTemplateSpec
 from tator.openapi.tator_openapi.models.image_definition import ImageDefinition
+from tator.openapi.tator_openapi.models.inline_response200 import InlineResponse200
+from tator.openapi.tator_openapi.models.inline_response2001 import InlineResponse2001
+from tator.openapi.tator_openapi.models.inline_response2002 import InlineResponse2002
 from tator.openapi.tator_openapi.models.invitation import Invitation
 from tator.openapi.tator_openapi.models.invitation_spec import InvitationSpec
 from tator.openapi.tator_openapi.models.invitation_update import InvitationUpdate
 from tator.openapi.tator_openapi.models.job import Job
 from tator.openapi.tator_openapi.models.job_cluster import JobCluster
 from tator.openapi.tator_openapi.models.job_cluster_spec import JobClusterSpec
 from tator.openapi.tator_openapi.models.job_node import JobNode
@@ -140,21 +145,24 @@
 from tator.openapi.tator_openapi.models.message_response import MessageResponse
 from tator.openapi.tator_openapi.models.multi_definition import MultiDefinition
 from tator.openapi.tator_openapi.models.not_found_response import NotFoundResponse
 from tator.openapi.tator_openapi.models.notify_spec import NotifySpec
 from tator.openapi.tator_openapi.models.organization import Organization
 from tator.openapi.tator_openapi.models.organization_spec import OrganizationSpec
 from tator.openapi.tator_openapi.models.organization_update import OrganizationUpdate
+from tator.openapi.tator_openapi.models.parameter import Parameter
 from tator.openapi.tator_openapi.models.password_reset_spec import PasswordResetSpec
 from tator.openapi.tator_openapi.models.project import Project
 from tator.openapi.tator_openapi.models.project_spec import ProjectSpec
 from tator.openapi.tator_openapi.models.project_update import ProjectUpdate
 from tator.openapi.tator_openapi.models.resolution_config import ResolutionConfig
 from tator.openapi.tator_openapi.models.s3_storage_config import S3StorageConfig
 from tator.openapi.tator_openapi.models.section import Section
+from tator.openapi.tator_openapi.models.section_bulk_update import SectionBulkUpdate
+from tator.openapi.tator_openapi.models.section_bulk_update_path_substitution import SectionBulkUpdatePathSubstitution
 from tator.openapi.tator_openapi.models.section_spec import SectionSpec
 from tator.openapi.tator_openapi.models.section_update import SectionUpdate
 from tator.openapi.tator_openapi.models.state import State
 from tator.openapi.tator_openapi.models.state_bulk_delete import StateBulkDelete
 from tator.openapi.tator_openapi.models.state_bulk_update import StateBulkUpdate
 from tator.openapi.tator_openapi.models.state_delete import StateDelete
 from tator.openapi.tator_openapi.models.state_id_query import StateIdQuery
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/api/tator_api.py` & `tator-1.3.0/tator/openapi/tator_openapi/api/tator_api.py`

 * *Files 12% similar despite different names*

```diff
@@ -44,14 +44,15 @@
         :param bool async_req: execute request asynchronously
         :param int project: A unique integer identifying the source project. (required)
         :param CloneMediaSpec clone_media_spec: (required)
         :param list[int] media_id: List of integers identifying media.
         :param int type: Unique integer identifying media type.
         :param str name: Name of the media to filter on.
         :param int section: Unique integer identifying a media section.
+        :param list[int] multi_section: List of integers identifying sections to select.
         :param str dtype: Data type of the files, either image or video.
         :param str md5: MD5 sum of the media file.
         :param str gid: Upload group ID of the media file.
         :param str uid: Upload unique ID of the media file.
         :param int after: If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str after_name: If given, all results returned will be after the media with this name. The `start` and `stop` parameters are relative to this modified range.
         :param str archive_lifecycle: Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
@@ -63,15 +64,15 @@
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts. Default is 300.
@@ -95,14 +96,15 @@
         :param bool async_req: execute request asynchronously
         :param int project: A unique integer identifying the source project. (required)
         :param CloneMediaSpec clone_media_spec: (required)
         :param list[int] media_id: List of integers identifying media.
         :param int type: Unique integer identifying media type.
         :param str name: Name of the media to filter on.
         :param int section: Unique integer identifying a media section.
+        :param list[int] multi_section: List of integers identifying sections to select.
         :param str dtype: Data type of the files, either image or video.
         :param str md5: MD5 sum of the media file.
         :param str gid: Upload group ID of the media file.
         :param str uid: Upload unique ID of the media file.
         :param int after: If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str after_name: If given, all results returned will be after the media with this name. The `start` and `stop` parameters are relative to this modified range.
         :param str archive_lifecycle: Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
@@ -114,15 +116,15 @@
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param _return_http_data_only: response data without head status code
                                        and headers
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
@@ -138,14 +140,15 @@
         all_params = [
             'project',
             'clone_media_spec',
             'media_id',
             'type',
             'name',
             'section',
+            'multi_section',
             'dtype',
             'md5',
             'gid',
             'uid',
             'after',
             'after_name',
             'archive_lifecycle',
@@ -201,14 +204,17 @@
             collection_formats['media_id'] = 'csv'  # noqa: E501
         if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
             query_params.append(('type', local_var_params['type']))  # noqa: E501
         if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
             query_params.append(('name', local_var_params['name']))  # noqa: E501
         if 'section' in local_var_params and local_var_params['section'] is not None:  # noqa: E501
             query_params.append(('section', local_var_params['section']))  # noqa: E501
+        if 'multi_section' in local_var_params and local_var_params['multi_section'] is not None:  # noqa: E501
+            query_params.append(('multi_section', local_var_params['multi_section']))  # noqa: E501
+            collection_formats['multi_section'] = 'csv'  # noqa: E501
         if 'dtype' in local_var_params and local_var_params['dtype'] is not None:  # noqa: E501
             query_params.append(('dtype', local_var_params['dtype']))  # noqa: E501
         if 'md5' in local_var_params and local_var_params['md5'] is not None:  # noqa: E501
             query_params.append(('md5', local_var_params['md5']))  # noqa: E501
         if 'gid' in local_var_params and local_var_params['gid'] is not None:  # noqa: E501
             query_params.append(('gid', local_var_params['gid']))  # noqa: E501
         if 'uid' in local_var_params and local_var_params['uid'] is not None:  # noqa: E501
@@ -1615,14 +1621,144 @@
             auth_settings=auth_settings,
             async_req=local_var_params.get('async_req'),
             _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
             _preload_content=local_var_params.get('_preload_content', True),
             _request_timeout=local_var_params.get('_request_timeout',300),
             collection_formats=collection_formats)
 
+    def create_hosted_template(self, organization, hosted_template_spec, **kwargs):
+        """create_hosted_template
+
+         Create a hosted template.  This endpoint replicates the hosted template creation through the admin portal. 
+
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.create_hosted_template(organization, hosted_template_spec, async_req=True)
+        >>> result = thread.get()
+
+        :param bool async_req: execute request asynchronously
+        :param int organization: A unique integer identifying an organization. (required)
+        :param HostedTemplateSpec hosted_template_spec: (required)
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts. Default is 300.
+        :return: :class:`tator.models.CreateResponse`
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.create_hosted_template_with_http_info(organization, hosted_template_spec, **kwargs)  # noqa: E501
+
+    def create_hosted_template_with_http_info(self, organization, hosted_template_spec, **kwargs):  # noqa: E501
+        """
+         Create a hosted template.  This endpoint replicates the hosted template creation through the admin portal.   # noqa: E501
+
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.create_hosted_template_with_http_info(organization, hosted_template_spec, async_req=True)
+        >>> result = thread.get()
+
+        :param bool async_req: execute request asynchronously
+        :param int organization: A unique integer identifying an organization. (required)
+        :param HostedTemplateSpec hosted_template_spec: (required)
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts. Default is 300.
+        :return: tuple(:class:`tator.models.CreateResponse`, status_code(int), headers(HTTPHeaderDict))
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+
+        local_var_params = locals()
+
+        all_params = [
+            'organization',
+            'hosted_template_spec'
+        ]
+        all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout'
+            ]
+        )
+
+        for key, val in six.iteritems(local_var_params['kwargs']):
+            if key not in all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method create_hosted_template" % key
+                )
+            local_var_params[key] = val
+        del local_var_params['kwargs']
+        # verify the required parameter 'organization' is set
+        if self.api_client.client_side_validation and ('organization' not in local_var_params or  # noqa: E501
+                                                        local_var_params['organization'] is None):  # noqa: E501
+            raise ApiValueError("Missing the required parameter `organization` when calling `create_hosted_template`")  # noqa: E501
+        # verify the required parameter 'hosted_template_spec' is set
+        if self.api_client.client_side_validation and ('hosted_template_spec' not in local_var_params or  # noqa: E501
+                                                        local_var_params['hosted_template_spec'] is None):  # noqa: E501
+            raise ApiValueError("Missing the required parameter `hosted_template_spec` when calling `create_hosted_template`")  # noqa: E501
+
+        collection_formats = {}
+
+        path_params = {}
+        if 'organization' in local_var_params:
+            path_params['organization'] = local_var_params['organization']  # noqa: E501
+
+        query_params = []
+
+        header_params = {}
+
+        form_params = []
+        local_var_files = {}
+
+        body_params = None
+        if 'hosted_template_spec' in local_var_params:
+            body_params = local_var_params['hosted_template_spec']
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json'])  # noqa: E501
+
+        # HTTP header `Content-Type`
+        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
+            ['application/json'])  # noqa: E501
+
+        # Authentication setting
+        auth_settings = ['SessionAuth', 'TokenAuth']  # noqa: E501
+
+        return self.api_client.call_api(
+            '/rest/HostedTemplates/{organization}', 'POST',
+            path_params,
+            query_params,
+            header_params,
+            body=body_params,
+            post_params=form_params,
+            files=local_var_files,
+            response_type='CreateResponse',  # noqa: E501
+            auth_settings=auth_settings,
+            async_req=local_var_params.get('async_req'),
+            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=local_var_params.get('_preload_content', True),
+            _request_timeout=local_var_params.get('_request_timeout',300),
+            collection_formats=collection_formats)
+
     def create_image_file(self, id, role, image_definition, **kwargs):
         """create_image_file
 
         Create image file.  Image files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying image. One or more image files can be used to reference thumbnails, thumbnail GIFs, or images in a `Media` object. The file itself must first be  uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the image file's `path` field. 
 
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -5923,14 +6059,131 @@
             auth_settings=auth_settings,
             async_req=local_var_params.get('async_req'),
             _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
             _preload_content=local_var_params.get('_preload_content', True),
             _request_timeout=local_var_params.get('_request_timeout',300),
             collection_formats=collection_formats)
 
+    def delete_hosted_template(self, id, **kwargs):
+        """delete_hosted_template
+
+        Delete registered hosted template
+
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.delete_hosted_template(id, async_req=True)
+        >>> result = thread.get()
+
+        :param bool async_req: execute request asynchronously
+        :param int id: A unique integer identifying a registered hosted template. (required)
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts. Default is 300.
+        :return: :class:`tator.models.MessageResponse`
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.delete_hosted_template_with_http_info(id, **kwargs)  # noqa: E501
+
+    def delete_hosted_template_with_http_info(self, id, **kwargs):  # noqa: E501
+        """
+        Delete registered hosted template  # noqa: E501
+
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.delete_hosted_template_with_http_info(id, async_req=True)
+        >>> result = thread.get()
+
+        :param bool async_req: execute request asynchronously
+        :param int id: A unique integer identifying a registered hosted template. (required)
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts. Default is 300.
+        :return: tuple(:class:`tator.models.MessageResponse`, status_code(int), headers(HTTPHeaderDict))
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+
+        local_var_params = locals()
+
+        all_params = [
+            'id'
+        ]
+        all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout'
+            ]
+        )
+
+        for key, val in six.iteritems(local_var_params['kwargs']):
+            if key not in all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method delete_hosted_template" % key
+                )
+            local_var_params[key] = val
+        del local_var_params['kwargs']
+        # verify the required parameter 'id' is set
+        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
+                                                        local_var_params['id'] is None):  # noqa: E501
+            raise ApiValueError("Missing the required parameter `id` when calling `delete_hosted_template`")  # noqa: E501
+
+        collection_formats = {}
+
+        path_params = {}
+        if 'id' in local_var_params:
+            path_params['id'] = local_var_params['id']  # noqa: E501
+
+        query_params = []
+
+        header_params = {}
+
+        form_params = []
+        local_var_files = {}
+
+        body_params = None
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json'])  # noqa: E501
+
+        # Authentication setting
+        auth_settings = ['SessionAuth', 'TokenAuth']  # noqa: E501
+
+        return self.api_client.call_api(
+            '/rest/HostedTemplate/{id}', 'DELETE',
+            path_params,
+            query_params,
+            header_params,
+            body=body_params,
+            post_params=form_params,
+            files=local_var_files,
+            response_type='MessageResponse',  # noqa: E501
+            auth_settings=auth_settings,
+            async_req=local_var_params.get('async_req'),
+            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=local_var_params.get('_preload_content', True),
+            _request_timeout=local_var_params.get('_request_timeout',300),
+            collection_formats=collection_formats)
+
     def delete_image_file(self, id, role, index, **kwargs):
         """delete_image_file
 
         Delete image file.  Image files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying image. One or more image files can be used to reference thumbnails, thumbnail GIFs, or images in a `Media` object. The file itself must first be  uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the image file's `path` field. 
 
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -6425,14 +6678,15 @@
 
         >>> thread = api.delete_job_list(project, async_req=True)
         >>> result = thread.get()
 
         :param bool async_req: execute request asynchronously
         :param int project: A unique integer identifying a project. (required)
         :param str gid: A UUID string identifying a group of jobs.
+        :param list[int] media_id: Comma-separated list of media IDs.
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts. Default is 300.
@@ -6452,14 +6706,15 @@
 
         >>> thread = api.delete_job_list_with_http_info(project, async_req=True)
         >>> result = thread.get()
 
         :param bool async_req: execute request asynchronously
         :param int project: A unique integer identifying a project. (required)
         :param str gid: A UUID string identifying a group of jobs.
+        :param list[int] media_id: Comma-separated list of media IDs.
         :param _return_http_data_only: response data without head status code
                                        and headers
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
@@ -6470,15 +6725,16 @@
                  returns the request thread.
         """
 
         local_var_params = locals()
 
         all_params = [
             'project',
-            'gid'
+            'gid',
+            'media_id'
         ]
         all_params.extend(
             [
                 'async_req',
                 '_return_http_data_only',
                 '_preload_content',
                 '_request_timeout'
@@ -6503,14 +6759,17 @@
         path_params = {}
         if 'project' in local_var_params:
             path_params['project'] = local_var_params['project']  # noqa: E501
 
         query_params = []
         if 'gid' in local_var_params and local_var_params['gid'] is not None:  # noqa: E501
             query_params.append(('gid', local_var_params['gid']))  # noqa: E501
+        if 'media_id' in local_var_params and local_var_params['media_id'] is not None:  # noqa: E501
+            query_params.append(('media_id', local_var_params['media_id']))  # noqa: E501
+            collection_formats['media_id'] = 'csv'  # noqa: E501
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
@@ -6678,15 +6937,16 @@
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
+        :param int count: Expected count of elements affected by this operation. If the number of elements differs from this count, the operation is aborted and 400 response is returned.
         :param LeafIdQuery leaf_id_query:
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -6721,15 +6981,16 @@
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
+        :param int count: Expected count of elements affected by this operation. If the number of elements differs from this count, the operation is aborted and 400 response is returned.
         :param LeafIdQuery leaf_id_query:
         :param _return_http_data_only: response data without head status code
                                        and headers
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
@@ -6757,14 +7018,15 @@
             'attribute_contains',
             'attribute_distance',
             'attribute_null',
             'start',
             'stop',
             'encoded_search',
             'sort_by',
+            'count',
             'leaf_id_query'
         ]
         all_params.extend(
             [
                 'async_req',
                 '_return_http_data_only',
                 '_preload_content',
@@ -6781,14 +7043,16 @@
             local_var_params[key] = val
         del local_var_params['kwargs']
         # verify the required parameter 'project' is set
         if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                         local_var_params['project'] is None):  # noqa: E501
             raise ApiValueError("Missing the required parameter `project` when calling `delete_leaf_list`")  # noqa: E501
 
+        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
+            raise ApiValueError("Invalid value for parameter `count` when calling `delete_leaf_list`, must be a value greater than or equal to `0`")  # noqa: E501
         collection_formats = {}
 
         path_params = {}
         if 'project' in local_var_params:
             path_params['project'] = local_var_params['project']  # noqa: E501
 
         query_params = []
@@ -6830,14 +7094,16 @@
         if 'stop' in local_var_params and local_var_params['stop'] is not None:  # noqa: E501
             query_params.append(('stop', local_var_params['stop']))  # noqa: E501
         if 'encoded_search' in local_var_params and local_var_params['encoded_search'] is not None:  # noqa: E501
             query_params.append(('encoded_search', local_var_params['encoded_search']))  # noqa: E501
         if 'sort_by' in local_var_params and local_var_params['sort_by'] is not None:  # noqa: E501
             query_params.append(('sort_by', local_var_params['sort_by']))  # noqa: E501
             collection_formats['sort_by'] = 'multi'  # noqa: E501
+        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
+            query_params.append(('count', local_var_params['count']))  # noqa: E501
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
@@ -7004,15 +7270,15 @@
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts. Default is 300.
-        :return: :class:`tator.models.MessageResponse`
+        :return: :class:`tator.models.InlineResponse200`
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
         return self.delete_localization_with_http_info(id, **kwargs)  # noqa: E501
 
     def delete_localization_with_http_info(self, id, **kwargs):  # noqa: E501
@@ -7033,15 +7299,15 @@
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts. Default is 300.
-        :return: tuple(:class:`tator.models.MessageResponse`, status_code(int), headers(HTTPHeaderDict))
+        :return: tuple(:class:`tator.models.InlineResponse200`, status_code(int), headers(HTTPHeaderDict))
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         local_var_params = locals()
 
         all_params = [
@@ -7101,15 +7367,150 @@
             '/rest/Localization/{id}', 'DELETE',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='MessageResponse',  # noqa: E501
+            response_type='InlineResponse200',  # noqa: E501
+            auth_settings=auth_settings,
+            async_req=local_var_params.get('async_req'),
+            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=local_var_params.get('_preload_content', True),
+            _request_timeout=local_var_params.get('_request_timeout',300),
+            collection_formats=collection_formats)
+
+    def delete_localization_by_elemental_id(self, version, elemental_id, **kwargs):
+        """delete_localization_by_elemental_id
+
+        Delete localization.  Localizations are shape annotations drawn on a video or image. Available shapes (`dtype`) are  box, line, or dot. Each shape is parameterized by a different subset of data members: - `box` uses `x`, `y`, `width`, `height`. - `line` uses `x`, `y`, `u`, `v`. - `dot` uses `x` and `y`. - `poly` uses `points`.  Geometry members may be left null when creating a localization, in which case the shapes may be  drawn later using the redraw capability in the web UI. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes. 
+
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.delete_localization_by_elemental_id(version, elemental_id, async_req=True)
+        >>> result = thread.get()
+
+        :param bool async_req: execute request asynchronously
+        :param int version: Version ID to select object from (required)
+        :param str elemental_id: Elemental ID to fetch (required)
+        :param LocalizationDelete localization_delete:
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts. Default is 300.
+        :return: :class:`tator.models.InlineResponse200`
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.delete_localization_by_elemental_id_with_http_info(version, elemental_id, **kwargs)  # noqa: E501
+
+    def delete_localization_by_elemental_id_with_http_info(self, version, elemental_id, **kwargs):  # noqa: E501
+        """
+        Delete localization.  Localizations are shape annotations drawn on a video or image. Available shapes (`dtype`) are  box, line, or dot. Each shape is parameterized by a different subset of data members: - `box` uses `x`, `y`, `width`, `height`. - `line` uses `x`, `y`, `u`, `v`. - `dot` uses `x` and `y`. - `poly` uses `points`.  Geometry members may be left null when creating a localization, in which case the shapes may be  drawn later using the redraw capability in the web UI. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes.   # noqa: E501
+
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.delete_localization_by_elemental_id_with_http_info(version, elemental_id, async_req=True)
+        >>> result = thread.get()
+
+        :param bool async_req: execute request asynchronously
+        :param int version: Version ID to select object from (required)
+        :param str elemental_id: Elemental ID to fetch (required)
+        :param LocalizationDelete localization_delete:
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts. Default is 300.
+        :return: tuple(:class:`tator.models.InlineResponse200`, status_code(int), headers(HTTPHeaderDict))
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+
+        local_var_params = locals()
+
+        all_params = [
+            'version',
+            'elemental_id',
+            'localization_delete'
+        ]
+        all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout'
+            ]
+        )
+
+        for key, val in six.iteritems(local_var_params['kwargs']):
+            if key not in all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method delete_localization_by_elemental_id" % key
+                )
+            local_var_params[key] = val
+        del local_var_params['kwargs']
+        # verify the required parameter 'version' is set
+        if self.api_client.client_side_validation and ('version' not in local_var_params or  # noqa: E501
+                                                        local_var_params['version'] is None):  # noqa: E501
+            raise ApiValueError("Missing the required parameter `version` when calling `delete_localization_by_elemental_id`")  # noqa: E501
+        # verify the required parameter 'elemental_id' is set
+        if self.api_client.client_side_validation and ('elemental_id' not in local_var_params or  # noqa: E501
+                                                        local_var_params['elemental_id'] is None):  # noqa: E501
+            raise ApiValueError("Missing the required parameter `elemental_id` when calling `delete_localization_by_elemental_id`")  # noqa: E501
+
+        collection_formats = {}
+
+        path_params = {}
+        if 'version' in local_var_params:
+            path_params['version'] = local_var_params['version']  # noqa: E501
+        if 'elemental_id' in local_var_params:
+            path_params['elemental_id'] = local_var_params['elemental_id']  # noqa: E501
+
+        query_params = []
+
+        header_params = {}
+
+        form_params = []
+        local_var_files = {}
+
+        body_params = None
+        if 'localization_delete' in local_var_params:
+            body_params = local_var_params['localization_delete']
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json'])  # noqa: E501
+
+        # HTTP header `Content-Type`
+        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
+            ['application/json'])  # noqa: E501
+
+        # Authentication setting
+        auth_settings = ['SessionAuth', 'TokenAuth']  # noqa: E501
+
+        return self.api_client.call_api(
+            '/rest/Localization/{version}/{elemental_id}', 'DELETE',
+            path_params,
+            query_params,
+            header_params,
+            body=body_params,
+            post_params=form_params,
+            files=local_var_files,
+            response_type='InlineResponse200',  # noqa: E501
             auth_settings=auth_settings,
             async_req=local_var_params.get('async_req'),
             _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
             _preload_content=local_var_params.get('_preload_content', True),
             _request_timeout=local_var_params.get('_request_timeout',300),
             collection_formats=collection_formats)
 
@@ -7131,36 +7532,38 @@
         :param int section: Unique integer identifying a media section.
         :param int type: Unique integer identifying a annotation type.
         :param list[int] version: List of integers representing versions to fetch
         :param int after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str elemental_id: Elemental ID to search for
         :param int merge: Reduce result set based on a server side merge. If multiple versions are selected and a variant of the object exists in both versions, the merge logic will return 1 or 0 objects. Example:  Version B derives off Version A. An object, with the same elemental id \"foo\" exists on both. If Version B over A is selected and merge is turned on: + The \"foo\" present on Version B is returned  + If the \"foo\" on version B is deleted, no \"foo\" is returned.
         :param int show_deleted: Include in the return set objects that have `variant_deleted` set to True.
+        :param int show_all_marks: Include in the return set all marks, not just the latest.
         :param list[str] attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param int frame: Frame number of this localization if it is in a video.
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param str encoded_related_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec applied against related objects
+        :param int count: Expected count of elements affected by this operation. If the number of elements differs from this count, the operation is aborted and 400 response is returned.
         :param LocalizationBulkDelete localization_bulk_delete:
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -7189,36 +7592,38 @@
         :param int section: Unique integer identifying a media section.
         :param int type: Unique integer identifying a annotation type.
         :param list[int] version: List of integers representing versions to fetch
         :param int after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str elemental_id: Elemental ID to search for
         :param int merge: Reduce result set based on a server side merge. If multiple versions are selected and a variant of the object exists in both versions, the merge logic will return 1 or 0 objects. Example:  Version B derives off Version A. An object, with the same elemental id \"foo\" exists on both. If Version B over A is selected and merge is turned on: + The \"foo\" present on Version B is returned  + If the \"foo\" on version B is deleted, no \"foo\" is returned.
         :param int show_deleted: Include in the return set objects that have `variant_deleted` set to True.
+        :param int show_all_marks: Include in the return set all marks, not just the latest.
         :param list[str] attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param int frame: Frame number of this localization if it is in a video.
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param str encoded_related_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec applied against related objects
+        :param int count: Expected count of elements affected by this operation. If the number of elements differs from this count, the operation is aborted and 400 response is returned.
         :param LocalizationBulkDelete localization_bulk_delete:
         :param _return_http_data_only: response data without head status code
                                        and headers
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
@@ -7239,14 +7644,15 @@
             'section',
             'type',
             'version',
             'after',
             'elemental_id',
             'merge',
             'show_deleted',
+            'show_all_marks',
             'attribute',
             'attribute_lt',
             'attribute_lte',
             'attribute_gt',
             'attribute_gte',
             'attribute_contains',
             'attribute_distance',
@@ -7261,14 +7667,15 @@
             'related_attribute_lte',
             'related_attribute_gt',
             'related_attribute_gte',
             'related_attribute_contains',
             'related_attribute_distance',
             'related_attribute_null',
             'encoded_related_search',
+            'count',
             'localization_bulk_delete'
         ]
         all_params.extend(
             [
                 'async_req',
                 '_return_http_data_only',
                 '_preload_content',
@@ -7293,16 +7700,22 @@
             raise ApiValueError("Invalid value for parameter `merge` when calling `delete_localization_list`, must be a value less than or equal to `1`")  # noqa: E501
         if self.api_client.client_side_validation and 'merge' in local_var_params and local_var_params['merge'] < 0:  # noqa: E501
             raise ApiValueError("Invalid value for parameter `merge` when calling `delete_localization_list`, must be a value greater than or equal to `0`")  # noqa: E501
         if self.api_client.client_side_validation and 'show_deleted' in local_var_params and local_var_params['show_deleted'] > 1:  # noqa: E501
             raise ApiValueError("Invalid value for parameter `show_deleted` when calling `delete_localization_list`, must be a value less than or equal to `1`")  # noqa: E501
         if self.api_client.client_side_validation and 'show_deleted' in local_var_params and local_var_params['show_deleted'] < 0:  # noqa: E501
             raise ApiValueError("Invalid value for parameter `show_deleted` when calling `delete_localization_list`, must be a value greater than or equal to `0`")  # noqa: E501
+        if self.api_client.client_side_validation and 'show_all_marks' in local_var_params and local_var_params['show_all_marks'] > 1:  # noqa: E501
+            raise ApiValueError("Invalid value for parameter `show_all_marks` when calling `delete_localization_list`, must be a value less than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and 'show_all_marks' in local_var_params and local_var_params['show_all_marks'] < 0:  # noqa: E501
+            raise ApiValueError("Invalid value for parameter `show_all_marks` when calling `delete_localization_list`, must be a value greater than or equal to `0`")  # noqa: E501
         if self.api_client.client_side_validation and 'frame' in local_var_params and local_var_params['frame'] < 0:  # noqa: E501
             raise ApiValueError("Invalid value for parameter `frame` when calling `delete_localization_list`, must be a value greater than or equal to `0`")  # noqa: E501
+        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
+            raise ApiValueError("Invalid value for parameter `count` when calling `delete_localization_list`, must be a value greater than or equal to `0`")  # noqa: E501
         collection_formats = {}
 
         path_params = {}
         if 'project' in local_var_params:
             path_params['project'] = local_var_params['project']  # noqa: E501
 
         query_params = []
@@ -7323,14 +7736,16 @@
             query_params.append(('after', local_var_params['after']))  # noqa: E501
         if 'elemental_id' in local_var_params and local_var_params['elemental_id'] is not None:  # noqa: E501
             query_params.append(('elemental_id', local_var_params['elemental_id']))  # noqa: E501
         if 'merge' in local_var_params and local_var_params['merge'] is not None:  # noqa: E501
             query_params.append(('merge', local_var_params['merge']))  # noqa: E501
         if 'show_deleted' in local_var_params and local_var_params['show_deleted'] is not None:  # noqa: E501
             query_params.append(('show_deleted', local_var_params['show_deleted']))  # noqa: E501
+        if 'show_all_marks' in local_var_params and local_var_params['show_all_marks'] is not None:  # noqa: E501
+            query_params.append(('show_all_marks', local_var_params['show_all_marks']))  # noqa: E501
         if 'attribute' in local_var_params and local_var_params['attribute'] is not None:  # noqa: E501
             query_params.append(('attribute', local_var_params['attribute']))  # noqa: E501
             collection_formats['attribute'] = 'csv'  # noqa: E501
         if 'attribute_lt' in local_var_params and local_var_params['attribute_lt'] is not None:  # noqa: E501
             query_params.append(('attribute_lt', local_var_params['attribute_lt']))  # noqa: E501
             collection_formats['attribute_lt'] = 'csv'  # noqa: E501
         if 'attribute_lte' in local_var_params and local_var_params['attribute_lte'] is not None:  # noqa: E501
@@ -7384,14 +7799,16 @@
             query_params.append(('related_attribute_distance', local_var_params['related_attribute_distance']))  # noqa: E501
             collection_formats['related_attribute_distance'] = 'csv'  # noqa: E501
         if 'related_attribute_null' in local_var_params and local_var_params['related_attribute_null'] is not None:  # noqa: E501
             query_params.append(('related_attribute_null', local_var_params['related_attribute_null']))  # noqa: E501
             collection_formats['related_attribute_null'] = 'csv'  # noqa: E501
         if 'encoded_related_search' in local_var_params and local_var_params['encoded_related_search'] is not None:  # noqa: E501
             query_params.append(('encoded_related_search', local_var_params['encoded_related_search']))  # noqa: E501
+        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
+            query_params.append(('count', local_var_params['count']))  # noqa: E501
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
@@ -7671,14 +8088,15 @@
 
         :param bool async_req: execute request asynchronously
         :param int project: A unique integer identifying a project. (required)
         :param list[int] media_id: List of integers identifying media.
         :param int type: Unique integer identifying media type.
         :param str name: Name of the media to filter on.
         :param int section: Unique integer identifying a media section.
+        :param list[int] multi_section: List of integers identifying sections to select.
         :param str dtype: Data type of the files, either image or video.
         :param str md5: MD5 sum of the media file.
         :param str gid: Upload group ID of the media file.
         :param str uid: Upload unique ID of the media file.
         :param int after: If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str after_name: If given, all results returned will be after the media with this name. The `start` and `stop` parameters are relative to this modified range.
         :param str archive_lifecycle: Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
@@ -7690,24 +8108,25 @@
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param str encoded_related_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec applied against related objects
+        :param int count: Expected count of elements affected by this operation. If the number of elements differs from this count, the operation is aborted and 400 response is returned.
         :param MediaIdQuery media_id_query:
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -7731,14 +8150,15 @@
 
         :param bool async_req: execute request asynchronously
         :param int project: A unique integer identifying a project. (required)
         :param list[int] media_id: List of integers identifying media.
         :param int type: Unique integer identifying media type.
         :param str name: Name of the media to filter on.
         :param int section: Unique integer identifying a media section.
+        :param list[int] multi_section: List of integers identifying sections to select.
         :param str dtype: Data type of the files, either image or video.
         :param str md5: MD5 sum of the media file.
         :param str gid: Upload group ID of the media file.
         :param str uid: Upload unique ID of the media file.
         :param int after: If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str after_name: If given, all results returned will be after the media with this name. The `start` and `stop` parameters are relative to this modified range.
         :param str archive_lifecycle: Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
@@ -7750,24 +8170,25 @@
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param str encoded_related_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec applied against related objects
+        :param int count: Expected count of elements affected by this operation. If the number of elements differs from this count, the operation is aborted and 400 response is returned.
         :param MediaIdQuery media_id_query:
         :param _return_http_data_only: response data without head status code
                                        and headers
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
@@ -7783,14 +8204,15 @@
 
         all_params = [
             'project',
             'media_id',
             'type',
             'name',
             'section',
+            'multi_section',
             'dtype',
             'md5',
             'gid',
             'uid',
             'after',
             'after_name',
             'archive_lifecycle',
@@ -7812,14 +8234,15 @@
             'related_attribute_lte',
             'related_attribute_gt',
             'related_attribute_gte',
             'related_attribute_contains',
             'related_attribute_distance',
             'related_attribute_null',
             'encoded_related_search',
+            'count',
             'media_id_query'
         ]
         all_params.extend(
             [
                 'async_req',
                 '_return_http_data_only',
                 '_preload_content',
@@ -7836,14 +8259,16 @@
             local_var_params[key] = val
         del local_var_params['kwargs']
         # verify the required parameter 'project' is set
         if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                         local_var_params['project'] is None):  # noqa: E501
             raise ApiValueError("Missing the required parameter `project` when calling `delete_media_list`")  # noqa: E501
 
+        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
+            raise ApiValueError("Invalid value for parameter `count` when calling `delete_media_list`, must be a value greater than or equal to `0`")  # noqa: E501
         collection_formats = {}
 
         path_params = {}
         if 'project' in local_var_params:
             path_params['project'] = local_var_params['project']  # noqa: E501
 
         query_params = []
@@ -7852,14 +8277,17 @@
             collection_formats['media_id'] = 'csv'  # noqa: E501
         if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
             query_params.append(('type', local_var_params['type']))  # noqa: E501
         if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
             query_params.append(('name', local_var_params['name']))  # noqa: E501
         if 'section' in local_var_params and local_var_params['section'] is not None:  # noqa: E501
             query_params.append(('section', local_var_params['section']))  # noqa: E501
+        if 'multi_section' in local_var_params and local_var_params['multi_section'] is not None:  # noqa: E501
+            query_params.append(('multi_section', local_var_params['multi_section']))  # noqa: E501
+            collection_formats['multi_section'] = 'csv'  # noqa: E501
         if 'dtype' in local_var_params and local_var_params['dtype'] is not None:  # noqa: E501
             query_params.append(('dtype', local_var_params['dtype']))  # noqa: E501
         if 'md5' in local_var_params and local_var_params['md5'] is not None:  # noqa: E501
             query_params.append(('md5', local_var_params['md5']))  # noqa: E501
         if 'gid' in local_var_params and local_var_params['gid'] is not None:  # noqa: E501
             query_params.append(('gid', local_var_params['gid']))  # noqa: E501
         if 'uid' in local_var_params and local_var_params['uid'] is not None:  # noqa: E501
@@ -7927,14 +8355,16 @@
             query_params.append(('related_attribute_distance', local_var_params['related_attribute_distance']))  # noqa: E501
             collection_formats['related_attribute_distance'] = 'csv'  # noqa: E501
         if 'related_attribute_null' in local_var_params and local_var_params['related_attribute_null'] is not None:  # noqa: E501
             query_params.append(('related_attribute_null', local_var_params['related_attribute_null']))  # noqa: E501
             collection_formats['related_attribute_null'] = 'csv'  # noqa: E501
         if 'encoded_related_search' in local_var_params and local_var_params['encoded_related_search'] is not None:  # noqa: E501
             query_params.append(('encoded_related_search', local_var_params['encoded_related_search']))  # noqa: E501
+        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
+            query_params.append(('count', local_var_params['count']))  # noqa: E501
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
@@ -8674,14 +9104,149 @@
             auth_settings=auth_settings,
             async_req=local_var_params.get('async_req'),
             _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
             _preload_content=local_var_params.get('_preload_content', True),
             _request_timeout=local_var_params.get('_request_timeout',300),
             collection_formats=collection_formats)
 
+    def delete_state_by_elemental_id(self, version, elemental_id, **kwargs):
+        """delete_state_by_elemental_id
+
+        Delete state.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes. 
+
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.delete_state_by_elemental_id(version, elemental_id, async_req=True)
+        >>> result = thread.get()
+
+        :param bool async_req: execute request asynchronously
+        :param int version: Version ID to select object from (required)
+        :param str elemental_id: Elemental ID to fetch (required)
+        :param StateDelete state_delete:
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts. Default is 300.
+        :return: :class:`tator.models.MessageResponse`
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.delete_state_by_elemental_id_with_http_info(version, elemental_id, **kwargs)  # noqa: E501
+
+    def delete_state_by_elemental_id_with_http_info(self, version, elemental_id, **kwargs):  # noqa: E501
+        """
+        Delete state.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes.   # noqa: E501
+
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.delete_state_by_elemental_id_with_http_info(version, elemental_id, async_req=True)
+        >>> result = thread.get()
+
+        :param bool async_req: execute request asynchronously
+        :param int version: Version ID to select object from (required)
+        :param str elemental_id: Elemental ID to fetch (required)
+        :param StateDelete state_delete:
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts. Default is 300.
+        :return: tuple(:class:`tator.models.MessageResponse`, status_code(int), headers(HTTPHeaderDict))
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+
+        local_var_params = locals()
+
+        all_params = [
+            'version',
+            'elemental_id',
+            'state_delete'
+        ]
+        all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout'
+            ]
+        )
+
+        for key, val in six.iteritems(local_var_params['kwargs']):
+            if key not in all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method delete_state_by_elemental_id" % key
+                )
+            local_var_params[key] = val
+        del local_var_params['kwargs']
+        # verify the required parameter 'version' is set
+        if self.api_client.client_side_validation and ('version' not in local_var_params or  # noqa: E501
+                                                        local_var_params['version'] is None):  # noqa: E501
+            raise ApiValueError("Missing the required parameter `version` when calling `delete_state_by_elemental_id`")  # noqa: E501
+        # verify the required parameter 'elemental_id' is set
+        if self.api_client.client_side_validation and ('elemental_id' not in local_var_params or  # noqa: E501
+                                                        local_var_params['elemental_id'] is None):  # noqa: E501
+            raise ApiValueError("Missing the required parameter `elemental_id` when calling `delete_state_by_elemental_id`")  # noqa: E501
+
+        collection_formats = {}
+
+        path_params = {}
+        if 'version' in local_var_params:
+            path_params['version'] = local_var_params['version']  # noqa: E501
+        if 'elemental_id' in local_var_params:
+            path_params['elemental_id'] = local_var_params['elemental_id']  # noqa: E501
+
+        query_params = []
+
+        header_params = {}
+
+        form_params = []
+        local_var_files = {}
+
+        body_params = None
+        if 'state_delete' in local_var_params:
+            body_params = local_var_params['state_delete']
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json'])  # noqa: E501
+
+        # HTTP header `Content-Type`
+        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
+            ['application/json'])  # noqa: E501
+
+        # Authentication setting
+        auth_settings = ['SessionAuth', 'TokenAuth']  # noqa: E501
+
+        return self.api_client.call_api(
+            '/rest/State/{version}/{elemental_id}', 'DELETE',
+            path_params,
+            query_params,
+            header_params,
+            body=body_params,
+            post_params=form_params,
+            files=local_var_files,
+            response_type='MessageResponse',  # noqa: E501
+            auth_settings=auth_settings,
+            async_req=local_var_params.get('async_req'),
+            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=local_var_params.get('_preload_content', True),
+            _request_timeout=local_var_params.get('_request_timeout',300),
+            collection_formats=collection_formats)
+
     def delete_state_list(self, project, **kwargs):
         """delete_state_list
 
         Delete state list.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes.   This method performs a bulk delete on all states matching a query. It is  recommended to use a GET request first to check what is being deleted. 
 
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -8696,35 +9261,37 @@
         :param int section: Unique integer identifying a media section.
         :param int type: Unique integer identifying a annotation type.
         :param list[int] version: List of integers representing versions to fetch
         :param int after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str elemental_id: Elemental ID to search for
         :param int merge: Reduce result set based on a server side merge. If multiple versions are selected and a variant of the object exists in both versions, the merge logic will return 1 or 0 objects. Example:  Version B derives off Version A. An object, with the same elemental id \"foo\" exists on both. If Version B over A is selected and merge is turned on: + The \"foo\" present on Version B is returned  + If the \"foo\" on version B is deleted, no \"foo\" is returned.
         :param int show_deleted: Include in the return set objects that have `variant_deleted` set to True.
+        :param int show_all_marks: Include in the return set all marks, not just the latest.
         :param list[str] attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param str encoded_related_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec applied against related objects
+        :param int count: Expected count of elements affected by this operation. If the number of elements differs from this count, the operation is aborted and 400 response is returned.
         :param StateBulkDelete state_bulk_delete:
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -8753,35 +9320,37 @@
         :param int section: Unique integer identifying a media section.
         :param int type: Unique integer identifying a annotation type.
         :param list[int] version: List of integers representing versions to fetch
         :param int after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str elemental_id: Elemental ID to search for
         :param int merge: Reduce result set based on a server side merge. If multiple versions are selected and a variant of the object exists in both versions, the merge logic will return 1 or 0 objects. Example:  Version B derives off Version A. An object, with the same elemental id \"foo\" exists on both. If Version B over A is selected and merge is turned on: + The \"foo\" present on Version B is returned  + If the \"foo\" on version B is deleted, no \"foo\" is returned.
         :param int show_deleted: Include in the return set objects that have `variant_deleted` set to True.
+        :param int show_all_marks: Include in the return set all marks, not just the latest.
         :param list[str] attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param str encoded_related_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec applied against related objects
+        :param int count: Expected count of elements affected by this operation. If the number of elements differs from this count, the operation is aborted and 400 response is returned.
         :param StateBulkDelete state_bulk_delete:
         :param _return_http_data_only: response data without head status code
                                        and headers
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
@@ -8802,14 +9371,15 @@
             'section',
             'type',
             'version',
             'after',
             'elemental_id',
             'merge',
             'show_deleted',
+            'show_all_marks',
             'attribute',
             'attribute_lt',
             'attribute_lte',
             'attribute_gt',
             'attribute_gte',
             'attribute_contains',
             'attribute_distance',
@@ -8823,14 +9393,15 @@
             'related_attribute_lte',
             'related_attribute_gt',
             'related_attribute_gte',
             'related_attribute_contains',
             'related_attribute_distance',
             'related_attribute_null',
             'encoded_related_search',
+            'count',
             'state_bulk_delete'
         ]
         all_params.extend(
             [
                 'async_req',
                 '_return_http_data_only',
                 '_preload_content',
@@ -8855,14 +9426,20 @@
             raise ApiValueError("Invalid value for parameter `merge` when calling `delete_state_list`, must be a value less than or equal to `1`")  # noqa: E501
         if self.api_client.client_side_validation and 'merge' in local_var_params and local_var_params['merge'] < 0:  # noqa: E501
             raise ApiValueError("Invalid value for parameter `merge` when calling `delete_state_list`, must be a value greater than or equal to `0`")  # noqa: E501
         if self.api_client.client_side_validation and 'show_deleted' in local_var_params and local_var_params['show_deleted'] > 1:  # noqa: E501
             raise ApiValueError("Invalid value for parameter `show_deleted` when calling `delete_state_list`, must be a value less than or equal to `1`")  # noqa: E501
         if self.api_client.client_side_validation and 'show_deleted' in local_var_params and local_var_params['show_deleted'] < 0:  # noqa: E501
             raise ApiValueError("Invalid value for parameter `show_deleted` when calling `delete_state_list`, must be a value greater than or equal to `0`")  # noqa: E501
+        if self.api_client.client_side_validation and 'show_all_marks' in local_var_params and local_var_params['show_all_marks'] > 1:  # noqa: E501
+            raise ApiValueError("Invalid value for parameter `show_all_marks` when calling `delete_state_list`, must be a value less than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and 'show_all_marks' in local_var_params and local_var_params['show_all_marks'] < 0:  # noqa: E501
+            raise ApiValueError("Invalid value for parameter `show_all_marks` when calling `delete_state_list`, must be a value greater than or equal to `0`")  # noqa: E501
+        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
+            raise ApiValueError("Invalid value for parameter `count` when calling `delete_state_list`, must be a value greater than or equal to `0`")  # noqa: E501
         collection_formats = {}
 
         path_params = {}
         if 'project' in local_var_params:
             path_params['project'] = local_var_params['project']  # noqa: E501
 
         query_params = []
@@ -8883,14 +9460,16 @@
             query_params.append(('after', local_var_params['after']))  # noqa: E501
         if 'elemental_id' in local_var_params and local_var_params['elemental_id'] is not None:  # noqa: E501
             query_params.append(('elemental_id', local_var_params['elemental_id']))  # noqa: E501
         if 'merge' in local_var_params and local_var_params['merge'] is not None:  # noqa: E501
             query_params.append(('merge', local_var_params['merge']))  # noqa: E501
         if 'show_deleted' in local_var_params and local_var_params['show_deleted'] is not None:  # noqa: E501
             query_params.append(('show_deleted', local_var_params['show_deleted']))  # noqa: E501
+        if 'show_all_marks' in local_var_params and local_var_params['show_all_marks'] is not None:  # noqa: E501
+            query_params.append(('show_all_marks', local_var_params['show_all_marks']))  # noqa: E501
         if 'attribute' in local_var_params and local_var_params['attribute'] is not None:  # noqa: E501
             query_params.append(('attribute', local_var_params['attribute']))  # noqa: E501
             collection_formats['attribute'] = 'csv'  # noqa: E501
         if 'attribute_lt' in local_var_params and local_var_params['attribute_lt'] is not None:  # noqa: E501
             query_params.append(('attribute_lt', local_var_params['attribute_lt']))  # noqa: E501
             collection_formats['attribute_lt'] = 'csv'  # noqa: E501
         if 'attribute_lte' in local_var_params and local_var_params['attribute_lte'] is not None:  # noqa: E501
@@ -8942,14 +9521,16 @@
             query_params.append(('related_attribute_distance', local_var_params['related_attribute_distance']))  # noqa: E501
             collection_formats['related_attribute_distance'] = 'csv'  # noqa: E501
         if 'related_attribute_null' in local_var_params and local_var_params['related_attribute_null'] is not None:  # noqa: E501
             query_params.append(('related_attribute_null', local_var_params['related_attribute_null']))  # noqa: E501
             collection_formats['related_attribute_null'] = 'csv'  # noqa: E501
         if 'encoded_related_search' in local_var_params and local_var_params['encoded_related_search'] is not None:  # noqa: E501
             query_params.append(('encoded_related_search', local_var_params['encoded_related_search']))  # noqa: E501
+        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
+            query_params.append(('count', local_var_params['count']))  # noqa: E501
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
@@ -9468,14 +10049,15 @@
 
         :param bool async_req: execute request asynchronously
         :param int project: A unique integer identifying a project. (required)
         :param list[int] media_id: List of integers identifying media.
         :param int type: Unique integer identifying media type.
         :param str name: Name of the media to filter on.
         :param int section: Unique integer identifying a media section.
+        :param list[int] multi_section: List of integers identifying sections to select.
         :param str dtype: Data type of the files, either image or video.
         :param str md5: MD5 sum of the media file.
         :param str gid: Upload group ID of the media file.
         :param str uid: Upload unique ID of the media file.
         :param int after: If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str after_name: If given, all results returned will be after the media with this name. The `start` and `stop` parameters are relative to this modified range.
         :param str archive_lifecycle: Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
@@ -9487,15 +10069,15 @@
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
@@ -9528,14 +10110,15 @@
 
         :param bool async_req: execute request asynchronously
         :param int project: A unique integer identifying a project. (required)
         :param list[int] media_id: List of integers identifying media.
         :param int type: Unique integer identifying media type.
         :param str name: Name of the media to filter on.
         :param int section: Unique integer identifying a media section.
+        :param list[int] multi_section: List of integers identifying sections to select.
         :param str dtype: Data type of the files, either image or video.
         :param str md5: MD5 sum of the media file.
         :param str gid: Upload group ID of the media file.
         :param str uid: Upload unique ID of the media file.
         :param int after: If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str after_name: If given, all results returned will be after the media with this name. The `start` and `stop` parameters are relative to this modified range.
         :param str archive_lifecycle: Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
@@ -9547,15 +10130,15 @@
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
@@ -9580,14 +10163,15 @@
 
         all_params = [
             'project',
             'media_id',
             'type',
             'name',
             'section',
+            'multi_section',
             'dtype',
             'md5',
             'gid',
             'uid',
             'after',
             'after_name',
             'archive_lifecycle',
@@ -9649,14 +10233,17 @@
             collection_formats['media_id'] = 'csv'  # noqa: E501
         if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
             query_params.append(('type', local_var_params['type']))  # noqa: E501
         if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
             query_params.append(('name', local_var_params['name']))  # noqa: E501
         if 'section' in local_var_params and local_var_params['section'] is not None:  # noqa: E501
             query_params.append(('section', local_var_params['section']))  # noqa: E501
+        if 'multi_section' in local_var_params and local_var_params['multi_section'] is not None:  # noqa: E501
+            query_params.append(('multi_section', local_var_params['multi_section']))  # noqa: E501
+            collection_formats['multi_section'] = 'csv'  # noqa: E501
         if 'dtype' in local_var_params and local_var_params['dtype'] is not None:  # noqa: E501
             query_params.append(('dtype', local_var_params['dtype']))  # noqa: E501
         if 'md5' in local_var_params and local_var_params['md5'] is not None:  # noqa: E501
             query_params.append(('md5', local_var_params['md5']))  # noqa: E501
         if 'gid' in local_var_params and local_var_params['gid'] is not None:  # noqa: E501
             query_params.append(('gid', local_var_params['gid']))  # noqa: E501
         if 'uid' in local_var_params and local_var_params['uid'] is not None:  # noqa: E501
@@ -10014,14 +10601,161 @@
             auth_settings=auth_settings,
             async_req=local_var_params.get('async_req'),
             _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
             _preload_content=local_var_params.get('_preload_content', True),
             _request_timeout=local_var_params.get('_request_timeout',300),
             collection_formats=collection_formats)
 
+    def destroy_section_list_api(self, project, **kwargs):
+        """destroy_section_list_api
+
+        Delete section list  Sections represent groups of media using saved queries.   
+
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.destroy_section_list_api(project, async_req=True)
+        >>> result = thread.get()
+
+        :param bool async_req: execute request asynchronously
+        :param int project: A unique integer identifying a project. (required)
+        :param str name: Name of the section.
+        :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
+        :param str elemental_id: Elemental ID to search for
+        :param str match: Find any sections matching using an lquery.                - foo         Match the exact label path foo             - *.foo.*     Match any label path containing the label foo             - *.foo       Match any label path whose last label is foo              Modifiers:             - @           Match case-insensitively, for example a@ matches A             - *           Match any label with this prefix, for example foo* matches foobar             - %           Match initial underscore-separated words              American@.Foot@*              would match both             america.Football and America.footwear                  For more information: https://www.postgresql.org/docs/current/ltree.html 
+        :param str ancestors: Find ancestors using using an lquery.                - foo         Match the exact label path foo             - *.foo.*     Match any label path containing the label foo             - *.foo       Match any label path whose last label is foo              Modifiers:             - @           Match case-insensitively, for example a@ matches A             - *           Match any label with this prefix, for example foo* matches foobar             - %           Match initial underscore-separated words              American@.Foot@*              would match both             america.Football and America.footwear                  For more information: https://www.postgresql.org/docs/current/ltree.html 
+        :param str descendants: Find descendants using using an lquery.                - foo         Match the exact label path foo             - *.foo.*     Match any label path containing the label foo             - *.foo       Match any label path whose last label is foo              Modifiers:             - @           Match case-insensitively, for example a@ matches A             - *           Match any label with this prefix, for example foo* matches foobar             - %           Match initial underscore-separated words              American@.Foot@*              would match both             america.Football and America.footwear                  For more information: https://www.postgresql.org/docs/current/ltree.html 
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts. Default is 300.
+        :return: None
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.destroy_section_list_api_with_http_info(project, **kwargs)  # noqa: E501
+
+    def destroy_section_list_api_with_http_info(self, project, **kwargs):  # noqa: E501
+        """
+        Delete section list  Sections represent groups of media using saved queries.     # noqa: E501
+
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.destroy_section_list_api_with_http_info(project, async_req=True)
+        >>> result = thread.get()
+
+        :param bool async_req: execute request asynchronously
+        :param int project: A unique integer identifying a project. (required)
+        :param str name: Name of the section.
+        :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
+        :param str elemental_id: Elemental ID to search for
+        :param str match: Find any sections matching using an lquery.                - foo         Match the exact label path foo             - *.foo.*     Match any label path containing the label foo             - *.foo       Match any label path whose last label is foo              Modifiers:             - @           Match case-insensitively, for example a@ matches A             - *           Match any label with this prefix, for example foo* matches foobar             - %           Match initial underscore-separated words              American@.Foot@*              would match both             america.Football and America.footwear                  For more information: https://www.postgresql.org/docs/current/ltree.html 
+        :param str ancestors: Find ancestors using using an lquery.                - foo         Match the exact label path foo             - *.foo.*     Match any label path containing the label foo             - *.foo       Match any label path whose last label is foo              Modifiers:             - @           Match case-insensitively, for example a@ matches A             - *           Match any label with this prefix, for example foo* matches foobar             - %           Match initial underscore-separated words              American@.Foot@*              would match both             america.Football and America.footwear                  For more information: https://www.postgresql.org/docs/current/ltree.html 
+        :param str descendants: Find descendants using using an lquery.                - foo         Match the exact label path foo             - *.foo.*     Match any label path containing the label foo             - *.foo       Match any label path whose last label is foo              Modifiers:             - @           Match case-insensitively, for example a@ matches A             - *           Match any label with this prefix, for example foo* matches foobar             - %           Match initial underscore-separated words              American@.Foot@*              would match both             america.Football and America.footwear                  For more information: https://www.postgresql.org/docs/current/ltree.html 
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts. Default is 300.
+        :return: None
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+
+        local_var_params = locals()
+
+        all_params = [
+            'project',
+            'name',
+            'encoded_search',
+            'elemental_id',
+            'match',
+            'ancestors',
+            'descendants'
+        ]
+        all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout'
+            ]
+        )
+
+        for key, val in six.iteritems(local_var_params['kwargs']):
+            if key not in all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method destroy_section_list_api" % key
+                )
+            local_var_params[key] = val
+        del local_var_params['kwargs']
+        # verify the required parameter 'project' is set
+        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
+                                                        local_var_params['project'] is None):  # noqa: E501
+            raise ApiValueError("Missing the required parameter `project` when calling `destroy_section_list_api`")  # noqa: E501
+
+        collection_formats = {}
+
+        path_params = {}
+        if 'project' in local_var_params:
+            path_params['project'] = local_var_params['project']  # noqa: E501
+
+        query_params = []
+        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
+            query_params.append(('name', local_var_params['name']))  # noqa: E501
+        if 'encoded_search' in local_var_params and local_var_params['encoded_search'] is not None:  # noqa: E501
+            query_params.append(('encoded_search', local_var_params['encoded_search']))  # noqa: E501
+        if 'elemental_id' in local_var_params and local_var_params['elemental_id'] is not None:  # noqa: E501
+            query_params.append(('elemental_id', local_var_params['elemental_id']))  # noqa: E501
+        if 'match' in local_var_params and local_var_params['match'] is not None:  # noqa: E501
+            query_params.append(('match', local_var_params['match']))  # noqa: E501
+        if 'ancestors' in local_var_params and local_var_params['ancestors'] is not None:  # noqa: E501
+            query_params.append(('ancestors', local_var_params['ancestors']))  # noqa: E501
+        if 'descendants' in local_var_params and local_var_params['descendants'] is not None:  # noqa: E501
+            query_params.append(('descendants', local_var_params['descendants']))  # noqa: E501
+
+        header_params = {}
+
+        form_params = []
+        local_var_files = {}
+
+        body_params = None
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json'])  # noqa: E501
+
+        # Authentication setting
+        auth_settings = ['SessionAuth', 'TokenAuth']  # noqa: E501
+
+        return self.api_client.call_api(
+            '/rest/Sections/{project}', 'DELETE',
+            path_params,
+            query_params,
+            header_params,
+            body=body_params,
+            post_params=form_params,
+            files=local_var_files,
+            response_type=None,  # noqa: E501
+            auth_settings=auth_settings,
+            async_req=local_var_params.get('async_req'),
+            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=local_var_params.get('_preload_content', True),
+            _request_timeout=local_var_params.get('_request_timeout',300),
+            collection_formats=collection_formats)
+
     def get_affiliation(self, id, **kwargs):
         """get_affiliation
 
         Get affiliation.  Affiliations specify a permission level of a user to an organization. There are currently two cumulative permission levels. `Member` can only view an organization and not change any data. `Admin` can modify an organization, add members to an organization, and create new projects under the organization's account. 
 
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -12715,15 +13449,15 @@
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts. Default is 300.
@@ -12757,15 +13491,15 @@
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param _return_http_data_only: response data without head status code
                                        and headers
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
@@ -13289,14 +14023,248 @@
             auth_settings=auth_settings,
             async_req=local_var_params.get('async_req'),
             _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
             _preload_content=local_var_params.get('_preload_content', True),
             _request_timeout=local_var_params.get('_request_timeout',300),
             collection_formats=collection_formats)
 
+    def get_hosted_template(self, id, **kwargs):
+        """get_hosted_template
+
+        Get registered hosted template
+
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.get_hosted_template(id, async_req=True)
+        >>> result = thread.get()
+
+        :param bool async_req: execute request asynchronously
+        :param int id: A unique integer identifying a registered hosted template. (required)
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts. Default is 300.
+        :return: :class:`tator.models.HostedTemplate`
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.get_hosted_template_with_http_info(id, **kwargs)  # noqa: E501
+
+    def get_hosted_template_with_http_info(self, id, **kwargs):  # noqa: E501
+        """
+        Get registered hosted template  # noqa: E501
+
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.get_hosted_template_with_http_info(id, async_req=True)
+        >>> result = thread.get()
+
+        :param bool async_req: execute request asynchronously
+        :param int id: A unique integer identifying a registered hosted template. (required)
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts. Default is 300.
+        :return: tuple(:class:`tator.models.HostedTemplate`, status_code(int), headers(HTTPHeaderDict))
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+
+        local_var_params = locals()
+
+        all_params = [
+            'id'
+        ]
+        all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout'
+            ]
+        )
+
+        for key, val in six.iteritems(local_var_params['kwargs']):
+            if key not in all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method get_hosted_template" % key
+                )
+            local_var_params[key] = val
+        del local_var_params['kwargs']
+        # verify the required parameter 'id' is set
+        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
+                                                        local_var_params['id'] is None):  # noqa: E501
+            raise ApiValueError("Missing the required parameter `id` when calling `get_hosted_template`")  # noqa: E501
+
+        collection_formats = {}
+
+        path_params = {}
+        if 'id' in local_var_params:
+            path_params['id'] = local_var_params['id']  # noqa: E501
+
+        query_params = []
+
+        header_params = {}
+
+        form_params = []
+        local_var_files = {}
+
+        body_params = None
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json'])  # noqa: E501
+
+        # Authentication setting
+        auth_settings = ['SessionAuth', 'TokenAuth']  # noqa: E501
+
+        return self.api_client.call_api(
+            '/rest/HostedTemplate/{id}', 'GET',
+            path_params,
+            query_params,
+            header_params,
+            body=body_params,
+            post_params=form_params,
+            files=local_var_files,
+            response_type='HostedTemplate',  # noqa: E501
+            auth_settings=auth_settings,
+            async_req=local_var_params.get('async_req'),
+            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=local_var_params.get('_preload_content', True),
+            _request_timeout=local_var_params.get('_request_timeout',300),
+            collection_formats=collection_formats)
+
+    def get_hosted_template_list(self, organization, **kwargs):
+        """get_hosted_template_list
+
+         Get hosted templates. 
+
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.get_hosted_template_list(organization, async_req=True)
+        >>> result = thread.get()
+
+        :param bool async_req: execute request asynchronously
+        :param int organization: A unique integer identifying an organization. (required)
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts. Default is 300.
+        :return: :class:`tator.models.list[HostedTemplate]`
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.get_hosted_template_list_with_http_info(organization, **kwargs)  # noqa: E501
+
+    def get_hosted_template_list_with_http_info(self, organization, **kwargs):  # noqa: E501
+        """
+         Get hosted templates.   # noqa: E501
+
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.get_hosted_template_list_with_http_info(organization, async_req=True)
+        >>> result = thread.get()
+
+        :param bool async_req: execute request asynchronously
+        :param int organization: A unique integer identifying an organization. (required)
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts. Default is 300.
+        :return: tuple(:class:`tator.models.list[HostedTemplate]`, status_code(int), headers(HTTPHeaderDict))
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+
+        local_var_params = locals()
+
+        all_params = [
+            'organization'
+        ]
+        all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout'
+            ]
+        )
+
+        for key, val in six.iteritems(local_var_params['kwargs']):
+            if key not in all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method get_hosted_template_list" % key
+                )
+            local_var_params[key] = val
+        del local_var_params['kwargs']
+        # verify the required parameter 'organization' is set
+        if self.api_client.client_side_validation and ('organization' not in local_var_params or  # noqa: E501
+                                                        local_var_params['organization'] is None):  # noqa: E501
+            raise ApiValueError("Missing the required parameter `organization` when calling `get_hosted_template_list`")  # noqa: E501
+
+        collection_formats = {}
+
+        path_params = {}
+        if 'organization' in local_var_params:
+            path_params['organization'] = local_var_params['organization']  # noqa: E501
+
+        query_params = []
+
+        header_params = {}
+
+        form_params = []
+        local_var_files = {}
+
+        body_params = None
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json'])  # noqa: E501
+
+        # Authentication setting
+        auth_settings = ['SessionAuth', 'TokenAuth']  # noqa: E501
+
+        return self.api_client.call_api(
+            '/rest/HostedTemplates/{organization}', 'GET',
+            path_params,
+            query_params,
+            header_params,
+            body=body_params,
+            post_params=form_params,
+            files=local_var_files,
+            response_type='list[HostedTemplate]',  # noqa: E501
+            auth_settings=auth_settings,
+            async_req=local_var_params.get('async_req'),
+            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=local_var_params.get('_preload_content', True),
+            _request_timeout=local_var_params.get('_request_timeout',300),
+            collection_formats=collection_formats)
+
     def get_image_file(self, id, role, index, **kwargs):
         """get_image_file
 
         Get image file.  Image files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying image. One or more image files can be used to reference thumbnails, thumbnail GIFs, or images in a `Media` object. The file itself must first be  uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the image file's `path` field. 
 
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -14151,14 +15119,15 @@
 
         >>> thread = api.get_job_list(project, async_req=True)
         >>> result = thread.get()
 
         :param bool async_req: execute request asynchronously
         :param int project: A unique integer identifying a project. (required)
         :param str gid: A UUID string identifying a group of jobs.
+        :param list[int] media_id: Comma-separated list of media IDs.
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts. Default is 300.
@@ -14178,14 +15147,15 @@
 
         >>> thread = api.get_job_list_with_http_info(project, async_req=True)
         >>> result = thread.get()
 
         :param bool async_req: execute request asynchronously
         :param int project: A unique integer identifying a project. (required)
         :param str gid: A UUID string identifying a group of jobs.
+        :param list[int] media_id: Comma-separated list of media IDs.
         :param _return_http_data_only: response data without head status code
                                        and headers
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
@@ -14196,15 +15166,16 @@
                  returns the request thread.
         """
 
         local_var_params = locals()
 
         all_params = [
             'project',
-            'gid'
+            'gid',
+            'media_id'
         ]
         all_params.extend(
             [
                 'async_req',
                 '_return_http_data_only',
                 '_preload_content',
                 '_request_timeout'
@@ -14229,14 +15200,17 @@
         path_params = {}
         if 'project' in local_var_params:
             path_params['project'] = local_var_params['project']  # noqa: E501
 
         query_params = []
         if 'gid' in local_var_params and local_var_params['gid'] is not None:  # noqa: E501
             query_params.append(('gid', local_var_params['gid']))  # noqa: E501
+        if 'media_id' in local_var_params and local_var_params['media_id'] is not None:  # noqa: E501
+            query_params.append(('media_id', local_var_params['media_id']))  # noqa: E501
+            collection_formats['media_id'] = 'csv'  # noqa: E501
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
@@ -14404,15 +15378,15 @@
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts. Default is 300.
@@ -14446,15 +15420,15 @@
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param _return_http_data_only: response data without head status code
                                        and headers
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
@@ -14612,15 +15586,15 @@
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts. Default is 300.
@@ -14655,15 +15629,15 @@
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param _return_http_data_only: response data without head status code
                                        and headers
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
@@ -14831,15 +15805,15 @@
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts. Default is 300.
@@ -14873,15 +15847,15 @@
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param _return_http_data_only: response data without head status code
                                        and headers
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
@@ -15039,15 +16013,15 @@
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts. Default is 300.
@@ -15082,15 +16056,15 @@
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param _return_http_data_only: response data without head status code
                                        and headers
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
@@ -15586,14 +16560,147 @@
             auth_settings=auth_settings,
             async_req=local_var_params.get('async_req'),
             _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
             _preload_content=local_var_params.get('_preload_content', True),
             _request_timeout=local_var_params.get('_request_timeout',300),
             collection_formats=collection_formats)
 
+    def get_localization_by_elemental_id(self, version, elemental_id, **kwargs):
+        """get_localization_by_elemental_id
+
+        Get localization.  Localizations are shape annotations drawn on a video or image. Available shapes (`dtype`) are  box, line, or dot. Each shape is parameterized by a different subset of data members: - `box` uses `x`, `y`, `width`, `height`. - `line` uses `x`, `y`, `u`, `v`. - `dot` uses `x` and `y`. - `poly` uses `points`.  Geometry members may be left null when creating a localization, in which case the shapes may be  drawn later using the redraw capability in the web UI. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes. 
+
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.get_localization_by_elemental_id(version, elemental_id, async_req=True)
+        >>> result = thread.get()
+
+        :param bool async_req: execute request asynchronously
+        :param int version: Version ID to select object from (required)
+        :param str elemental_id: Elemental ID to fetch (required)
+        :param int mark: If given, select this mark of the element on this version. Defaults to LATEST.
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts. Default is 300.
+        :return: :class:`tator.models.Localization`
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.get_localization_by_elemental_id_with_http_info(version, elemental_id, **kwargs)  # noqa: E501
+
+    def get_localization_by_elemental_id_with_http_info(self, version, elemental_id, **kwargs):  # noqa: E501
+        """
+        Get localization.  Localizations are shape annotations drawn on a video or image. Available shapes (`dtype`) are  box, line, or dot. Each shape is parameterized by a different subset of data members: - `box` uses `x`, `y`, `width`, `height`. - `line` uses `x`, `y`, `u`, `v`. - `dot` uses `x` and `y`. - `poly` uses `points`.  Geometry members may be left null when creating a localization, in which case the shapes may be  drawn later using the redraw capability in the web UI. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes.   # noqa: E501
+
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.get_localization_by_elemental_id_with_http_info(version, elemental_id, async_req=True)
+        >>> result = thread.get()
+
+        :param bool async_req: execute request asynchronously
+        :param int version: Version ID to select object from (required)
+        :param str elemental_id: Elemental ID to fetch (required)
+        :param int mark: If given, select this mark of the element on this version. Defaults to LATEST.
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts. Default is 300.
+        :return: tuple(:class:`tator.models.Localization`, status_code(int), headers(HTTPHeaderDict))
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+
+        local_var_params = locals()
+
+        all_params = [
+            'version',
+            'elemental_id',
+            'mark'
+        ]
+        all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout'
+            ]
+        )
+
+        for key, val in six.iteritems(local_var_params['kwargs']):
+            if key not in all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method get_localization_by_elemental_id" % key
+                )
+            local_var_params[key] = val
+        del local_var_params['kwargs']
+        # verify the required parameter 'version' is set
+        if self.api_client.client_side_validation and ('version' not in local_var_params or  # noqa: E501
+                                                        local_var_params['version'] is None):  # noqa: E501
+            raise ApiValueError("Missing the required parameter `version` when calling `get_localization_by_elemental_id`")  # noqa: E501
+        # verify the required parameter 'elemental_id' is set
+        if self.api_client.client_side_validation and ('elemental_id' not in local_var_params or  # noqa: E501
+                                                        local_var_params['elemental_id'] is None):  # noqa: E501
+            raise ApiValueError("Missing the required parameter `elemental_id` when calling `get_localization_by_elemental_id`")  # noqa: E501
+
+        if self.api_client.client_side_validation and 'mark' in local_var_params and local_var_params['mark'] < 0:  # noqa: E501
+            raise ApiValueError("Invalid value for parameter `mark` when calling `get_localization_by_elemental_id`, must be a value greater than or equal to `0`")  # noqa: E501
+        collection_formats = {}
+
+        path_params = {}
+        if 'version' in local_var_params:
+            path_params['version'] = local_var_params['version']  # noqa: E501
+        if 'elemental_id' in local_var_params:
+            path_params['elemental_id'] = local_var_params['elemental_id']  # noqa: E501
+
+        query_params = []
+        if 'mark' in local_var_params and local_var_params['mark'] is not None:  # noqa: E501
+            query_params.append(('mark', local_var_params['mark']))  # noqa: E501
+
+        header_params = {}
+
+        form_params = []
+        local_var_files = {}
+
+        body_params = None
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json'])  # noqa: E501
+
+        # Authentication setting
+        auth_settings = ['SessionAuth', 'TokenAuth']  # noqa: E501
+
+        return self.api_client.call_api(
+            '/rest/Localization/{version}/{elemental_id}', 'GET',
+            path_params,
+            query_params,
+            header_params,
+            body=body_params,
+            post_params=form_params,
+            files=local_var_files,
+            response_type='Localization',  # noqa: E501
+            auth_settings=auth_settings,
+            async_req=local_var_params.get('async_req'),
+            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=local_var_params.get('_preload_content', True),
+            _request_timeout=local_var_params.get('_request_timeout',300),
+            collection_formats=collection_formats)
+
     def get_localization_count(self, project, **kwargs):
         """get_localization_count
 
         Get localization list count.  This endpoint accepts the same query parameters as a GET or PUT request to the `Localizations` endpoint, but only returns the number of localizations. 
 
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -15608,26 +16715,27 @@
         :param int section: Unique integer identifying a media section.
         :param int type: Unique integer identifying a annotation type.
         :param list[int] version: List of integers representing versions to fetch
         :param int after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str elemental_id: Elemental ID to search for
         :param int merge: Reduce result set based on a server side merge. If multiple versions are selected and a variant of the object exists in both versions, the merge logic will return 1 or 0 objects. Example:  Version B derives off Version A. An object, with the same elemental id \"foo\" exists on both. If Version B over A is selected and merge is turned on: + The \"foo\" present on Version B is returned  + If the \"foo\" on version B is deleted, no \"foo\" is returned.
         :param int show_deleted: Include in the return set objects that have `variant_deleted` set to True.
+        :param int show_all_marks: Include in the return set all marks, not just the latest.
         :param list[str] attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param int frame: Frame number of this localization if it is in a video.
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
@@ -15665,26 +16773,27 @@
         :param int section: Unique integer identifying a media section.
         :param int type: Unique integer identifying a annotation type.
         :param list[int] version: List of integers representing versions to fetch
         :param int after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str elemental_id: Elemental ID to search for
         :param int merge: Reduce result set based on a server side merge. If multiple versions are selected and a variant of the object exists in both versions, the merge logic will return 1 or 0 objects. Example:  Version B derives off Version A. An object, with the same elemental id \"foo\" exists on both. If Version B over A is selected and merge is turned on: + The \"foo\" present on Version B is returned  + If the \"foo\" on version B is deleted, no \"foo\" is returned.
         :param int show_deleted: Include in the return set objects that have `variant_deleted` set to True.
+        :param int show_all_marks: Include in the return set all marks, not just the latest.
         :param list[str] attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param int frame: Frame number of this localization if it is in a video.
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
@@ -15714,14 +16823,15 @@
             'section',
             'type',
             'version',
             'after',
             'elemental_id',
             'merge',
             'show_deleted',
+            'show_all_marks',
             'attribute',
             'attribute_lt',
             'attribute_lte',
             'attribute_gt',
             'attribute_gte',
             'attribute_contains',
             'attribute_distance',
@@ -15767,14 +16877,18 @@
             raise ApiValueError("Invalid value for parameter `merge` when calling `get_localization_count`, must be a value less than or equal to `1`")  # noqa: E501
         if self.api_client.client_side_validation and 'merge' in local_var_params and local_var_params['merge'] < 0:  # noqa: E501
             raise ApiValueError("Invalid value for parameter `merge` when calling `get_localization_count`, must be a value greater than or equal to `0`")  # noqa: E501
         if self.api_client.client_side_validation and 'show_deleted' in local_var_params and local_var_params['show_deleted'] > 1:  # noqa: E501
             raise ApiValueError("Invalid value for parameter `show_deleted` when calling `get_localization_count`, must be a value less than or equal to `1`")  # noqa: E501
         if self.api_client.client_side_validation and 'show_deleted' in local_var_params and local_var_params['show_deleted'] < 0:  # noqa: E501
             raise ApiValueError("Invalid value for parameter `show_deleted` when calling `get_localization_count`, must be a value greater than or equal to `0`")  # noqa: E501
+        if self.api_client.client_side_validation and 'show_all_marks' in local_var_params and local_var_params['show_all_marks'] > 1:  # noqa: E501
+            raise ApiValueError("Invalid value for parameter `show_all_marks` when calling `get_localization_count`, must be a value less than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and 'show_all_marks' in local_var_params and local_var_params['show_all_marks'] < 0:  # noqa: E501
+            raise ApiValueError("Invalid value for parameter `show_all_marks` when calling `get_localization_count`, must be a value greater than or equal to `0`")  # noqa: E501
         if self.api_client.client_side_validation and 'frame' in local_var_params and local_var_params['frame'] < 0:  # noqa: E501
             raise ApiValueError("Invalid value for parameter `frame` when calling `get_localization_count`, must be a value greater than or equal to `0`")  # noqa: E501
         collection_formats = {}
 
         path_params = {}
         if 'project' in local_var_params:
             path_params['project'] = local_var_params['project']  # noqa: E501
@@ -15797,14 +16911,16 @@
             query_params.append(('after', local_var_params['after']))  # noqa: E501
         if 'elemental_id' in local_var_params and local_var_params['elemental_id'] is not None:  # noqa: E501
             query_params.append(('elemental_id', local_var_params['elemental_id']))  # noqa: E501
         if 'merge' in local_var_params and local_var_params['merge'] is not None:  # noqa: E501
             query_params.append(('merge', local_var_params['merge']))  # noqa: E501
         if 'show_deleted' in local_var_params and local_var_params['show_deleted'] is not None:  # noqa: E501
             query_params.append(('show_deleted', local_var_params['show_deleted']))  # noqa: E501
+        if 'show_all_marks' in local_var_params and local_var_params['show_all_marks'] is not None:  # noqa: E501
+            query_params.append(('show_all_marks', local_var_params['show_all_marks']))  # noqa: E501
         if 'attribute' in local_var_params and local_var_params['attribute'] is not None:  # noqa: E501
             query_params.append(('attribute', local_var_params['attribute']))  # noqa: E501
             collection_formats['attribute'] = 'csv'  # noqa: E501
         if 'attribute_lt' in local_var_params and local_var_params['attribute_lt'] is not None:  # noqa: E501
             query_params.append(('attribute_lt', local_var_params['attribute_lt']))  # noqa: E501
             collection_formats['attribute_lt'] = 'csv'  # noqa: E501
         if 'attribute_lte' in local_var_params and local_var_params['attribute_lte'] is not None:  # noqa: E501
@@ -15911,26 +17027,27 @@
         :param int section: Unique integer identifying a media section.
         :param int type: Unique integer identifying a annotation type.
         :param list[int] version: List of integers representing versions to fetch
         :param int after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str elemental_id: Elemental ID to search for
         :param int merge: Reduce result set based on a server side merge. If multiple versions are selected and a variant of the object exists in both versions, the merge logic will return 1 or 0 objects. Example:  Version B derives off Version A. An object, with the same elemental id \"foo\" exists on both. If Version B over A is selected and merge is turned on: + The \"foo\" present on Version B is returned  + If the \"foo\" on version B is deleted, no \"foo\" is returned.
         :param int show_deleted: Include in the return set objects that have `variant_deleted` set to True.
+        :param int show_all_marks: Include in the return set all marks, not just the latest.
         :param list[str] attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param int frame: Frame number of this localization if it is in a video.
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
@@ -15969,26 +17086,27 @@
         :param int section: Unique integer identifying a media section.
         :param int type: Unique integer identifying a annotation type.
         :param list[int] version: List of integers representing versions to fetch
         :param int after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str elemental_id: Elemental ID to search for
         :param int merge: Reduce result set based on a server side merge. If multiple versions are selected and a variant of the object exists in both versions, the merge logic will return 1 or 0 objects. Example:  Version B derives off Version A. An object, with the same elemental id \"foo\" exists on both. If Version B over A is selected and merge is turned on: + The \"foo\" present on Version B is returned  + If the \"foo\" on version B is deleted, no \"foo\" is returned.
         :param int show_deleted: Include in the return set objects that have `variant_deleted` set to True.
+        :param int show_all_marks: Include in the return set all marks, not just the latest.
         :param list[str] attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param int frame: Frame number of this localization if it is in a video.
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
@@ -16019,14 +17137,15 @@
             'section',
             'type',
             'version',
             'after',
             'elemental_id',
             'merge',
             'show_deleted',
+            'show_all_marks',
             'attribute',
             'attribute_lt',
             'attribute_lte',
             'attribute_gt',
             'attribute_gte',
             'attribute_contains',
             'attribute_distance',
@@ -16076,14 +17195,18 @@
             raise ApiValueError("Invalid value for parameter `merge` when calling `get_localization_count_by_id`, must be a value less than or equal to `1`")  # noqa: E501
         if self.api_client.client_side_validation and 'merge' in local_var_params and local_var_params['merge'] < 0:  # noqa: E501
             raise ApiValueError("Invalid value for parameter `merge` when calling `get_localization_count_by_id`, must be a value greater than or equal to `0`")  # noqa: E501
         if self.api_client.client_side_validation and 'show_deleted' in local_var_params and local_var_params['show_deleted'] > 1:  # noqa: E501
             raise ApiValueError("Invalid value for parameter `show_deleted` when calling `get_localization_count_by_id`, must be a value less than or equal to `1`")  # noqa: E501
         if self.api_client.client_side_validation and 'show_deleted' in local_var_params and local_var_params['show_deleted'] < 0:  # noqa: E501
             raise ApiValueError("Invalid value for parameter `show_deleted` when calling `get_localization_count_by_id`, must be a value greater than or equal to `0`")  # noqa: E501
+        if self.api_client.client_side_validation and 'show_all_marks' in local_var_params and local_var_params['show_all_marks'] > 1:  # noqa: E501
+            raise ApiValueError("Invalid value for parameter `show_all_marks` when calling `get_localization_count_by_id`, must be a value less than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and 'show_all_marks' in local_var_params and local_var_params['show_all_marks'] < 0:  # noqa: E501
+            raise ApiValueError("Invalid value for parameter `show_all_marks` when calling `get_localization_count_by_id`, must be a value greater than or equal to `0`")  # noqa: E501
         if self.api_client.client_side_validation and 'frame' in local_var_params and local_var_params['frame'] < 0:  # noqa: E501
             raise ApiValueError("Invalid value for parameter `frame` when calling `get_localization_count_by_id`, must be a value greater than or equal to `0`")  # noqa: E501
         collection_formats = {}
 
         path_params = {}
         if 'project' in local_var_params:
             path_params['project'] = local_var_params['project']  # noqa: E501
@@ -16106,14 +17229,16 @@
             query_params.append(('after', local_var_params['after']))  # noqa: E501
         if 'elemental_id' in local_var_params and local_var_params['elemental_id'] is not None:  # noqa: E501
             query_params.append(('elemental_id', local_var_params['elemental_id']))  # noqa: E501
         if 'merge' in local_var_params and local_var_params['merge'] is not None:  # noqa: E501
             query_params.append(('merge', local_var_params['merge']))  # noqa: E501
         if 'show_deleted' in local_var_params and local_var_params['show_deleted'] is not None:  # noqa: E501
             query_params.append(('show_deleted', local_var_params['show_deleted']))  # noqa: E501
+        if 'show_all_marks' in local_var_params and local_var_params['show_all_marks'] is not None:  # noqa: E501
+            query_params.append(('show_all_marks', local_var_params['show_all_marks']))  # noqa: E501
         if 'attribute' in local_var_params and local_var_params['attribute'] is not None:  # noqa: E501
             query_params.append(('attribute', local_var_params['attribute']))  # noqa: E501
             collection_formats['attribute'] = 'csv'  # noqa: E501
         if 'attribute_lt' in local_var_params and local_var_params['attribute_lt'] is not None:  # noqa: E501
             query_params.append(('attribute_lt', local_var_params['attribute_lt']))  # noqa: E501
             collection_formats['attribute_lt'] = 'csv'  # noqa: E501
         if 'attribute_lte' in local_var_params and local_var_params['attribute_lte'] is not None:  # noqa: E501
@@ -16362,26 +17487,27 @@
         :param int section: Unique integer identifying a media section.
         :param int type: Unique integer identifying a annotation type.
         :param list[int] version: List of integers representing versions to fetch
         :param int after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str elemental_id: Elemental ID to search for
         :param int merge: Reduce result set based on a server side merge. If multiple versions are selected and a variant of the object exists in both versions, the merge logic will return 1 or 0 objects. Example:  Version B derives off Version A. An object, with the same elemental id \"foo\" exists on both. If Version B over A is selected and merge is turned on: + The \"foo\" present on Version B is returned  + If the \"foo\" on version B is deleted, no \"foo\" is returned.
         :param int show_deleted: Include in the return set objects that have `variant_deleted` set to True.
+        :param int show_all_marks: Include in the return set all marks, not just the latest.
         :param list[str] attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param int frame: Frame number of this localization if it is in a video.
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
@@ -16419,26 +17545,27 @@
         :param int section: Unique integer identifying a media section.
         :param int type: Unique integer identifying a annotation type.
         :param list[int] version: List of integers representing versions to fetch
         :param int after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str elemental_id: Elemental ID to search for
         :param int merge: Reduce result set based on a server side merge. If multiple versions are selected and a variant of the object exists in both versions, the merge logic will return 1 or 0 objects. Example:  Version B derives off Version A. An object, with the same elemental id \"foo\" exists on both. If Version B over A is selected and merge is turned on: + The \"foo\" present on Version B is returned  + If the \"foo\" on version B is deleted, no \"foo\" is returned.
         :param int show_deleted: Include in the return set objects that have `variant_deleted` set to True.
+        :param int show_all_marks: Include in the return set all marks, not just the latest.
         :param list[str] attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param int frame: Frame number of this localization if it is in a video.
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
@@ -16468,14 +17595,15 @@
             'section',
             'type',
             'version',
             'after',
             'elemental_id',
             'merge',
             'show_deleted',
+            'show_all_marks',
             'attribute',
             'attribute_lt',
             'attribute_lte',
             'attribute_gt',
             'attribute_gte',
             'attribute_contains',
             'attribute_distance',
@@ -16521,14 +17649,18 @@
             raise ApiValueError("Invalid value for parameter `merge` when calling `get_localization_list`, must be a value less than or equal to `1`")  # noqa: E501
         if self.api_client.client_side_validation and 'merge' in local_var_params and local_var_params['merge'] < 0:  # noqa: E501
             raise ApiValueError("Invalid value for parameter `merge` when calling `get_localization_list`, must be a value greater than or equal to `0`")  # noqa: E501
         if self.api_client.client_side_validation and 'show_deleted' in local_var_params and local_var_params['show_deleted'] > 1:  # noqa: E501
             raise ApiValueError("Invalid value for parameter `show_deleted` when calling `get_localization_list`, must be a value less than or equal to `1`")  # noqa: E501
         if self.api_client.client_side_validation and 'show_deleted' in local_var_params and local_var_params['show_deleted'] < 0:  # noqa: E501
             raise ApiValueError("Invalid value for parameter `show_deleted` when calling `get_localization_list`, must be a value greater than or equal to `0`")  # noqa: E501
+        if self.api_client.client_side_validation and 'show_all_marks' in local_var_params and local_var_params['show_all_marks'] > 1:  # noqa: E501
+            raise ApiValueError("Invalid value for parameter `show_all_marks` when calling `get_localization_list`, must be a value less than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and 'show_all_marks' in local_var_params and local_var_params['show_all_marks'] < 0:  # noqa: E501
+            raise ApiValueError("Invalid value for parameter `show_all_marks` when calling `get_localization_list`, must be a value greater than or equal to `0`")  # noqa: E501
         if self.api_client.client_side_validation and 'frame' in local_var_params and local_var_params['frame'] < 0:  # noqa: E501
             raise ApiValueError("Invalid value for parameter `frame` when calling `get_localization_list`, must be a value greater than or equal to `0`")  # noqa: E501
         collection_formats = {}
 
         path_params = {}
         if 'project' in local_var_params:
             path_params['project'] = local_var_params['project']  # noqa: E501
@@ -16551,14 +17683,16 @@
             query_params.append(('after', local_var_params['after']))  # noqa: E501
         if 'elemental_id' in local_var_params and local_var_params['elemental_id'] is not None:  # noqa: E501
             query_params.append(('elemental_id', local_var_params['elemental_id']))  # noqa: E501
         if 'merge' in local_var_params and local_var_params['merge'] is not None:  # noqa: E501
             query_params.append(('merge', local_var_params['merge']))  # noqa: E501
         if 'show_deleted' in local_var_params and local_var_params['show_deleted'] is not None:  # noqa: E501
             query_params.append(('show_deleted', local_var_params['show_deleted']))  # noqa: E501
+        if 'show_all_marks' in local_var_params and local_var_params['show_all_marks'] is not None:  # noqa: E501
+            query_params.append(('show_all_marks', local_var_params['show_all_marks']))  # noqa: E501
         if 'attribute' in local_var_params and local_var_params['attribute'] is not None:  # noqa: E501
             query_params.append(('attribute', local_var_params['attribute']))  # noqa: E501
             collection_formats['attribute'] = 'csv'  # noqa: E501
         if 'attribute_lt' in local_var_params and local_var_params['attribute_lt'] is not None:  # noqa: E501
             query_params.append(('attribute_lt', local_var_params['attribute_lt']))  # noqa: E501
             collection_formats['attribute_lt'] = 'csv'  # noqa: E501
         if 'attribute_lte' in local_var_params and local_var_params['attribute_lte'] is not None:  # noqa: E501
@@ -16665,26 +17799,27 @@
         :param int section: Unique integer identifying a media section.
         :param int type: Unique integer identifying a annotation type.
         :param list[int] version: List of integers representing versions to fetch
         :param int after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str elemental_id: Elemental ID to search for
         :param int merge: Reduce result set based on a server side merge. If multiple versions are selected and a variant of the object exists in both versions, the merge logic will return 1 or 0 objects. Example:  Version B derives off Version A. An object, with the same elemental id \"foo\" exists on both. If Version B over A is selected and merge is turned on: + The \"foo\" present on Version B is returned  + If the \"foo\" on version B is deleted, no \"foo\" is returned.
         :param int show_deleted: Include in the return set objects that have `variant_deleted` set to True.
+        :param int show_all_marks: Include in the return set all marks, not just the latest.
         :param list[str] attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param int frame: Frame number of this localization if it is in a video.
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
@@ -16723,26 +17858,27 @@
         :param int section: Unique integer identifying a media section.
         :param int type: Unique integer identifying a annotation type.
         :param list[int] version: List of integers representing versions to fetch
         :param int after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str elemental_id: Elemental ID to search for
         :param int merge: Reduce result set based on a server side merge. If multiple versions are selected and a variant of the object exists in both versions, the merge logic will return 1 or 0 objects. Example:  Version B derives off Version A. An object, with the same elemental id \"foo\" exists on both. If Version B over A is selected and merge is turned on: + The \"foo\" present on Version B is returned  + If the \"foo\" on version B is deleted, no \"foo\" is returned.
         :param int show_deleted: Include in the return set objects that have `variant_deleted` set to True.
+        :param int show_all_marks: Include in the return set all marks, not just the latest.
         :param list[str] attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param int frame: Frame number of this localization if it is in a video.
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
@@ -16773,14 +17909,15 @@
             'section',
             'type',
             'version',
             'after',
             'elemental_id',
             'merge',
             'show_deleted',
+            'show_all_marks',
             'attribute',
             'attribute_lt',
             'attribute_lte',
             'attribute_gt',
             'attribute_gte',
             'attribute_contains',
             'attribute_distance',
@@ -16830,14 +17967,18 @@
             raise ApiValueError("Invalid value for parameter `merge` when calling `get_localization_list_by_id`, must be a value less than or equal to `1`")  # noqa: E501
         if self.api_client.client_side_validation and 'merge' in local_var_params and local_var_params['merge'] < 0:  # noqa: E501
             raise ApiValueError("Invalid value for parameter `merge` when calling `get_localization_list_by_id`, must be a value greater than or equal to `0`")  # noqa: E501
         if self.api_client.client_side_validation and 'show_deleted' in local_var_params and local_var_params['show_deleted'] > 1:  # noqa: E501
             raise ApiValueError("Invalid value for parameter `show_deleted` when calling `get_localization_list_by_id`, must be a value less than or equal to `1`")  # noqa: E501
         if self.api_client.client_side_validation and 'show_deleted' in local_var_params and local_var_params['show_deleted'] < 0:  # noqa: E501
             raise ApiValueError("Invalid value for parameter `show_deleted` when calling `get_localization_list_by_id`, must be a value greater than or equal to `0`")  # noqa: E501
+        if self.api_client.client_side_validation and 'show_all_marks' in local_var_params and local_var_params['show_all_marks'] > 1:  # noqa: E501
+            raise ApiValueError("Invalid value for parameter `show_all_marks` when calling `get_localization_list_by_id`, must be a value less than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and 'show_all_marks' in local_var_params and local_var_params['show_all_marks'] < 0:  # noqa: E501
+            raise ApiValueError("Invalid value for parameter `show_all_marks` when calling `get_localization_list_by_id`, must be a value greater than or equal to `0`")  # noqa: E501
         if self.api_client.client_side_validation and 'frame' in local_var_params and local_var_params['frame'] < 0:  # noqa: E501
             raise ApiValueError("Invalid value for parameter `frame` when calling `get_localization_list_by_id`, must be a value greater than or equal to `0`")  # noqa: E501
         collection_formats = {}
 
         path_params = {}
         if 'project' in local_var_params:
             path_params['project'] = local_var_params['project']  # noqa: E501
@@ -16860,14 +18001,16 @@
             query_params.append(('after', local_var_params['after']))  # noqa: E501
         if 'elemental_id' in local_var_params and local_var_params['elemental_id'] is not None:  # noqa: E501
             query_params.append(('elemental_id', local_var_params['elemental_id']))  # noqa: E501
         if 'merge' in local_var_params and local_var_params['merge'] is not None:  # noqa: E501
             query_params.append(('merge', local_var_params['merge']))  # noqa: E501
         if 'show_deleted' in local_var_params and local_var_params['show_deleted'] is not None:  # noqa: E501
             query_params.append(('show_deleted', local_var_params['show_deleted']))  # noqa: E501
+        if 'show_all_marks' in local_var_params and local_var_params['show_all_marks'] is not None:  # noqa: E501
+            query_params.append(('show_all_marks', local_var_params['show_all_marks']))  # noqa: E501
         if 'attribute' in local_var_params and local_var_params['attribute'] is not None:  # noqa: E501
             query_params.append(('attribute', local_var_params['attribute']))  # noqa: E501
             collection_formats['attribute'] = 'csv'  # noqa: E501
         if 'attribute_lt' in local_var_params and local_var_params['attribute_lt'] is not None:  # noqa: E501
             query_params.append(('attribute_lt', local_var_params['attribute_lt']))  # noqa: E501
             collection_formats['attribute_lt'] = 'csv'  # noqa: E501
         if 'attribute_lte' in local_var_params and local_var_params['attribute_lte'] is not None:  # noqa: E501
@@ -17355,14 +18498,15 @@
 
         :param bool async_req: execute request asynchronously
         :param int project: A unique integer identifying a project. (required)
         :param list[int] media_id: List of integers identifying media.
         :param int type: Unique integer identifying media type.
         :param str name: Name of the media to filter on.
         :param int section: Unique integer identifying a media section.
+        :param list[int] multi_section: List of integers identifying sections to select.
         :param str dtype: Data type of the files, either image or video.
         :param str md5: MD5 sum of the media file.
         :param str gid: Upload group ID of the media file.
         :param str uid: Upload unique ID of the media file.
         :param int after: If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str after_name: If given, all results returned will be after the media with this name. The `start` and `stop` parameters are relative to this modified range.
         :param str archive_lifecycle: Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
@@ -17374,15 +18518,15 @@
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
@@ -17414,14 +18558,15 @@
 
         :param bool async_req: execute request asynchronously
         :param int project: A unique integer identifying a project. (required)
         :param list[int] media_id: List of integers identifying media.
         :param int type: Unique integer identifying media type.
         :param str name: Name of the media to filter on.
         :param int section: Unique integer identifying a media section.
+        :param list[int] multi_section: List of integers identifying sections to select.
         :param str dtype: Data type of the files, either image or video.
         :param str md5: MD5 sum of the media file.
         :param str gid: Upload group ID of the media file.
         :param str uid: Upload unique ID of the media file.
         :param int after: If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str after_name: If given, all results returned will be after the media with this name. The `start` and `stop` parameters are relative to this modified range.
         :param str archive_lifecycle: Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
@@ -17433,15 +18578,15 @@
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
@@ -17465,14 +18610,15 @@
 
         all_params = [
             'project',
             'media_id',
             'type',
             'name',
             'section',
+            'multi_section',
             'dtype',
             'md5',
             'gid',
             'uid',
             'after',
             'after_name',
             'archive_lifecycle',
@@ -17533,14 +18679,17 @@
             collection_formats['media_id'] = 'csv'  # noqa: E501
         if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
             query_params.append(('type', local_var_params['type']))  # noqa: E501
         if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
             query_params.append(('name', local_var_params['name']))  # noqa: E501
         if 'section' in local_var_params and local_var_params['section'] is not None:  # noqa: E501
             query_params.append(('section', local_var_params['section']))  # noqa: E501
+        if 'multi_section' in local_var_params and local_var_params['multi_section'] is not None:  # noqa: E501
+            query_params.append(('multi_section', local_var_params['multi_section']))  # noqa: E501
+            collection_formats['multi_section'] = 'csv'  # noqa: E501
         if 'dtype' in local_var_params and local_var_params['dtype'] is not None:  # noqa: E501
             query_params.append(('dtype', local_var_params['dtype']))  # noqa: E501
         if 'md5' in local_var_params and local_var_params['md5'] is not None:  # noqa: E501
             query_params.append(('md5', local_var_params['md5']))  # noqa: E501
         if 'gid' in local_var_params and local_var_params['gid'] is not None:  # noqa: E501
             query_params.append(('gid', local_var_params['gid']))  # noqa: E501
         if 'uid' in local_var_params and local_var_params['uid'] is not None:  # noqa: E501
@@ -17656,14 +18805,15 @@
         :param bool async_req: execute request asynchronously
         :param int project: A unique integer identifying a project. (required)
         :param MediaIdQuery media_id_query: (required)
         :param list[int] media_id: List of integers identifying media.
         :param int type: Unique integer identifying media type.
         :param str name: Name of the media to filter on.
         :param int section: Unique integer identifying a media section.
+        :param list[int] multi_section: List of integers identifying sections to select.
         :param str dtype: Data type of the files, either image or video.
         :param str md5: MD5 sum of the media file.
         :param str gid: Upload group ID of the media file.
         :param str uid: Upload unique ID of the media file.
         :param int after: If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str after_name: If given, all results returned will be after the media with this name. The `start` and `stop` parameters are relative to this modified range.
         :param str archive_lifecycle: Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
@@ -17675,15 +18825,15 @@
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
@@ -17716,14 +18866,15 @@
         :param bool async_req: execute request asynchronously
         :param int project: A unique integer identifying a project. (required)
         :param MediaIdQuery media_id_query: (required)
         :param list[int] media_id: List of integers identifying media.
         :param int type: Unique integer identifying media type.
         :param str name: Name of the media to filter on.
         :param int section: Unique integer identifying a media section.
+        :param list[int] multi_section: List of integers identifying sections to select.
         :param str dtype: Data type of the files, either image or video.
         :param str md5: MD5 sum of the media file.
         :param str gid: Upload group ID of the media file.
         :param str uid: Upload unique ID of the media file.
         :param int after: If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str after_name: If given, all results returned will be after the media with this name. The `start` and `stop` parameters are relative to this modified range.
         :param str archive_lifecycle: Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
@@ -17735,15 +18886,15 @@
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
@@ -17768,14 +18919,15 @@
         all_params = [
             'project',
             'media_id_query',
             'media_id',
             'type',
             'name',
             'section',
+            'multi_section',
             'dtype',
             'md5',
             'gid',
             'uid',
             'after',
             'after_name',
             'archive_lifecycle',
@@ -17840,14 +18992,17 @@
             collection_formats['media_id'] = 'csv'  # noqa: E501
         if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
             query_params.append(('type', local_var_params['type']))  # noqa: E501
         if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
             query_params.append(('name', local_var_params['name']))  # noqa: E501
         if 'section' in local_var_params and local_var_params['section'] is not None:  # noqa: E501
             query_params.append(('section', local_var_params['section']))  # noqa: E501
+        if 'multi_section' in local_var_params and local_var_params['multi_section'] is not None:  # noqa: E501
+            query_params.append(('multi_section', local_var_params['multi_section']))  # noqa: E501
+            collection_formats['multi_section'] = 'csv'  # noqa: E501
         if 'dtype' in local_var_params and local_var_params['dtype'] is not None:  # noqa: E501
             query_params.append(('dtype', local_var_params['dtype']))  # noqa: E501
         if 'md5' in local_var_params and local_var_params['md5'] is not None:  # noqa: E501
             query_params.append(('md5', local_var_params['md5']))  # noqa: E501
         if 'gid' in local_var_params and local_var_params['gid'] is not None:  # noqa: E501
             query_params.append(('gid', local_var_params['gid']))  # noqa: E501
         if 'uid' in local_var_params and local_var_params['uid'] is not None:  # noqa: E501
@@ -17968,14 +19123,15 @@
 
         :param bool async_req: execute request asynchronously
         :param int project: A unique integer identifying a project. (required)
         :param list[int] media_id: List of integers identifying media.
         :param int type: Unique integer identifying media type.
         :param str name: Name of the media to filter on.
         :param int section: Unique integer identifying a media section.
+        :param list[int] multi_section: List of integers identifying sections to select.
         :param str dtype: Data type of the files, either image or video.
         :param str md5: MD5 sum of the media file.
         :param str gid: Upload group ID of the media file.
         :param str uid: Upload unique ID of the media file.
         :param int after: If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str after_name: If given, all results returned will be after the media with this name. The `start` and `stop` parameters are relative to this modified range.
         :param str archive_lifecycle: Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
@@ -17987,15 +19143,15 @@
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
@@ -18029,14 +19185,15 @@
 
         :param bool async_req: execute request asynchronously
         :param int project: A unique integer identifying a project. (required)
         :param list[int] media_id: List of integers identifying media.
         :param int type: Unique integer identifying media type.
         :param str name: Name of the media to filter on.
         :param int section: Unique integer identifying a media section.
+        :param list[int] multi_section: List of integers identifying sections to select.
         :param str dtype: Data type of the files, either image or video.
         :param str md5: MD5 sum of the media file.
         :param str gid: Upload group ID of the media file.
         :param str uid: Upload unique ID of the media file.
         :param int after: If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str after_name: If given, all results returned will be after the media with this name. The `start` and `stop` parameters are relative to this modified range.
         :param str archive_lifecycle: Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
@@ -18048,15 +19205,15 @@
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
@@ -18082,14 +19239,15 @@
 
         all_params = [
             'project',
             'media_id',
             'type',
             'name',
             'section',
+            'multi_section',
             'dtype',
             'md5',
             'gid',
             'uid',
             'after',
             'after_name',
             'archive_lifecycle',
@@ -18156,14 +19314,17 @@
             collection_formats['media_id'] = 'csv'  # noqa: E501
         if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
             query_params.append(('type', local_var_params['type']))  # noqa: E501
         if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
             query_params.append(('name', local_var_params['name']))  # noqa: E501
         if 'section' in local_var_params and local_var_params['section'] is not None:  # noqa: E501
             query_params.append(('section', local_var_params['section']))  # noqa: E501
+        if 'multi_section' in local_var_params and local_var_params['multi_section'] is not None:  # noqa: E501
+            query_params.append(('multi_section', local_var_params['multi_section']))  # noqa: E501
+            collection_formats['multi_section'] = 'csv'  # noqa: E501
         if 'dtype' in local_var_params and local_var_params['dtype'] is not None:  # noqa: E501
             query_params.append(('dtype', local_var_params['dtype']))  # noqa: E501
         if 'md5' in local_var_params and local_var_params['md5'] is not None:  # noqa: E501
             query_params.append(('md5', local_var_params['md5']))  # noqa: E501
         if 'gid' in local_var_params and local_var_params['gid'] is not None:  # noqa: E501
             query_params.append(('gid', local_var_params['gid']))  # noqa: E501
         if 'uid' in local_var_params and local_var_params['uid'] is not None:  # noqa: E501
@@ -18283,14 +19444,15 @@
         :param bool async_req: execute request asynchronously
         :param int project: A unique integer identifying a project. (required)
         :param MediaIdQuery media_id_query: (required)
         :param list[int] media_id: List of integers identifying media.
         :param int type: Unique integer identifying media type.
         :param str name: Name of the media to filter on.
         :param int section: Unique integer identifying a media section.
+        :param list[int] multi_section: List of integers identifying sections to select.
         :param str dtype: Data type of the files, either image or video.
         :param str md5: MD5 sum of the media file.
         :param str gid: Upload group ID of the media file.
         :param str uid: Upload unique ID of the media file.
         :param int after: If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str after_name: If given, all results returned will be after the media with this name. The `start` and `stop` parameters are relative to this modified range.
         :param str archive_lifecycle: Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
@@ -18302,15 +19464,15 @@
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
@@ -18345,14 +19507,15 @@
         :param bool async_req: execute request asynchronously
         :param int project: A unique integer identifying a project. (required)
         :param MediaIdQuery media_id_query: (required)
         :param list[int] media_id: List of integers identifying media.
         :param int type: Unique integer identifying media type.
         :param str name: Name of the media to filter on.
         :param int section: Unique integer identifying a media section.
+        :param list[int] multi_section: List of integers identifying sections to select.
         :param str dtype: Data type of the files, either image or video.
         :param str md5: MD5 sum of the media file.
         :param str gid: Upload group ID of the media file.
         :param str uid: Upload unique ID of the media file.
         :param int after: If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str after_name: If given, all results returned will be after the media with this name. The `start` and `stop` parameters are relative to this modified range.
         :param str archive_lifecycle: Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
@@ -18364,15 +19527,15 @@
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
@@ -18399,14 +19562,15 @@
         all_params = [
             'project',
             'media_id_query',
             'media_id',
             'type',
             'name',
             'section',
+            'multi_section',
             'dtype',
             'md5',
             'gid',
             'uid',
             'after',
             'after_name',
             'archive_lifecycle',
@@ -18477,14 +19641,17 @@
             collection_formats['media_id'] = 'csv'  # noqa: E501
         if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
             query_params.append(('type', local_var_params['type']))  # noqa: E501
         if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
             query_params.append(('name', local_var_params['name']))  # noqa: E501
         if 'section' in local_var_params and local_var_params['section'] is not None:  # noqa: E501
             query_params.append(('section', local_var_params['section']))  # noqa: E501
+        if 'multi_section' in local_var_params and local_var_params['multi_section'] is not None:  # noqa: E501
+            query_params.append(('multi_section', local_var_params['multi_section']))  # noqa: E501
+            collection_formats['multi_section'] = 'csv'  # noqa: E501
         if 'dtype' in local_var_params and local_var_params['dtype'] is not None:  # noqa: E501
             query_params.append(('dtype', local_var_params['dtype']))  # noqa: E501
         if 'md5' in local_var_params and local_var_params['md5'] is not None:  # noqa: E501
             query_params.append(('md5', local_var_params['md5']))  # noqa: E501
         if 'gid' in local_var_params and local_var_params['gid'] is not None:  # noqa: E501
             query_params.append(('gid', local_var_params['gid']))  # noqa: E501
         if 'uid' in local_var_params and local_var_params['uid'] is not None:  # noqa: E501
@@ -18609,14 +19776,15 @@
 
         :param bool async_req: execute request asynchronously
         :param int id: A unique integer identifying a media object. (required)
         :param list[int] media_id: List of integers identifying media.
         :param int type: Unique integer identifying media type.
         :param str name: Name of the media to filter on.
         :param int section: Unique integer identifying a media section.
+        :param list[int] multi_section: List of integers identifying sections to select.
         :param str dtype: Data type of the files, either image or video.
         :param str md5: MD5 sum of the media file.
         :param str gid: Upload group ID of the media file.
         :param str uid: Upload unique ID of the media file.
         :param int after: If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str after_name: If given, all results returned will be after the media with this name. The `start` and `stop` parameters are relative to this modified range.
         :param str archive_lifecycle: Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
@@ -18628,15 +19796,15 @@
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
@@ -18668,14 +19836,15 @@
 
         :param bool async_req: execute request asynchronously
         :param int id: A unique integer identifying a media object. (required)
         :param list[int] media_id: List of integers identifying media.
         :param int type: Unique integer identifying media type.
         :param str name: Name of the media to filter on.
         :param int section: Unique integer identifying a media section.
+        :param list[int] multi_section: List of integers identifying sections to select.
         :param str dtype: Data type of the files, either image or video.
         :param str md5: MD5 sum of the media file.
         :param str gid: Upload group ID of the media file.
         :param str uid: Upload unique ID of the media file.
         :param int after: If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str after_name: If given, all results returned will be after the media with this name. The `start` and `stop` parameters are relative to this modified range.
         :param str archive_lifecycle: Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
@@ -18687,15 +19856,15 @@
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
@@ -18719,14 +19888,15 @@
 
         all_params = [
             'id',
             'media_id',
             'type',
             'name',
             'section',
+            'multi_section',
             'dtype',
             'md5',
             'gid',
             'uid',
             'after',
             'after_name',
             'archive_lifecycle',
@@ -18787,14 +19957,17 @@
             collection_formats['media_id'] = 'csv'  # noqa: E501
         if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
             query_params.append(('type', local_var_params['type']))  # noqa: E501
         if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
             query_params.append(('name', local_var_params['name']))  # noqa: E501
         if 'section' in local_var_params and local_var_params['section'] is not None:  # noqa: E501
             query_params.append(('section', local_var_params['section']))  # noqa: E501
+        if 'multi_section' in local_var_params and local_var_params['multi_section'] is not None:  # noqa: E501
+            query_params.append(('multi_section', local_var_params['multi_section']))  # noqa: E501
+            collection_formats['multi_section'] = 'csv'  # noqa: E501
         if 'dtype' in local_var_params and local_var_params['dtype'] is not None:  # noqa: E501
             query_params.append(('dtype', local_var_params['dtype']))  # noqa: E501
         if 'md5' in local_var_params and local_var_params['md5'] is not None:  # noqa: E501
             query_params.append(('md5', local_var_params['md5']))  # noqa: E501
         if 'gid' in local_var_params and local_var_params['gid'] is not None:  # noqa: E501
             query_params.append(('gid', local_var_params['gid']))  # noqa: E501
         if 'uid' in local_var_params and local_var_params['uid'] is not None:  # noqa: E501
@@ -18909,14 +20082,15 @@
 
         :param bool async_req: execute request asynchronously
         :param int id: A unique integer identifying a media object. (required)
         :param list[int] media_id: List of integers identifying media.
         :param int type: Unique integer identifying media type.
         :param str name: Name of the media to filter on.
         :param int section: Unique integer identifying a media section.
+        :param list[int] multi_section: List of integers identifying sections to select.
         :param str dtype: Data type of the files, either image or video.
         :param str md5: MD5 sum of the media file.
         :param str gid: Upload group ID of the media file.
         :param str uid: Upload unique ID of the media file.
         :param int after: If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str after_name: If given, all results returned will be after the media with this name. The `start` and `stop` parameters are relative to this modified range.
         :param str archive_lifecycle: Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
@@ -18928,15 +20102,15 @@
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
@@ -18968,14 +20142,15 @@
 
         :param bool async_req: execute request asynchronously
         :param int id: A unique integer identifying a media object. (required)
         :param list[int] media_id: List of integers identifying media.
         :param int type: Unique integer identifying media type.
         :param str name: Name of the media to filter on.
         :param int section: Unique integer identifying a media section.
+        :param list[int] multi_section: List of integers identifying sections to select.
         :param str dtype: Data type of the files, either image or video.
         :param str md5: MD5 sum of the media file.
         :param str gid: Upload group ID of the media file.
         :param str uid: Upload unique ID of the media file.
         :param int after: If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str after_name: If given, all results returned will be after the media with this name. The `start` and `stop` parameters are relative to this modified range.
         :param str archive_lifecycle: Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
@@ -18987,15 +20162,15 @@
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
@@ -19019,14 +20194,15 @@
 
         all_params = [
             'id',
             'media_id',
             'type',
             'name',
             'section',
+            'multi_section',
             'dtype',
             'md5',
             'gid',
             'uid',
             'after',
             'after_name',
             'archive_lifecycle',
@@ -19087,14 +20263,17 @@
             collection_formats['media_id'] = 'csv'  # noqa: E501
         if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
             query_params.append(('type', local_var_params['type']))  # noqa: E501
         if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
             query_params.append(('name', local_var_params['name']))  # noqa: E501
         if 'section' in local_var_params and local_var_params['section'] is not None:  # noqa: E501
             query_params.append(('section', local_var_params['section']))  # noqa: E501
+        if 'multi_section' in local_var_params and local_var_params['multi_section'] is not None:  # noqa: E501
+            query_params.append(('multi_section', local_var_params['multi_section']))  # noqa: E501
+            collection_formats['multi_section'] = 'csv'  # noqa: E501
         if 'dtype' in local_var_params and local_var_params['dtype'] is not None:  # noqa: E501
             query_params.append(('dtype', local_var_params['dtype']))  # noqa: E501
         if 'md5' in local_var_params and local_var_params['md5'] is not None:  # noqa: E501
             query_params.append(('md5', local_var_params['md5']))  # noqa: E501
         if 'gid' in local_var_params and local_var_params['gid'] is not None:  # noqa: E501
             query_params.append(('gid', local_var_params['gid']))  # noqa: E501
         if 'uid' in local_var_params and local_var_params['uid'] is not None:  # noqa: E501
@@ -19209,14 +20388,15 @@
 
         :param bool async_req: execute request asynchronously
         :param int project: A unique integer identifying a project. (required)
         :param list[int] media_id: List of integers identifying media.
         :param int type: Unique integer identifying media type.
         :param str name: Name of the media to filter on.
         :param int section: Unique integer identifying a media section.
+        :param list[int] multi_section: List of integers identifying sections to select.
         :param str dtype: Data type of the files, either image or video.
         :param str md5: MD5 sum of the media file.
         :param str gid: Upload group ID of the media file.
         :param str uid: Upload unique ID of the media file.
         :param int after: If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str after_name: If given, all results returned will be after the media with this name. The `start` and `stop` parameters are relative to this modified range.
         :param str archive_lifecycle: Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
@@ -19228,15 +20408,15 @@
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
@@ -19268,14 +20448,15 @@
 
         :param bool async_req: execute request asynchronously
         :param int project: A unique integer identifying a project. (required)
         :param list[int] media_id: List of integers identifying media.
         :param int type: Unique integer identifying media type.
         :param str name: Name of the media to filter on.
         :param int section: Unique integer identifying a media section.
+        :param list[int] multi_section: List of integers identifying sections to select.
         :param str dtype: Data type of the files, either image or video.
         :param str md5: MD5 sum of the media file.
         :param str gid: Upload group ID of the media file.
         :param str uid: Upload unique ID of the media file.
         :param int after: If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str after_name: If given, all results returned will be after the media with this name. The `start` and `stop` parameters are relative to this modified range.
         :param str archive_lifecycle: Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
@@ -19287,15 +20468,15 @@
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
@@ -19319,14 +20500,15 @@
 
         all_params = [
             'project',
             'media_id',
             'type',
             'name',
             'section',
+            'multi_section',
             'dtype',
             'md5',
             'gid',
             'uid',
             'after',
             'after_name',
             'archive_lifecycle',
@@ -19387,14 +20569,17 @@
             collection_formats['media_id'] = 'csv'  # noqa: E501
         if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
             query_params.append(('type', local_var_params['type']))  # noqa: E501
         if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
             query_params.append(('name', local_var_params['name']))  # noqa: E501
         if 'section' in local_var_params and local_var_params['section'] is not None:  # noqa: E501
             query_params.append(('section', local_var_params['section']))  # noqa: E501
+        if 'multi_section' in local_var_params and local_var_params['multi_section'] is not None:  # noqa: E501
+            query_params.append(('multi_section', local_var_params['multi_section']))  # noqa: E501
+            collection_formats['multi_section'] = 'csv'  # noqa: E501
         if 'dtype' in local_var_params and local_var_params['dtype'] is not None:  # noqa: E501
             query_params.append(('dtype', local_var_params['dtype']))  # noqa: E501
         if 'md5' in local_var_params and local_var_params['md5'] is not None:  # noqa: E501
             query_params.append(('md5', local_var_params['md5']))  # noqa: E501
         if 'gid' in local_var_params and local_var_params['gid'] is not None:  # noqa: E501
             query_params.append(('gid', local_var_params['gid']))  # noqa: E501
         if 'uid' in local_var_params and local_var_params['uid'] is not None:  # noqa: E501
@@ -20822,14 +22007,15 @@
 
         >>> thread = api.get_section_list(project, async_req=True)
         >>> result = thread.get()
 
         :param bool async_req: execute request asynchronously
         :param int project: A unique integer identifying a project. (required)
         :param str name: Name of the section.
+        :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
         :param str elemental_id: Elemental ID to search for
         :param str match: Find any sections matching using an lquery.                - foo         Match the exact label path foo             - *.foo.*     Match any label path containing the label foo             - *.foo       Match any label path whose last label is foo              Modifiers:             - @           Match case-insensitively, for example a@ matches A             - *           Match any label with this prefix, for example foo* matches foobar             - %           Match initial underscore-separated words              American@.Foot@*              would match both             america.Football and America.footwear                  For more information: https://www.postgresql.org/docs/current/ltree.html 
         :param str ancestors: Find ancestors using using an lquery.                - foo         Match the exact label path foo             - *.foo.*     Match any label path containing the label foo             - *.foo       Match any label path whose last label is foo              Modifiers:             - @           Match case-insensitively, for example a@ matches A             - *           Match any label with this prefix, for example foo* matches foobar             - %           Match initial underscore-separated words              American@.Foot@*              would match both             america.Football and America.footwear                  For more information: https://www.postgresql.org/docs/current/ltree.html 
         :param str descendants: Find descendants using using an lquery.                - foo         Match the exact label path foo             - *.foo.*     Match any label path containing the label foo             - *.foo       Match any label path whose last label is foo              Modifiers:             - @           Match case-insensitively, for example a@ matches A             - *           Match any label with this prefix, for example foo* matches foobar             - %           Match initial underscore-separated words              American@.Foot@*              would match both             america.Football and America.footwear                  For more information: https://www.postgresql.org/docs/current/ltree.html 
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
@@ -20853,14 +22039,15 @@
 
         >>> thread = api.get_section_list_with_http_info(project, async_req=True)
         >>> result = thread.get()
 
         :param bool async_req: execute request asynchronously
         :param int project: A unique integer identifying a project. (required)
         :param str name: Name of the section.
+        :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
         :param str elemental_id: Elemental ID to search for
         :param str match: Find any sections matching using an lquery.                - foo         Match the exact label path foo             - *.foo.*     Match any label path containing the label foo             - *.foo       Match any label path whose last label is foo              Modifiers:             - @           Match case-insensitively, for example a@ matches A             - *           Match any label with this prefix, for example foo* matches foobar             - %           Match initial underscore-separated words              American@.Foot@*              would match both             america.Football and America.footwear                  For more information: https://www.postgresql.org/docs/current/ltree.html 
         :param str ancestors: Find ancestors using using an lquery.                - foo         Match the exact label path foo             - *.foo.*     Match any label path containing the label foo             - *.foo       Match any label path whose last label is foo              Modifiers:             - @           Match case-insensitively, for example a@ matches A             - *           Match any label with this prefix, for example foo* matches foobar             - %           Match initial underscore-separated words              American@.Foot@*              would match both             america.Football and America.footwear                  For more information: https://www.postgresql.org/docs/current/ltree.html 
         :param str descendants: Find descendants using using an lquery.                - foo         Match the exact label path foo             - *.foo.*     Match any label path containing the label foo             - *.foo       Match any label path whose last label is foo              Modifiers:             - @           Match case-insensitively, for example a@ matches A             - *           Match any label with this prefix, for example foo* matches foobar             - %           Match initial underscore-separated words              American@.Foot@*              would match both             america.Football and America.footwear                  For more information: https://www.postgresql.org/docs/current/ltree.html 
         :param _return_http_data_only: response data without head status code
                                        and headers
         :param _preload_content: if False, the urllib3.HTTPResponse object will
@@ -20876,14 +22063,15 @@
         """
 
         local_var_params = locals()
 
         all_params = [
             'project',
             'name',
+            'encoded_search',
             'elemental_id',
             'match',
             'ancestors',
             'descendants'
         ]
         all_params.extend(
             [
@@ -20912,14 +22100,16 @@
         path_params = {}
         if 'project' in local_var_params:
             path_params['project'] = local_var_params['project']  # noqa: E501
 
         query_params = []
         if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
             query_params.append(('name', local_var_params['name']))  # noqa: E501
+        if 'encoded_search' in local_var_params and local_var_params['encoded_search'] is not None:  # noqa: E501
+            query_params.append(('encoded_search', local_var_params['encoded_search']))  # noqa: E501
         if 'elemental_id' in local_var_params and local_var_params['elemental_id'] is not None:  # noqa: E501
             query_params.append(('elemental_id', local_var_params['elemental_id']))  # noqa: E501
         if 'match' in local_var_params and local_var_params['match'] is not None:  # noqa: E501
             query_params.append(('match', local_var_params['match']))  # noqa: E501
         if 'ancestors' in local_var_params and local_var_params['ancestors'] is not None:  # noqa: E501
             query_params.append(('ancestors', local_var_params['ancestors']))  # noqa: E501
         if 'descendants' in local_var_params and local_var_params['descendants'] is not None:  # noqa: E501
@@ -21067,14 +22257,147 @@
             auth_settings=auth_settings,
             async_req=local_var_params.get('async_req'),
             _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
             _preload_content=local_var_params.get('_preload_content', True),
             _request_timeout=local_var_params.get('_request_timeout',300),
             collection_formats=collection_formats)
 
+    def get_state_by_elemental_id(self, version, elemental_id, **kwargs):
+        """get_state_by_elemental_id
+
+        Get state.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes. 
+
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.get_state_by_elemental_id(version, elemental_id, async_req=True)
+        >>> result = thread.get()
+
+        :param bool async_req: execute request asynchronously
+        :param int version: Version ID to select object from (required)
+        :param str elemental_id: Elemental ID to fetch (required)
+        :param int mark: If given, select this mark of the element on this version. Defaults to LATEST.
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts. Default is 300.
+        :return: :class:`tator.models.State`
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.get_state_by_elemental_id_with_http_info(version, elemental_id, **kwargs)  # noqa: E501
+
+    def get_state_by_elemental_id_with_http_info(self, version, elemental_id, **kwargs):  # noqa: E501
+        """
+        Get state.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes.   # noqa: E501
+
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.get_state_by_elemental_id_with_http_info(version, elemental_id, async_req=True)
+        >>> result = thread.get()
+
+        :param bool async_req: execute request asynchronously
+        :param int version: Version ID to select object from (required)
+        :param str elemental_id: Elemental ID to fetch (required)
+        :param int mark: If given, select this mark of the element on this version. Defaults to LATEST.
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts. Default is 300.
+        :return: tuple(:class:`tator.models.State`, status_code(int), headers(HTTPHeaderDict))
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+
+        local_var_params = locals()
+
+        all_params = [
+            'version',
+            'elemental_id',
+            'mark'
+        ]
+        all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout'
+            ]
+        )
+
+        for key, val in six.iteritems(local_var_params['kwargs']):
+            if key not in all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method get_state_by_elemental_id" % key
+                )
+            local_var_params[key] = val
+        del local_var_params['kwargs']
+        # verify the required parameter 'version' is set
+        if self.api_client.client_side_validation and ('version' not in local_var_params or  # noqa: E501
+                                                        local_var_params['version'] is None):  # noqa: E501
+            raise ApiValueError("Missing the required parameter `version` when calling `get_state_by_elemental_id`")  # noqa: E501
+        # verify the required parameter 'elemental_id' is set
+        if self.api_client.client_side_validation and ('elemental_id' not in local_var_params or  # noqa: E501
+                                                        local_var_params['elemental_id'] is None):  # noqa: E501
+            raise ApiValueError("Missing the required parameter `elemental_id` when calling `get_state_by_elemental_id`")  # noqa: E501
+
+        if self.api_client.client_side_validation and 'mark' in local_var_params and local_var_params['mark'] < 0:  # noqa: E501
+            raise ApiValueError("Invalid value for parameter `mark` when calling `get_state_by_elemental_id`, must be a value greater than or equal to `0`")  # noqa: E501
+        collection_formats = {}
+
+        path_params = {}
+        if 'version' in local_var_params:
+            path_params['version'] = local_var_params['version']  # noqa: E501
+        if 'elemental_id' in local_var_params:
+            path_params['elemental_id'] = local_var_params['elemental_id']  # noqa: E501
+
+        query_params = []
+        if 'mark' in local_var_params and local_var_params['mark'] is not None:  # noqa: E501
+            query_params.append(('mark', local_var_params['mark']))  # noqa: E501
+
+        header_params = {}
+
+        form_params = []
+        local_var_files = {}
+
+        body_params = None
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json'])  # noqa: E501
+
+        # Authentication setting
+        auth_settings = ['SessionAuth', 'TokenAuth']  # noqa: E501
+
+        return self.api_client.call_api(
+            '/rest/State/{version}/{elemental_id}', 'GET',
+            path_params,
+            query_params,
+            header_params,
+            body=body_params,
+            post_params=form_params,
+            files=local_var_files,
+            response_type='State',  # noqa: E501
+            auth_settings=auth_settings,
+            async_req=local_var_params.get('async_req'),
+            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=local_var_params.get('_preload_content', True),
+            _request_timeout=local_var_params.get('_request_timeout',300),
+            collection_formats=collection_formats)
+
     def get_state_count(self, project, **kwargs):
         """get_state_count
 
         Get state list count.  This endpoint accepts the same query parameters as a GET or PUT request to the `States` endpoint, but only returns the number of states. 
 
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -21089,26 +22412,27 @@
         :param int section: Unique integer identifying a media section.
         :param int type: Unique integer identifying a annotation type.
         :param list[int] version: List of integers representing versions to fetch
         :param int after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str elemental_id: Elemental ID to search for
         :param int merge: Reduce result set based on a server side merge. If multiple versions are selected and a variant of the object exists in both versions, the merge logic will return 1 or 0 objects. Example:  Version B derives off Version A. An object, with the same elemental id \"foo\" exists on both. If Version B over A is selected and merge is turned on: + The \"foo\" present on Version B is returned  + If the \"foo\" on version B is deleted, no \"foo\" is returned.
         :param int show_deleted: Include in the return set objects that have `variant_deleted` set to True.
+        :param int show_all_marks: Include in the return set all marks, not just the latest.
         :param list[str] attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
@@ -21145,26 +22469,27 @@
         :param int section: Unique integer identifying a media section.
         :param int type: Unique integer identifying a annotation type.
         :param list[int] version: List of integers representing versions to fetch
         :param int after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str elemental_id: Elemental ID to search for
         :param int merge: Reduce result set based on a server side merge. If multiple versions are selected and a variant of the object exists in both versions, the merge logic will return 1 or 0 objects. Example:  Version B derives off Version A. An object, with the same elemental id \"foo\" exists on both. If Version B over A is selected and merge is turned on: + The \"foo\" present on Version B is returned  + If the \"foo\" on version B is deleted, no \"foo\" is returned.
         :param int show_deleted: Include in the return set objects that have `variant_deleted` set to True.
+        :param int show_all_marks: Include in the return set all marks, not just the latest.
         :param list[str] attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
@@ -21193,14 +22518,15 @@
             'section',
             'type',
             'version',
             'after',
             'elemental_id',
             'merge',
             'show_deleted',
+            'show_all_marks',
             'attribute',
             'attribute_lt',
             'attribute_lte',
             'attribute_gt',
             'attribute_gte',
             'attribute_contains',
             'attribute_distance',
@@ -21245,14 +22571,18 @@
             raise ApiValueError("Invalid value for parameter `merge` when calling `get_state_count`, must be a value less than or equal to `1`")  # noqa: E501
         if self.api_client.client_side_validation and 'merge' in local_var_params and local_var_params['merge'] < 0:  # noqa: E501
             raise ApiValueError("Invalid value for parameter `merge` when calling `get_state_count`, must be a value greater than or equal to `0`")  # noqa: E501
         if self.api_client.client_side_validation and 'show_deleted' in local_var_params and local_var_params['show_deleted'] > 1:  # noqa: E501
             raise ApiValueError("Invalid value for parameter `show_deleted` when calling `get_state_count`, must be a value less than or equal to `1`")  # noqa: E501
         if self.api_client.client_side_validation and 'show_deleted' in local_var_params and local_var_params['show_deleted'] < 0:  # noqa: E501
             raise ApiValueError("Invalid value for parameter `show_deleted` when calling `get_state_count`, must be a value greater than or equal to `0`")  # noqa: E501
+        if self.api_client.client_side_validation and 'show_all_marks' in local_var_params and local_var_params['show_all_marks'] > 1:  # noqa: E501
+            raise ApiValueError("Invalid value for parameter `show_all_marks` when calling `get_state_count`, must be a value less than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and 'show_all_marks' in local_var_params and local_var_params['show_all_marks'] < 0:  # noqa: E501
+            raise ApiValueError("Invalid value for parameter `show_all_marks` when calling `get_state_count`, must be a value greater than or equal to `0`")  # noqa: E501
         collection_formats = {}
 
         path_params = {}
         if 'project' in local_var_params:
             path_params['project'] = local_var_params['project']  # noqa: E501
 
         query_params = []
@@ -21273,14 +22603,16 @@
             query_params.append(('after', local_var_params['after']))  # noqa: E501
         if 'elemental_id' in local_var_params and local_var_params['elemental_id'] is not None:  # noqa: E501
             query_params.append(('elemental_id', local_var_params['elemental_id']))  # noqa: E501
         if 'merge' in local_var_params and local_var_params['merge'] is not None:  # noqa: E501
             query_params.append(('merge', local_var_params['merge']))  # noqa: E501
         if 'show_deleted' in local_var_params and local_var_params['show_deleted'] is not None:  # noqa: E501
             query_params.append(('show_deleted', local_var_params['show_deleted']))  # noqa: E501
+        if 'show_all_marks' in local_var_params and local_var_params['show_all_marks'] is not None:  # noqa: E501
+            query_params.append(('show_all_marks', local_var_params['show_all_marks']))  # noqa: E501
         if 'attribute' in local_var_params and local_var_params['attribute'] is not None:  # noqa: E501
             query_params.append(('attribute', local_var_params['attribute']))  # noqa: E501
             collection_formats['attribute'] = 'csv'  # noqa: E501
         if 'attribute_lt' in local_var_params and local_var_params['attribute_lt'] is not None:  # noqa: E501
             query_params.append(('attribute_lt', local_var_params['attribute_lt']))  # noqa: E501
             collection_formats['attribute_lt'] = 'csv'  # noqa: E501
         if 'attribute_lte' in local_var_params and local_var_params['attribute_lte'] is not None:  # noqa: E501
@@ -21385,26 +22717,27 @@
         :param int section: Unique integer identifying a media section.
         :param int type: Unique integer identifying a annotation type.
         :param list[int] version: List of integers representing versions to fetch
         :param int after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str elemental_id: Elemental ID to search for
         :param int merge: Reduce result set based on a server side merge. If multiple versions are selected and a variant of the object exists in both versions, the merge logic will return 1 or 0 objects. Example:  Version B derives off Version A. An object, with the same elemental id \"foo\" exists on both. If Version B over A is selected and merge is turned on: + The \"foo\" present on Version B is returned  + If the \"foo\" on version B is deleted, no \"foo\" is returned.
         :param int show_deleted: Include in the return set objects that have `variant_deleted` set to True.
+        :param int show_all_marks: Include in the return set all marks, not just the latest.
         :param list[str] attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
@@ -21442,26 +22775,27 @@
         :param int section: Unique integer identifying a media section.
         :param int type: Unique integer identifying a annotation type.
         :param list[int] version: List of integers representing versions to fetch
         :param int after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str elemental_id: Elemental ID to search for
         :param int merge: Reduce result set based on a server side merge. If multiple versions are selected and a variant of the object exists in both versions, the merge logic will return 1 or 0 objects. Example:  Version B derives off Version A. An object, with the same elemental id \"foo\" exists on both. If Version B over A is selected and merge is turned on: + The \"foo\" present on Version B is returned  + If the \"foo\" on version B is deleted, no \"foo\" is returned.
         :param int show_deleted: Include in the return set objects that have `variant_deleted` set to True.
+        :param int show_all_marks: Include in the return set all marks, not just the latest.
         :param list[str] attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
@@ -21491,14 +22825,15 @@
             'section',
             'type',
             'version',
             'after',
             'elemental_id',
             'merge',
             'show_deleted',
+            'show_all_marks',
             'attribute',
             'attribute_lt',
             'attribute_lte',
             'attribute_gt',
             'attribute_gte',
             'attribute_contains',
             'attribute_distance',
@@ -21547,14 +22882,18 @@
             raise ApiValueError("Invalid value for parameter `merge` when calling `get_state_count_by_id`, must be a value less than or equal to `1`")  # noqa: E501
         if self.api_client.client_side_validation and 'merge' in local_var_params and local_var_params['merge'] < 0:  # noqa: E501
             raise ApiValueError("Invalid value for parameter `merge` when calling `get_state_count_by_id`, must be a value greater than or equal to `0`")  # noqa: E501
         if self.api_client.client_side_validation and 'show_deleted' in local_var_params and local_var_params['show_deleted'] > 1:  # noqa: E501
             raise ApiValueError("Invalid value for parameter `show_deleted` when calling `get_state_count_by_id`, must be a value less than or equal to `1`")  # noqa: E501
         if self.api_client.client_side_validation and 'show_deleted' in local_var_params and local_var_params['show_deleted'] < 0:  # noqa: E501
             raise ApiValueError("Invalid value for parameter `show_deleted` when calling `get_state_count_by_id`, must be a value greater than or equal to `0`")  # noqa: E501
+        if self.api_client.client_side_validation and 'show_all_marks' in local_var_params and local_var_params['show_all_marks'] > 1:  # noqa: E501
+            raise ApiValueError("Invalid value for parameter `show_all_marks` when calling `get_state_count_by_id`, must be a value less than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and 'show_all_marks' in local_var_params and local_var_params['show_all_marks'] < 0:  # noqa: E501
+            raise ApiValueError("Invalid value for parameter `show_all_marks` when calling `get_state_count_by_id`, must be a value greater than or equal to `0`")  # noqa: E501
         collection_formats = {}
 
         path_params = {}
         if 'project' in local_var_params:
             path_params['project'] = local_var_params['project']  # noqa: E501
 
         query_params = []
@@ -21575,14 +22914,16 @@
             query_params.append(('after', local_var_params['after']))  # noqa: E501
         if 'elemental_id' in local_var_params and local_var_params['elemental_id'] is not None:  # noqa: E501
             query_params.append(('elemental_id', local_var_params['elemental_id']))  # noqa: E501
         if 'merge' in local_var_params and local_var_params['merge'] is not None:  # noqa: E501
             query_params.append(('merge', local_var_params['merge']))  # noqa: E501
         if 'show_deleted' in local_var_params and local_var_params['show_deleted'] is not None:  # noqa: E501
             query_params.append(('show_deleted', local_var_params['show_deleted']))  # noqa: E501
+        if 'show_all_marks' in local_var_params and local_var_params['show_all_marks'] is not None:  # noqa: E501
+            query_params.append(('show_all_marks', local_var_params['show_all_marks']))  # noqa: E501
         if 'attribute' in local_var_params and local_var_params['attribute'] is not None:  # noqa: E501
             query_params.append(('attribute', local_var_params['attribute']))  # noqa: E501
             collection_formats['attribute'] = 'csv'  # noqa: E501
         if 'attribute_lt' in local_var_params and local_var_params['attribute_lt'] is not None:  # noqa: E501
             query_params.append(('attribute_lt', local_var_params['attribute_lt']))  # noqa: E501
             collection_formats['attribute_lt'] = 'csv'  # noqa: E501
         if 'attribute_lte' in local_var_params and local_var_params['attribute_lte'] is not None:  # noqa: E501
@@ -21836,26 +23177,27 @@
         :param int section: Unique integer identifying a media section.
         :param int type: Unique integer identifying a annotation type.
         :param list[int] version: List of integers representing versions to fetch
         :param int after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str elemental_id: Elemental ID to search for
         :param int merge: Reduce result set based on a server side merge. If multiple versions are selected and a variant of the object exists in both versions, the merge logic will return 1 or 0 objects. Example:  Version B derives off Version A. An object, with the same elemental id \"foo\" exists on both. If Version B over A is selected and merge is turned on: + The \"foo\" present on Version B is returned  + If the \"foo\" on version B is deleted, no \"foo\" is returned.
         :param int show_deleted: Include in the return set objects that have `variant_deleted` set to True.
+        :param int show_all_marks: Include in the return set all marks, not just the latest.
         :param list[str] attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
@@ -21892,26 +23234,27 @@
         :param int section: Unique integer identifying a media section.
         :param int type: Unique integer identifying a annotation type.
         :param list[int] version: List of integers representing versions to fetch
         :param int after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str elemental_id: Elemental ID to search for
         :param int merge: Reduce result set based on a server side merge. If multiple versions are selected and a variant of the object exists in both versions, the merge logic will return 1 or 0 objects. Example:  Version B derives off Version A. An object, with the same elemental id \"foo\" exists on both. If Version B over A is selected and merge is turned on: + The \"foo\" present on Version B is returned  + If the \"foo\" on version B is deleted, no \"foo\" is returned.
         :param int show_deleted: Include in the return set objects that have `variant_deleted` set to True.
+        :param int show_all_marks: Include in the return set all marks, not just the latest.
         :param list[str] attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
@@ -21940,14 +23283,15 @@
             'section',
             'type',
             'version',
             'after',
             'elemental_id',
             'merge',
             'show_deleted',
+            'show_all_marks',
             'attribute',
             'attribute_lt',
             'attribute_lte',
             'attribute_gt',
             'attribute_gte',
             'attribute_contains',
             'attribute_distance',
@@ -21992,14 +23336,18 @@
             raise ApiValueError("Invalid value for parameter `merge` when calling `get_state_list`, must be a value less than or equal to `1`")  # noqa: E501
         if self.api_client.client_side_validation and 'merge' in local_var_params and local_var_params['merge'] < 0:  # noqa: E501
             raise ApiValueError("Invalid value for parameter `merge` when calling `get_state_list`, must be a value greater than or equal to `0`")  # noqa: E501
         if self.api_client.client_side_validation and 'show_deleted' in local_var_params and local_var_params['show_deleted'] > 1:  # noqa: E501
             raise ApiValueError("Invalid value for parameter `show_deleted` when calling `get_state_list`, must be a value less than or equal to `1`")  # noqa: E501
         if self.api_client.client_side_validation and 'show_deleted' in local_var_params and local_var_params['show_deleted'] < 0:  # noqa: E501
             raise ApiValueError("Invalid value for parameter `show_deleted` when calling `get_state_list`, must be a value greater than or equal to `0`")  # noqa: E501
+        if self.api_client.client_side_validation and 'show_all_marks' in local_var_params and local_var_params['show_all_marks'] > 1:  # noqa: E501
+            raise ApiValueError("Invalid value for parameter `show_all_marks` when calling `get_state_list`, must be a value less than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and 'show_all_marks' in local_var_params and local_var_params['show_all_marks'] < 0:  # noqa: E501
+            raise ApiValueError("Invalid value for parameter `show_all_marks` when calling `get_state_list`, must be a value greater than or equal to `0`")  # noqa: E501
         collection_formats = {}
 
         path_params = {}
         if 'project' in local_var_params:
             path_params['project'] = local_var_params['project']  # noqa: E501
 
         query_params = []
@@ -22020,14 +23368,16 @@
             query_params.append(('after', local_var_params['after']))  # noqa: E501
         if 'elemental_id' in local_var_params and local_var_params['elemental_id'] is not None:  # noqa: E501
             query_params.append(('elemental_id', local_var_params['elemental_id']))  # noqa: E501
         if 'merge' in local_var_params and local_var_params['merge'] is not None:  # noqa: E501
             query_params.append(('merge', local_var_params['merge']))  # noqa: E501
         if 'show_deleted' in local_var_params and local_var_params['show_deleted'] is not None:  # noqa: E501
             query_params.append(('show_deleted', local_var_params['show_deleted']))  # noqa: E501
+        if 'show_all_marks' in local_var_params and local_var_params['show_all_marks'] is not None:  # noqa: E501
+            query_params.append(('show_all_marks', local_var_params['show_all_marks']))  # noqa: E501
         if 'attribute' in local_var_params and local_var_params['attribute'] is not None:  # noqa: E501
             query_params.append(('attribute', local_var_params['attribute']))  # noqa: E501
             collection_formats['attribute'] = 'csv'  # noqa: E501
         if 'attribute_lt' in local_var_params and local_var_params['attribute_lt'] is not None:  # noqa: E501
             query_params.append(('attribute_lt', local_var_params['attribute_lt']))  # noqa: E501
             collection_formats['attribute_lt'] = 'csv'  # noqa: E501
         if 'attribute_lte' in local_var_params and local_var_params['attribute_lte'] is not None:  # noqa: E501
@@ -22132,26 +23482,27 @@
         :param int section: Unique integer identifying a media section.
         :param int type: Unique integer identifying a annotation type.
         :param list[int] version: List of integers representing versions to fetch
         :param int after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str elemental_id: Elemental ID to search for
         :param int merge: Reduce result set based on a server side merge. If multiple versions are selected and a variant of the object exists in both versions, the merge logic will return 1 or 0 objects. Example:  Version B derives off Version A. An object, with the same elemental id \"foo\" exists on both. If Version B over A is selected and merge is turned on: + The \"foo\" present on Version B is returned  + If the \"foo\" on version B is deleted, no \"foo\" is returned.
         :param int show_deleted: Include in the return set objects that have `variant_deleted` set to True.
+        :param int show_all_marks: Include in the return set all marks, not just the latest.
         :param list[str] attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
@@ -22189,26 +23540,27 @@
         :param int section: Unique integer identifying a media section.
         :param int type: Unique integer identifying a annotation type.
         :param list[int] version: List of integers representing versions to fetch
         :param int after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str elemental_id: Elemental ID to search for
         :param int merge: Reduce result set based on a server side merge. If multiple versions are selected and a variant of the object exists in both versions, the merge logic will return 1 or 0 objects. Example:  Version B derives off Version A. An object, with the same elemental id \"foo\" exists on both. If Version B over A is selected and merge is turned on: + The \"foo\" present on Version B is returned  + If the \"foo\" on version B is deleted, no \"foo\" is returned.
         :param int show_deleted: Include in the return set objects that have `variant_deleted` set to True.
+        :param int show_all_marks: Include in the return set all marks, not just the latest.
         :param list[str] attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
@@ -22238,14 +23590,15 @@
             'section',
             'type',
             'version',
             'after',
             'elemental_id',
             'merge',
             'show_deleted',
+            'show_all_marks',
             'attribute',
             'attribute_lt',
             'attribute_lte',
             'attribute_gt',
             'attribute_gte',
             'attribute_contains',
             'attribute_distance',
@@ -22294,14 +23647,18 @@
             raise ApiValueError("Invalid value for parameter `merge` when calling `get_state_list_by_id`, must be a value less than or equal to `1`")  # noqa: E501
         if self.api_client.client_side_validation and 'merge' in local_var_params and local_var_params['merge'] < 0:  # noqa: E501
             raise ApiValueError("Invalid value for parameter `merge` when calling `get_state_list_by_id`, must be a value greater than or equal to `0`")  # noqa: E501
         if self.api_client.client_side_validation and 'show_deleted' in local_var_params and local_var_params['show_deleted'] > 1:  # noqa: E501
             raise ApiValueError("Invalid value for parameter `show_deleted` when calling `get_state_list_by_id`, must be a value less than or equal to `1`")  # noqa: E501
         if self.api_client.client_side_validation and 'show_deleted' in local_var_params and local_var_params['show_deleted'] < 0:  # noqa: E501
             raise ApiValueError("Invalid value for parameter `show_deleted` when calling `get_state_list_by_id`, must be a value greater than or equal to `0`")  # noqa: E501
+        if self.api_client.client_side_validation and 'show_all_marks' in local_var_params and local_var_params['show_all_marks'] > 1:  # noqa: E501
+            raise ApiValueError("Invalid value for parameter `show_all_marks` when calling `get_state_list_by_id`, must be a value less than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and 'show_all_marks' in local_var_params and local_var_params['show_all_marks'] < 0:  # noqa: E501
+            raise ApiValueError("Invalid value for parameter `show_all_marks` when calling `get_state_list_by_id`, must be a value greater than or equal to `0`")  # noqa: E501
         collection_formats = {}
 
         path_params = {}
         if 'project' in local_var_params:
             path_params['project'] = local_var_params['project']  # noqa: E501
 
         query_params = []
@@ -22322,14 +23679,16 @@
             query_params.append(('after', local_var_params['after']))  # noqa: E501
         if 'elemental_id' in local_var_params and local_var_params['elemental_id'] is not None:  # noqa: E501
             query_params.append(('elemental_id', local_var_params['elemental_id']))  # noqa: E501
         if 'merge' in local_var_params and local_var_params['merge'] is not None:  # noqa: E501
             query_params.append(('merge', local_var_params['merge']))  # noqa: E501
         if 'show_deleted' in local_var_params and local_var_params['show_deleted'] is not None:  # noqa: E501
             query_params.append(('show_deleted', local_var_params['show_deleted']))  # noqa: E501
+        if 'show_all_marks' in local_var_params and local_var_params['show_all_marks'] is not None:  # noqa: E501
+            query_params.append(('show_all_marks', local_var_params['show_all_marks']))  # noqa: E501
         if 'attribute' in local_var_params and local_var_params['attribute'] is not None:  # noqa: E501
             query_params.append(('attribute', local_var_params['attribute']))  # noqa: E501
             collection_formats['attribute'] = 'csv'  # noqa: E501
         if 'attribute_lt' in local_var_params and local_var_params['attribute_lt'] is not None:  # noqa: E501
             query_params.append(('attribute_lt', local_var_params['attribute_lt']))  # noqa: E501
             collection_formats['attribute_lt'] = 'csv'  # noqa: E501
         if 'attribute_lte' in local_var_params and local_var_params['attribute_lte'] is not None:  # noqa: E501
@@ -23040,14 +24399,15 @@
 
         :param bool async_req: execute request asynchronously
         :param int project: A unique integer identifying a project. (required)
         :param list[int] media_id: List of integers identifying media.
         :param int type: Unique integer identifying media type.
         :param str name: Name of the media to filter on.
         :param int section: Unique integer identifying a media section.
+        :param list[int] multi_section: List of integers identifying sections to select.
         :param str dtype: Data type of the files, either image or video.
         :param str md5: MD5 sum of the media file.
         :param str gid: Upload group ID of the media file.
         :param str uid: Upload unique ID of the media file.
         :param int after: If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str after_name: If given, all results returned will be after the media with this name. The `start` and `stop` parameters are relative to this modified range.
         :param str archive_lifecycle: Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
@@ -23059,15 +24419,15 @@
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
@@ -23099,14 +24459,15 @@
 
         :param bool async_req: execute request asynchronously
         :param int project: A unique integer identifying a project. (required)
         :param list[int] media_id: List of integers identifying media.
         :param int type: Unique integer identifying media type.
         :param str name: Name of the media to filter on.
         :param int section: Unique integer identifying a media section.
+        :param list[int] multi_section: List of integers identifying sections to select.
         :param str dtype: Data type of the files, either image or video.
         :param str md5: MD5 sum of the media file.
         :param str gid: Upload group ID of the media file.
         :param str uid: Upload unique ID of the media file.
         :param int after: If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str after_name: If given, all results returned will be after the media with this name. The `start` and `stop` parameters are relative to this modified range.
         :param str archive_lifecycle: Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
@@ -23118,15 +24479,15 @@
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
@@ -23150,14 +24511,15 @@
 
         all_params = [
             'project',
             'media_id',
             'type',
             'name',
             'section',
+            'multi_section',
             'dtype',
             'md5',
             'gid',
             'uid',
             'after',
             'after_name',
             'archive_lifecycle',
@@ -23218,14 +24580,17 @@
             collection_formats['media_id'] = 'csv'  # noqa: E501
         if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
             query_params.append(('type', local_var_params['type']))  # noqa: E501
         if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
             query_params.append(('name', local_var_params['name']))  # noqa: E501
         if 'section' in local_var_params and local_var_params['section'] is not None:  # noqa: E501
             query_params.append(('section', local_var_params['section']))  # noqa: E501
+        if 'multi_section' in local_var_params and local_var_params['multi_section'] is not None:  # noqa: E501
+            query_params.append(('multi_section', local_var_params['multi_section']))  # noqa: E501
+            collection_formats['multi_section'] = 'csv'  # noqa: E501
         if 'dtype' in local_var_params and local_var_params['dtype'] is not None:  # noqa: E501
             query_params.append(('dtype', local_var_params['dtype']))  # noqa: E501
         if 'md5' in local_var_params and local_var_params['md5'] is not None:  # noqa: E501
             query_params.append(('md5', local_var_params['md5']))  # noqa: E501
         if 'gid' in local_var_params and local_var_params['gid'] is not None:  # noqa: E501
             query_params.append(('gid', local_var_params['gid']))  # noqa: E501
         if 'uid' in local_var_params and local_var_params['uid'] is not None:  # noqa: E501
@@ -23341,14 +24706,15 @@
         :param bool async_req: execute request asynchronously
         :param int project: A unique integer identifying a project. (required)
         :param MediaIdQuery media_id_query: (required)
         :param list[int] media_id: List of integers identifying media.
         :param int type: Unique integer identifying media type.
         :param str name: Name of the media to filter on.
         :param int section: Unique integer identifying a media section.
+        :param list[int] multi_section: List of integers identifying sections to select.
         :param str dtype: Data type of the files, either image or video.
         :param str md5: MD5 sum of the media file.
         :param str gid: Upload group ID of the media file.
         :param str uid: Upload unique ID of the media file.
         :param int after: If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str after_name: If given, all results returned will be after the media with this name. The `start` and `stop` parameters are relative to this modified range.
         :param str archive_lifecycle: Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
@@ -23360,15 +24726,15 @@
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
@@ -23401,14 +24767,15 @@
         :param bool async_req: execute request asynchronously
         :param int project: A unique integer identifying a project. (required)
         :param MediaIdQuery media_id_query: (required)
         :param list[int] media_id: List of integers identifying media.
         :param int type: Unique integer identifying media type.
         :param str name: Name of the media to filter on.
         :param int section: Unique integer identifying a media section.
+        :param list[int] multi_section: List of integers identifying sections to select.
         :param str dtype: Data type of the files, either image or video.
         :param str md5: MD5 sum of the media file.
         :param str gid: Upload group ID of the media file.
         :param str uid: Upload unique ID of the media file.
         :param int after: If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str after_name: If given, all results returned will be after the media with this name. The `start` and `stop` parameters are relative to this modified range.
         :param str archive_lifecycle: Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
@@ -23420,15 +24787,15 @@
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
@@ -23453,14 +24820,15 @@
         all_params = [
             'project',
             'media_id_query',
             'media_id',
             'type',
             'name',
             'section',
+            'multi_section',
             'dtype',
             'md5',
             'gid',
             'uid',
             'after',
             'after_name',
             'archive_lifecycle',
@@ -23525,14 +24893,17 @@
             collection_formats['media_id'] = 'csv'  # noqa: E501
         if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
             query_params.append(('type', local_var_params['type']))  # noqa: E501
         if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
             query_params.append(('name', local_var_params['name']))  # noqa: E501
         if 'section' in local_var_params and local_var_params['section'] is not None:  # noqa: E501
             query_params.append(('section', local_var_params['section']))  # noqa: E501
+        if 'multi_section' in local_var_params and local_var_params['multi_section'] is not None:  # noqa: E501
+            query_params.append(('multi_section', local_var_params['multi_section']))  # noqa: E501
+            collection_formats['multi_section'] = 'csv'  # noqa: E501
         if 'dtype' in local_var_params and local_var_params['dtype'] is not None:  # noqa: E501
             query_params.append(('dtype', local_var_params['dtype']))  # noqa: E501
         if 'md5' in local_var_params and local_var_params['md5'] is not None:  # noqa: E501
             query_params.append(('md5', local_var_params['md5']))  # noqa: E501
         if 'gid' in local_var_params and local_var_params['gid'] is not None:  # noqa: E501
             query_params.append(('gid', local_var_params['gid']))  # noqa: E501
         if 'uid' in local_var_params and local_var_params['uid'] is not None:  # noqa: E501
@@ -25872,15 +27243,15 @@
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts. Default is 300.
-        :return: :class:`tator.models.MessageResponse`
+        :return: :class:`tator.models.InlineResponse200`
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
         return self.trim_state_end_with_http_info(id, state_trim_update, **kwargs)  # noqa: E501
 
     def trim_state_end_with_http_info(self, id, state_trim_update, **kwargs):  # noqa: E501
@@ -25901,15 +27272,15 @@
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts. Default is 300.
-        :return: tuple(:class:`tator.models.MessageResponse`, status_code(int), headers(HTTPHeaderDict))
+        :return: tuple(:class:`tator.models.InlineResponse200`, status_code(int), headers(HTTPHeaderDict))
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         local_var_params = locals()
 
         all_params = [
@@ -25973,15 +27344,15 @@
             '/rest/TrimStateEnd/{id}', 'PATCH',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='MessageResponse',  # noqa: E501
+            response_type='InlineResponse200',  # noqa: E501
             auth_settings=auth_settings,
             async_req=local_var_params.get('async_req'),
             _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
             _preload_content=local_var_params.get('_preload_content', True),
             _request_timeout=local_var_params.get('_request_timeout',300),
             collection_formats=collection_formats)
 
@@ -27443,14 +28814,144 @@
             auth_settings=auth_settings,
             async_req=local_var_params.get('async_req'),
             _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
             _preload_content=local_var_params.get('_preload_content', True),
             _request_timeout=local_var_params.get('_request_timeout',300),
             collection_formats=collection_formats)
 
+    def update_hosted_template(self, id, hosted_template_spec, **kwargs):
+        """update_hosted_template
+
+        Updated registered hosted template
+
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.update_hosted_template(id, hosted_template_spec, async_req=True)
+        >>> result = thread.get()
+
+        :param bool async_req: execute request asynchronously
+        :param int id: A unique integer identifying a registered hosted template. (required)
+        :param HostedTemplateSpec hosted_template_spec: (required)
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts. Default is 300.
+        :return: :class:`tator.models.MessageResponse`
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.update_hosted_template_with_http_info(id, hosted_template_spec, **kwargs)  # noqa: E501
+
+    def update_hosted_template_with_http_info(self, id, hosted_template_spec, **kwargs):  # noqa: E501
+        """
+        Updated registered hosted template  # noqa: E501
+
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.update_hosted_template_with_http_info(id, hosted_template_spec, async_req=True)
+        >>> result = thread.get()
+
+        :param bool async_req: execute request asynchronously
+        :param int id: A unique integer identifying a registered hosted template. (required)
+        :param HostedTemplateSpec hosted_template_spec: (required)
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts. Default is 300.
+        :return: tuple(:class:`tator.models.MessageResponse`, status_code(int), headers(HTTPHeaderDict))
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+
+        local_var_params = locals()
+
+        all_params = [
+            'id',
+            'hosted_template_spec'
+        ]
+        all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout'
+            ]
+        )
+
+        for key, val in six.iteritems(local_var_params['kwargs']):
+            if key not in all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method update_hosted_template" % key
+                )
+            local_var_params[key] = val
+        del local_var_params['kwargs']
+        # verify the required parameter 'id' is set
+        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
+                                                        local_var_params['id'] is None):  # noqa: E501
+            raise ApiValueError("Missing the required parameter `id` when calling `update_hosted_template`")  # noqa: E501
+        # verify the required parameter 'hosted_template_spec' is set
+        if self.api_client.client_side_validation and ('hosted_template_spec' not in local_var_params or  # noqa: E501
+                                                        local_var_params['hosted_template_spec'] is None):  # noqa: E501
+            raise ApiValueError("Missing the required parameter `hosted_template_spec` when calling `update_hosted_template`")  # noqa: E501
+
+        collection_formats = {}
+
+        path_params = {}
+        if 'id' in local_var_params:
+            path_params['id'] = local_var_params['id']  # noqa: E501
+
+        query_params = []
+
+        header_params = {}
+
+        form_params = []
+        local_var_files = {}
+
+        body_params = None
+        if 'hosted_template_spec' in local_var_params:
+            body_params = local_var_params['hosted_template_spec']
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json'])  # noqa: E501
+
+        # HTTP header `Content-Type`
+        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
+            ['application/json'])  # noqa: E501
+
+        # Authentication setting
+        auth_settings = ['SessionAuth', 'TokenAuth']  # noqa: E501
+
+        return self.api_client.call_api(
+            '/rest/HostedTemplate/{id}', 'PATCH',
+            path_params,
+            query_params,
+            header_params,
+            body=body_params,
+            post_params=form_params,
+            files=local_var_files,
+            response_type='MessageResponse',  # noqa: E501
+            auth_settings=auth_settings,
+            async_req=local_var_params.get('async_req'),
+            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=local_var_params.get('_preload_content', True),
+            _request_timeout=local_var_params.get('_request_timeout',300),
+            collection_formats=collection_formats)
+
     def update_image_file(self, id, role, index, image_definition, **kwargs):
         """update_image_file
 
         Update image file.  Image files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying image. One or more image files can be used to reference thumbnails, thumbnail GIFs, or images in a `Media` object. The file itself must first be  uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the image file's `path` field. 
 
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -28012,15 +29513,16 @@
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
+        :param int count: Expected count of elements affected by this operation. If the number of elements differs from this count, the operation is aborted and 400 response is returned.
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts. Default is 300.
@@ -28055,15 +29557,16 @@
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
+        :param int count: Expected count of elements affected by this operation. If the number of elements differs from this count, the operation is aborted and 400 response is returned.
         :param _return_http_data_only: response data without head status code
                                        and headers
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
@@ -28090,15 +29593,16 @@
             'attribute_gte',
             'attribute_contains',
             'attribute_distance',
             'attribute_null',
             'start',
             'stop',
             'encoded_search',
-            'sort_by'
+            'sort_by',
+            'count'
         ]
         all_params.extend(
             [
                 'async_req',
                 '_return_http_data_only',
                 '_preload_content',
                 '_request_timeout'
@@ -28118,14 +29622,16 @@
                                                         local_var_params['project'] is None):  # noqa: E501
             raise ApiValueError("Missing the required parameter `project` when calling `update_leaf_list`")  # noqa: E501
         # verify the required parameter 'leaf_bulk_update' is set
         if self.api_client.client_side_validation and ('leaf_bulk_update' not in local_var_params or  # noqa: E501
                                                         local_var_params['leaf_bulk_update'] is None):  # noqa: E501
             raise ApiValueError("Missing the required parameter `leaf_bulk_update` when calling `update_leaf_list`")  # noqa: E501
 
+        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
+            raise ApiValueError("Invalid value for parameter `count` when calling `update_leaf_list`, must be a value greater than or equal to `0`")  # noqa: E501
         collection_formats = {}
 
         path_params = {}
         if 'project' in local_var_params:
             path_params['project'] = local_var_params['project']  # noqa: E501
 
         query_params = []
@@ -28167,14 +29673,16 @@
         if 'stop' in local_var_params and local_var_params['stop'] is not None:  # noqa: E501
             query_params.append(('stop', local_var_params['stop']))  # noqa: E501
         if 'encoded_search' in local_var_params and local_var_params['encoded_search'] is not None:  # noqa: E501
             query_params.append(('encoded_search', local_var_params['encoded_search']))  # noqa: E501
         if 'sort_by' in local_var_params and local_var_params['sort_by'] is not None:  # noqa: E501
             query_params.append(('sort_by', local_var_params['sort_by']))  # noqa: E501
             collection_formats['sort_by'] = 'multi'  # noqa: E501
+        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
+            query_params.append(('count', local_var_params['count']))  # noqa: E501
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
@@ -28354,15 +29862,15 @@
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts. Default is 300.
-        :return: :class:`tator.models.MessageResponse`
+        :return: :class:`tator.models.InlineResponse2001`
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
         return self.update_localization_with_http_info(id, localization_update, **kwargs)  # noqa: E501
 
     def update_localization_with_http_info(self, id, localization_update, **kwargs):  # noqa: E501
@@ -28383,15 +29891,15 @@
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts. Default is 300.
-        :return: tuple(:class:`tator.models.MessageResponse`, status_code(int), headers(HTTPHeaderDict))
+        :return: tuple(:class:`tator.models.InlineResponse2001`, status_code(int), headers(HTTPHeaderDict))
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         local_var_params = locals()
 
         all_params = [
@@ -28455,15 +29963,154 @@
             '/rest/Localization/{id}', 'PATCH',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='MessageResponse',  # noqa: E501
+            response_type='InlineResponse2001',  # noqa: E501
+            auth_settings=auth_settings,
+            async_req=local_var_params.get('async_req'),
+            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=local_var_params.get('_preload_content', True),
+            _request_timeout=local_var_params.get('_request_timeout',300),
+            collection_formats=collection_formats)
+
+    def update_localization_by_elemental_id(self, version, elemental_id, localization_update, **kwargs):
+        """update_localization_by_elemental_id
+
+        Update localization.  Localizations are shape annotations drawn on a video or image. Available shapes (`dtype`) are  box, line, or dot. Each shape is parameterized by a different subset of data members: - `box` uses `x`, `y`, `width`, `height`. - `line` uses `x`, `y`, `u`, `v`. - `dot` uses `x` and `y`. - `poly` uses `points`.  Geometry members may be left null when creating a localization, in which case the shapes may be  drawn later using the redraw capability in the web UI. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes. 
+
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.update_localization_by_elemental_id(version, elemental_id, localization_update, async_req=True)
+        >>> result = thread.get()
+
+        :param bool async_req: execute request asynchronously
+        :param int version: Version ID to select object from (required)
+        :param str elemental_id: Elemental ID to fetch (required)
+        :param LocalizationUpdate localization_update: (required)
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts. Default is 300.
+        :return: :class:`tator.models.InlineResponse2001`
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.update_localization_by_elemental_id_with_http_info(version, elemental_id, localization_update, **kwargs)  # noqa: E501
+
+    def update_localization_by_elemental_id_with_http_info(self, version, elemental_id, localization_update, **kwargs):  # noqa: E501
+        """
+        Update localization.  Localizations are shape annotations drawn on a video or image. Available shapes (`dtype`) are  box, line, or dot. Each shape is parameterized by a different subset of data members: - `box` uses `x`, `y`, `width`, `height`. - `line` uses `x`, `y`, `u`, `v`. - `dot` uses `x` and `y`. - `poly` uses `points`.  Geometry members may be left null when creating a localization, in which case the shapes may be  drawn later using the redraw capability in the web UI. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes.   # noqa: E501
+
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.update_localization_by_elemental_id_with_http_info(version, elemental_id, localization_update, async_req=True)
+        >>> result = thread.get()
+
+        :param bool async_req: execute request asynchronously
+        :param int version: Version ID to select object from (required)
+        :param str elemental_id: Elemental ID to fetch (required)
+        :param LocalizationUpdate localization_update: (required)
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts. Default is 300.
+        :return: tuple(:class:`tator.models.InlineResponse2001`, status_code(int), headers(HTTPHeaderDict))
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+
+        local_var_params = locals()
+
+        all_params = [
+            'version',
+            'elemental_id',
+            'localization_update'
+        ]
+        all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout'
+            ]
+        )
+
+        for key, val in six.iteritems(local_var_params['kwargs']):
+            if key not in all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method update_localization_by_elemental_id" % key
+                )
+            local_var_params[key] = val
+        del local_var_params['kwargs']
+        # verify the required parameter 'version' is set
+        if self.api_client.client_side_validation and ('version' not in local_var_params or  # noqa: E501
+                                                        local_var_params['version'] is None):  # noqa: E501
+            raise ApiValueError("Missing the required parameter `version` when calling `update_localization_by_elemental_id`")  # noqa: E501
+        # verify the required parameter 'elemental_id' is set
+        if self.api_client.client_side_validation and ('elemental_id' not in local_var_params or  # noqa: E501
+                                                        local_var_params['elemental_id'] is None):  # noqa: E501
+            raise ApiValueError("Missing the required parameter `elemental_id` when calling `update_localization_by_elemental_id`")  # noqa: E501
+        # verify the required parameter 'localization_update' is set
+        if self.api_client.client_side_validation and ('localization_update' not in local_var_params or  # noqa: E501
+                                                        local_var_params['localization_update'] is None):  # noqa: E501
+            raise ApiValueError("Missing the required parameter `localization_update` when calling `update_localization_by_elemental_id`")  # noqa: E501
+
+        collection_formats = {}
+
+        path_params = {}
+        if 'version' in local_var_params:
+            path_params['version'] = local_var_params['version']  # noqa: E501
+        if 'elemental_id' in local_var_params:
+            path_params['elemental_id'] = local_var_params['elemental_id']  # noqa: E501
+
+        query_params = []
+
+        header_params = {}
+
+        form_params = []
+        local_var_files = {}
+
+        body_params = None
+        if 'localization_update' in local_var_params:
+            body_params = local_var_params['localization_update']
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json'])  # noqa: E501
+
+        # HTTP header `Content-Type`
+        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
+            ['application/json'])  # noqa: E501
+
+        # Authentication setting
+        auth_settings = ['SessionAuth', 'TokenAuth']  # noqa: E501
+
+        return self.api_client.call_api(
+            '/rest/Localization/{version}/{elemental_id}', 'PATCH',
+            path_params,
+            query_params,
+            header_params,
+            body=body_params,
+            post_params=form_params,
+            files=local_var_files,
+            response_type='InlineResponse2001',  # noqa: E501
             auth_settings=auth_settings,
             async_req=local_var_params.get('async_req'),
             _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
             _preload_content=local_var_params.get('_preload_content', True),
             _request_timeout=local_var_params.get('_request_timeout',300),
             collection_formats=collection_formats)
 
@@ -28486,36 +30133,38 @@
         :param int section: Unique integer identifying a media section.
         :param int type: Unique integer identifying a annotation type.
         :param list[int] version: List of integers representing versions to fetch
         :param int after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str elemental_id: Elemental ID to search for
         :param int merge: Reduce result set based on a server side merge. If multiple versions are selected and a variant of the object exists in both versions, the merge logic will return 1 or 0 objects. Example:  Version B derives off Version A. An object, with the same elemental id \"foo\" exists on both. If Version B over A is selected and merge is turned on: + The \"foo\" present on Version B is returned  + If the \"foo\" on version B is deleted, no \"foo\" is returned.
         :param int show_deleted: Include in the return set objects that have `variant_deleted` set to True.
+        :param int show_all_marks: Include in the return set all marks, not just the latest.
         :param list[str] attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param int frame: Frame number of this localization if it is in a video.
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param str encoded_related_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec applied against related objects
+        :param int count: Expected count of elements affected by this operation. If the number of elements differs from this count, the operation is aborted and 400 response is returned.
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts. Default is 300.
@@ -28544,36 +30193,38 @@
         :param int section: Unique integer identifying a media section.
         :param int type: Unique integer identifying a annotation type.
         :param list[int] version: List of integers representing versions to fetch
         :param int after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str elemental_id: Elemental ID to search for
         :param int merge: Reduce result set based on a server side merge. If multiple versions are selected and a variant of the object exists in both versions, the merge logic will return 1 or 0 objects. Example:  Version B derives off Version A. An object, with the same elemental id \"foo\" exists on both. If Version B over A is selected and merge is turned on: + The \"foo\" present on Version B is returned  + If the \"foo\" on version B is deleted, no \"foo\" is returned.
         :param int show_deleted: Include in the return set objects that have `variant_deleted` set to True.
+        :param int show_all_marks: Include in the return set all marks, not just the latest.
         :param list[str] attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param int frame: Frame number of this localization if it is in a video.
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param str encoded_related_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec applied against related objects
+        :param int count: Expected count of elements affected by this operation. If the number of elements differs from this count, the operation is aborted and 400 response is returned.
         :param _return_http_data_only: response data without head status code
                                        and headers
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
@@ -28594,14 +30245,15 @@
             'section',
             'type',
             'version',
             'after',
             'elemental_id',
             'merge',
             'show_deleted',
+            'show_all_marks',
             'attribute',
             'attribute_lt',
             'attribute_lte',
             'attribute_gt',
             'attribute_gte',
             'attribute_contains',
             'attribute_distance',
@@ -28615,15 +30267,16 @@
             'related_attribute_lt',
             'related_attribute_lte',
             'related_attribute_gt',
             'related_attribute_gte',
             'related_attribute_contains',
             'related_attribute_distance',
             'related_attribute_null',
-            'encoded_related_search'
+            'encoded_related_search',
+            'count'
         ]
         all_params.extend(
             [
                 'async_req',
                 '_return_http_data_only',
                 '_preload_content',
                 '_request_timeout'
@@ -28651,16 +30304,22 @@
             raise ApiValueError("Invalid value for parameter `merge` when calling `update_localization_list`, must be a value less than or equal to `1`")  # noqa: E501
         if self.api_client.client_side_validation and 'merge' in local_var_params and local_var_params['merge'] < 0:  # noqa: E501
             raise ApiValueError("Invalid value for parameter `merge` when calling `update_localization_list`, must be a value greater than or equal to `0`")  # noqa: E501
         if self.api_client.client_side_validation and 'show_deleted' in local_var_params and local_var_params['show_deleted'] > 1:  # noqa: E501
             raise ApiValueError("Invalid value for parameter `show_deleted` when calling `update_localization_list`, must be a value less than or equal to `1`")  # noqa: E501
         if self.api_client.client_side_validation and 'show_deleted' in local_var_params and local_var_params['show_deleted'] < 0:  # noqa: E501
             raise ApiValueError("Invalid value for parameter `show_deleted` when calling `update_localization_list`, must be a value greater than or equal to `0`")  # noqa: E501
+        if self.api_client.client_side_validation and 'show_all_marks' in local_var_params and local_var_params['show_all_marks'] > 1:  # noqa: E501
+            raise ApiValueError("Invalid value for parameter `show_all_marks` when calling `update_localization_list`, must be a value less than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and 'show_all_marks' in local_var_params and local_var_params['show_all_marks'] < 0:  # noqa: E501
+            raise ApiValueError("Invalid value for parameter `show_all_marks` when calling `update_localization_list`, must be a value greater than or equal to `0`")  # noqa: E501
         if self.api_client.client_side_validation and 'frame' in local_var_params and local_var_params['frame'] < 0:  # noqa: E501
             raise ApiValueError("Invalid value for parameter `frame` when calling `update_localization_list`, must be a value greater than or equal to `0`")  # noqa: E501
+        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
+            raise ApiValueError("Invalid value for parameter `count` when calling `update_localization_list`, must be a value greater than or equal to `0`")  # noqa: E501
         collection_formats = {}
 
         path_params = {}
         if 'project' in local_var_params:
             path_params['project'] = local_var_params['project']  # noqa: E501
 
         query_params = []
@@ -28681,14 +30340,16 @@
             query_params.append(('after', local_var_params['after']))  # noqa: E501
         if 'elemental_id' in local_var_params and local_var_params['elemental_id'] is not None:  # noqa: E501
             query_params.append(('elemental_id', local_var_params['elemental_id']))  # noqa: E501
         if 'merge' in local_var_params and local_var_params['merge'] is not None:  # noqa: E501
             query_params.append(('merge', local_var_params['merge']))  # noqa: E501
         if 'show_deleted' in local_var_params and local_var_params['show_deleted'] is not None:  # noqa: E501
             query_params.append(('show_deleted', local_var_params['show_deleted']))  # noqa: E501
+        if 'show_all_marks' in local_var_params and local_var_params['show_all_marks'] is not None:  # noqa: E501
+            query_params.append(('show_all_marks', local_var_params['show_all_marks']))  # noqa: E501
         if 'attribute' in local_var_params and local_var_params['attribute'] is not None:  # noqa: E501
             query_params.append(('attribute', local_var_params['attribute']))  # noqa: E501
             collection_formats['attribute'] = 'csv'  # noqa: E501
         if 'attribute_lt' in local_var_params and local_var_params['attribute_lt'] is not None:  # noqa: E501
             query_params.append(('attribute_lt', local_var_params['attribute_lt']))  # noqa: E501
             collection_formats['attribute_lt'] = 'csv'  # noqa: E501
         if 'attribute_lte' in local_var_params and local_var_params['attribute_lte'] is not None:  # noqa: E501
@@ -28742,14 +30403,16 @@
             query_params.append(('related_attribute_distance', local_var_params['related_attribute_distance']))  # noqa: E501
             collection_formats['related_attribute_distance'] = 'csv'  # noqa: E501
         if 'related_attribute_null' in local_var_params and local_var_params['related_attribute_null'] is not None:  # noqa: E501
             query_params.append(('related_attribute_null', local_var_params['related_attribute_null']))  # noqa: E501
             collection_formats['related_attribute_null'] = 'csv'  # noqa: E501
         if 'encoded_related_search' in local_var_params and local_var_params['encoded_related_search'] is not None:  # noqa: E501
             query_params.append(('encoded_related_search', local_var_params['encoded_related_search']))  # noqa: E501
+        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
+            query_params.append(('count', local_var_params['count']))  # noqa: E501
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
@@ -29056,14 +30719,15 @@
         :param bool async_req: execute request asynchronously
         :param int project: A unique integer identifying a project. (required)
         :param MediaBulkUpdate media_bulk_update: (required)
         :param list[int] media_id: List of integers identifying media.
         :param int type: Unique integer identifying media type.
         :param str name: Name of the media to filter on.
         :param int section: Unique integer identifying a media section.
+        :param list[int] multi_section: List of integers identifying sections to select.
         :param str dtype: Data type of the files, either image or video.
         :param str md5: MD5 sum of the media file.
         :param str gid: Upload group ID of the media file.
         :param str uid: Upload unique ID of the media file.
         :param int after: If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str after_name: If given, all results returned will be after the media with this name. The `start` and `stop` parameters are relative to this modified range.
         :param str archive_lifecycle: Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
@@ -29075,24 +30739,25 @@
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param str encoded_related_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec applied against related objects
+        :param int count: Expected count of elements affected by this operation. If the number of elements differs from this count, the operation is aborted and 400 response is returned.
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts. Default is 300.
@@ -29116,14 +30781,15 @@
         :param bool async_req: execute request asynchronously
         :param int project: A unique integer identifying a project. (required)
         :param MediaBulkUpdate media_bulk_update: (required)
         :param list[int] media_id: List of integers identifying media.
         :param int type: Unique integer identifying media type.
         :param str name: Name of the media to filter on.
         :param int section: Unique integer identifying a media section.
+        :param list[int] multi_section: List of integers identifying sections to select.
         :param str dtype: Data type of the files, either image or video.
         :param str md5: MD5 sum of the media file.
         :param str gid: Upload group ID of the media file.
         :param str uid: Upload unique ID of the media file.
         :param int after: If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str after_name: If given, all results returned will be after the media with this name. The `start` and `stop` parameters are relative to this modified range.
         :param str archive_lifecycle: Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
@@ -29135,24 +30801,25 @@
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param str encoded_related_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec applied against related objects
+        :param int count: Expected count of elements affected by this operation. If the number of elements differs from this count, the operation is aborted and 400 response is returned.
         :param _return_http_data_only: response data without head status code
                                        and headers
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
@@ -29168,14 +30835,15 @@
         all_params = [
             'project',
             'media_bulk_update',
             'media_id',
             'type',
             'name',
             'section',
+            'multi_section',
             'dtype',
             'md5',
             'gid',
             'uid',
             'after',
             'after_name',
             'archive_lifecycle',
@@ -29196,15 +30864,16 @@
             'related_attribute_lt',
             'related_attribute_lte',
             'related_attribute_gt',
             'related_attribute_gte',
             'related_attribute_contains',
             'related_attribute_distance',
             'related_attribute_null',
-            'encoded_related_search'
+            'encoded_related_search',
+            'count'
         ]
         all_params.extend(
             [
                 'async_req',
                 '_return_http_data_only',
                 '_preload_content',
                 '_request_timeout'
@@ -29224,14 +30893,16 @@
                                                         local_var_params['project'] is None):  # noqa: E501
             raise ApiValueError("Missing the required parameter `project` when calling `update_media_list`")  # noqa: E501
         # verify the required parameter 'media_bulk_update' is set
         if self.api_client.client_side_validation and ('media_bulk_update' not in local_var_params or  # noqa: E501
                                                         local_var_params['media_bulk_update'] is None):  # noqa: E501
             raise ApiValueError("Missing the required parameter `media_bulk_update` when calling `update_media_list`")  # noqa: E501
 
+        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
+            raise ApiValueError("Invalid value for parameter `count` when calling `update_media_list`, must be a value greater than or equal to `0`")  # noqa: E501
         collection_formats = {}
 
         path_params = {}
         if 'project' in local_var_params:
             path_params['project'] = local_var_params['project']  # noqa: E501
 
         query_params = []
@@ -29240,14 +30911,17 @@
             collection_formats['media_id'] = 'csv'  # noqa: E501
         if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
             query_params.append(('type', local_var_params['type']))  # noqa: E501
         if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
             query_params.append(('name', local_var_params['name']))  # noqa: E501
         if 'section' in local_var_params and local_var_params['section'] is not None:  # noqa: E501
             query_params.append(('section', local_var_params['section']))  # noqa: E501
+        if 'multi_section' in local_var_params and local_var_params['multi_section'] is not None:  # noqa: E501
+            query_params.append(('multi_section', local_var_params['multi_section']))  # noqa: E501
+            collection_formats['multi_section'] = 'csv'  # noqa: E501
         if 'dtype' in local_var_params and local_var_params['dtype'] is not None:  # noqa: E501
             query_params.append(('dtype', local_var_params['dtype']))  # noqa: E501
         if 'md5' in local_var_params and local_var_params['md5'] is not None:  # noqa: E501
             query_params.append(('md5', local_var_params['md5']))  # noqa: E501
         if 'gid' in local_var_params and local_var_params['gid'] is not None:  # noqa: E501
             query_params.append(('gid', local_var_params['gid']))  # noqa: E501
         if 'uid' in local_var_params and local_var_params['uid'] is not None:  # noqa: E501
@@ -29315,14 +30989,16 @@
             query_params.append(('related_attribute_distance', local_var_params['related_attribute_distance']))  # noqa: E501
             collection_formats['related_attribute_distance'] = 'csv'  # noqa: E501
         if 'related_attribute_null' in local_var_params and local_var_params['related_attribute_null'] is not None:  # noqa: E501
             query_params.append(('related_attribute_null', local_var_params['related_attribute_null']))  # noqa: E501
             collection_formats['related_attribute_null'] = 'csv'  # noqa: E501
         if 'encoded_related_search' in local_var_params and local_var_params['encoded_related_search'] is not None:  # noqa: E501
             query_params.append(('encoded_related_search', local_var_params['encoded_related_search']))  # noqa: E501
+        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
+            query_params.append(('count', local_var_params['count']))  # noqa: E501
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
@@ -30001,14 +31677,174 @@
             auth_settings=auth_settings,
             async_req=local_var_params.get('async_req'),
             _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
             _preload_content=local_var_params.get('_preload_content', True),
             _request_timeout=local_var_params.get('_request_timeout',300),
             collection_formats=collection_formats)
 
+    def update_section_list(self, project, section_bulk_update, **kwargs):
+        """update_section_list
+
+        Update section list.  Sections represent groups of media using saved queries.   This method does a bulk update on all section matching a query. 
+
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.update_section_list(project, section_bulk_update, async_req=True)
+        >>> result = thread.get()
+
+        :param bool async_req: execute request asynchronously
+        :param int project: A unique integer identifying a project. (required)
+        :param SectionBulkUpdate section_bulk_update: (required)
+        :param str name: Name of the section.
+        :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
+        :param str elemental_id: Elemental ID to search for
+        :param str match: Find any sections matching using an lquery.                - foo         Match the exact label path foo             - *.foo.*     Match any label path containing the label foo             - *.foo       Match any label path whose last label is foo              Modifiers:             - @           Match case-insensitively, for example a@ matches A             - *           Match any label with this prefix, for example foo* matches foobar             - %           Match initial underscore-separated words              American@.Foot@*              would match both             america.Football and America.footwear                  For more information: https://www.postgresql.org/docs/current/ltree.html 
+        :param str ancestors: Find ancestors using using an lquery.                - foo         Match the exact label path foo             - *.foo.*     Match any label path containing the label foo             - *.foo       Match any label path whose last label is foo              Modifiers:             - @           Match case-insensitively, for example a@ matches A             - *           Match any label with this prefix, for example foo* matches foobar             - %           Match initial underscore-separated words              American@.Foot@*              would match both             america.Football and America.footwear                  For more information: https://www.postgresql.org/docs/current/ltree.html 
+        :param str descendants: Find descendants using using an lquery.                - foo         Match the exact label path foo             - *.foo.*     Match any label path containing the label foo             - *.foo       Match any label path whose last label is foo              Modifiers:             - @           Match case-insensitively, for example a@ matches A             - *           Match any label with this prefix, for example foo* matches foobar             - %           Match initial underscore-separated words              American@.Foot@*              would match both             america.Football and America.footwear                  For more information: https://www.postgresql.org/docs/current/ltree.html 
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts. Default is 300.
+        :return: :class:`tator.models.MessageResponse`
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.update_section_list_with_http_info(project, section_bulk_update, **kwargs)  # noqa: E501
+
+    def update_section_list_with_http_info(self, project, section_bulk_update, **kwargs):  # noqa: E501
+        """
+        Update section list.  Sections represent groups of media using saved queries.   This method does a bulk update on all section matching a query.   # noqa: E501
+
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.update_section_list_with_http_info(project, section_bulk_update, async_req=True)
+        >>> result = thread.get()
+
+        :param bool async_req: execute request asynchronously
+        :param int project: A unique integer identifying a project. (required)
+        :param SectionBulkUpdate section_bulk_update: (required)
+        :param str name: Name of the section.
+        :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
+        :param str elemental_id: Elemental ID to search for
+        :param str match: Find any sections matching using an lquery.                - foo         Match the exact label path foo             - *.foo.*     Match any label path containing the label foo             - *.foo       Match any label path whose last label is foo              Modifiers:             - @           Match case-insensitively, for example a@ matches A             - *           Match any label with this prefix, for example foo* matches foobar             - %           Match initial underscore-separated words              American@.Foot@*              would match both             america.Football and America.footwear                  For more information: https://www.postgresql.org/docs/current/ltree.html 
+        :param str ancestors: Find ancestors using using an lquery.                - foo         Match the exact label path foo             - *.foo.*     Match any label path containing the label foo             - *.foo       Match any label path whose last label is foo              Modifiers:             - @           Match case-insensitively, for example a@ matches A             - *           Match any label with this prefix, for example foo* matches foobar             - %           Match initial underscore-separated words              American@.Foot@*              would match both             america.Football and America.footwear                  For more information: https://www.postgresql.org/docs/current/ltree.html 
+        :param str descendants: Find descendants using using an lquery.                - foo         Match the exact label path foo             - *.foo.*     Match any label path containing the label foo             - *.foo       Match any label path whose last label is foo              Modifiers:             - @           Match case-insensitively, for example a@ matches A             - *           Match any label with this prefix, for example foo* matches foobar             - %           Match initial underscore-separated words              American@.Foot@*              would match both             america.Football and America.footwear                  For more information: https://www.postgresql.org/docs/current/ltree.html 
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts. Default is 300.
+        :return: tuple(:class:`tator.models.MessageResponse`, status_code(int), headers(HTTPHeaderDict))
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+
+        local_var_params = locals()
+
+        all_params = [
+            'project',
+            'section_bulk_update',
+            'name',
+            'encoded_search',
+            'elemental_id',
+            'match',
+            'ancestors',
+            'descendants'
+        ]
+        all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout'
+            ]
+        )
+
+        for key, val in six.iteritems(local_var_params['kwargs']):
+            if key not in all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method update_section_list" % key
+                )
+            local_var_params[key] = val
+        del local_var_params['kwargs']
+        # verify the required parameter 'project' is set
+        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
+                                                        local_var_params['project'] is None):  # noqa: E501
+            raise ApiValueError("Missing the required parameter `project` when calling `update_section_list`")  # noqa: E501
+        # verify the required parameter 'section_bulk_update' is set
+        if self.api_client.client_side_validation and ('section_bulk_update' not in local_var_params or  # noqa: E501
+                                                        local_var_params['section_bulk_update'] is None):  # noqa: E501
+            raise ApiValueError("Missing the required parameter `section_bulk_update` when calling `update_section_list`")  # noqa: E501
+
+        collection_formats = {}
+
+        path_params = {}
+        if 'project' in local_var_params:
+            path_params['project'] = local_var_params['project']  # noqa: E501
+
+        query_params = []
+        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
+            query_params.append(('name', local_var_params['name']))  # noqa: E501
+        if 'encoded_search' in local_var_params and local_var_params['encoded_search'] is not None:  # noqa: E501
+            query_params.append(('encoded_search', local_var_params['encoded_search']))  # noqa: E501
+        if 'elemental_id' in local_var_params and local_var_params['elemental_id'] is not None:  # noqa: E501
+            query_params.append(('elemental_id', local_var_params['elemental_id']))  # noqa: E501
+        if 'match' in local_var_params and local_var_params['match'] is not None:  # noqa: E501
+            query_params.append(('match', local_var_params['match']))  # noqa: E501
+        if 'ancestors' in local_var_params and local_var_params['ancestors'] is not None:  # noqa: E501
+            query_params.append(('ancestors', local_var_params['ancestors']))  # noqa: E501
+        if 'descendants' in local_var_params and local_var_params['descendants'] is not None:  # noqa: E501
+            query_params.append(('descendants', local_var_params['descendants']))  # noqa: E501
+
+        header_params = {}
+
+        form_params = []
+        local_var_files = {}
+
+        body_params = None
+        if 'section_bulk_update' in local_var_params:
+            body_params = local_var_params['section_bulk_update']
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json'])  # noqa: E501
+
+        # HTTP header `Content-Type`
+        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
+            ['application/json'])  # noqa: E501
+
+        # Authentication setting
+        auth_settings = ['SessionAuth', 'TokenAuth']  # noqa: E501
+
+        return self.api_client.call_api(
+            '/rest/Sections/{project}', 'PATCH',
+            path_params,
+            query_params,
+            header_params,
+            body=body_params,
+            post_params=form_params,
+            files=local_var_files,
+            response_type='MessageResponse',  # noqa: E501
+            auth_settings=auth_settings,
+            async_req=local_var_params.get('async_req'),
+            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=local_var_params.get('_preload_content', True),
+            _request_timeout=local_var_params.get('_request_timeout',300),
+            collection_formats=collection_formats)
+
     def update_state(self, id, state_update, **kwargs):
         """update_state
 
         Update state.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes. 
 
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
@@ -30022,15 +31858,15 @@
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts. Default is 300.
-        :return: :class:`tator.models.MessageResponse`
+        :return: :class:`tator.models.InlineResponse2002`
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
         return self.update_state_with_http_info(id, state_update, **kwargs)  # noqa: E501
 
     def update_state_with_http_info(self, id, state_update, **kwargs):  # noqa: E501
@@ -30051,15 +31887,15 @@
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts. Default is 300.
-        :return: tuple(:class:`tator.models.MessageResponse`, status_code(int), headers(HTTPHeaderDict))
+        :return: tuple(:class:`tator.models.InlineResponse2002`, status_code(int), headers(HTTPHeaderDict))
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         local_var_params = locals()
 
         all_params = [
@@ -30123,15 +31959,154 @@
             '/rest/State/{id}', 'PATCH',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='MessageResponse',  # noqa: E501
+            response_type='InlineResponse2002',  # noqa: E501
+            auth_settings=auth_settings,
+            async_req=local_var_params.get('async_req'),
+            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=local_var_params.get('_preload_content', True),
+            _request_timeout=local_var_params.get('_request_timeout',300),
+            collection_formats=collection_formats)
+
+    def update_state_by_elemental_id(self, version, elemental_id, state_update, **kwargs):
+        """update_state_by_elemental_id
+
+        Update state.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes. 
+
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.update_state_by_elemental_id(version, elemental_id, state_update, async_req=True)
+        >>> result = thread.get()
+
+        :param bool async_req: execute request asynchronously
+        :param int version: Version ID to select object from (required)
+        :param str elemental_id: Elemental ID to fetch (required)
+        :param StateUpdate state_update: (required)
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts. Default is 300.
+        :return: :class:`tator.models.InlineResponse2002`
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.update_state_by_elemental_id_with_http_info(version, elemental_id, state_update, **kwargs)  # noqa: E501
+
+    def update_state_by_elemental_id_with_http_info(self, version, elemental_id, state_update, **kwargs):  # noqa: E501
+        """
+        Update state.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes.   # noqa: E501
+
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.update_state_by_elemental_id_with_http_info(version, elemental_id, state_update, async_req=True)
+        >>> result = thread.get()
+
+        :param bool async_req: execute request asynchronously
+        :param int version: Version ID to select object from (required)
+        :param str elemental_id: Elemental ID to fetch (required)
+        :param StateUpdate state_update: (required)
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts. Default is 300.
+        :return: tuple(:class:`tator.models.InlineResponse2002`, status_code(int), headers(HTTPHeaderDict))
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+
+        local_var_params = locals()
+
+        all_params = [
+            'version',
+            'elemental_id',
+            'state_update'
+        ]
+        all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout'
+            ]
+        )
+
+        for key, val in six.iteritems(local_var_params['kwargs']):
+            if key not in all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method update_state_by_elemental_id" % key
+                )
+            local_var_params[key] = val
+        del local_var_params['kwargs']
+        # verify the required parameter 'version' is set
+        if self.api_client.client_side_validation and ('version' not in local_var_params or  # noqa: E501
+                                                        local_var_params['version'] is None):  # noqa: E501
+            raise ApiValueError("Missing the required parameter `version` when calling `update_state_by_elemental_id`")  # noqa: E501
+        # verify the required parameter 'elemental_id' is set
+        if self.api_client.client_side_validation and ('elemental_id' not in local_var_params or  # noqa: E501
+                                                        local_var_params['elemental_id'] is None):  # noqa: E501
+            raise ApiValueError("Missing the required parameter `elemental_id` when calling `update_state_by_elemental_id`")  # noqa: E501
+        # verify the required parameter 'state_update' is set
+        if self.api_client.client_side_validation and ('state_update' not in local_var_params or  # noqa: E501
+                                                        local_var_params['state_update'] is None):  # noqa: E501
+            raise ApiValueError("Missing the required parameter `state_update` when calling `update_state_by_elemental_id`")  # noqa: E501
+
+        collection_formats = {}
+
+        path_params = {}
+        if 'version' in local_var_params:
+            path_params['version'] = local_var_params['version']  # noqa: E501
+        if 'elemental_id' in local_var_params:
+            path_params['elemental_id'] = local_var_params['elemental_id']  # noqa: E501
+
+        query_params = []
+
+        header_params = {}
+
+        form_params = []
+        local_var_files = {}
+
+        body_params = None
+        if 'state_update' in local_var_params:
+            body_params = local_var_params['state_update']
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json'])  # noqa: E501
+
+        # HTTP header `Content-Type`
+        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
+            ['application/json'])  # noqa: E501
+
+        # Authentication setting
+        auth_settings = ['SessionAuth', 'TokenAuth']  # noqa: E501
+
+        return self.api_client.call_api(
+            '/rest/State/{version}/{elemental_id}', 'PATCH',
+            path_params,
+            query_params,
+            header_params,
+            body=body_params,
+            post_params=form_params,
+            files=local_var_files,
+            response_type='InlineResponse2002',  # noqa: E501
             auth_settings=auth_settings,
             async_req=local_var_params.get('async_req'),
             _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
             _preload_content=local_var_params.get('_preload_content', True),
             _request_timeout=local_var_params.get('_request_timeout',300),
             collection_formats=collection_formats)
 
@@ -30154,35 +32129,37 @@
         :param int section: Unique integer identifying a media section.
         :param int type: Unique integer identifying a annotation type.
         :param list[int] version: List of integers representing versions to fetch
         :param int after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str elemental_id: Elemental ID to search for
         :param int merge: Reduce result set based on a server side merge. If multiple versions are selected and a variant of the object exists in both versions, the merge logic will return 1 or 0 objects. Example:  Version B derives off Version A. An object, with the same elemental id \"foo\" exists on both. If Version B over A is selected and merge is turned on: + The \"foo\" present on Version B is returned  + If the \"foo\" on version B is deleted, no \"foo\" is returned.
         :param int show_deleted: Include in the return set objects that have `variant_deleted` set to True.
+        :param int show_all_marks: Include in the return set all marks, not just the latest.
         :param list[str] attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param str encoded_related_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec applied against related objects
+        :param int count: Expected count of elements affected by this operation. If the number of elements differs from this count, the operation is aborted and 400 response is returned.
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts. Default is 300.
@@ -30211,35 +32188,37 @@
         :param int section: Unique integer identifying a media section.
         :param int type: Unique integer identifying a annotation type.
         :param list[int] version: List of integers representing versions to fetch
         :param int after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
         :param str elemental_id: Elemental ID to search for
         :param int merge: Reduce result set based on a server side merge. If multiple versions are selected and a variant of the object exists in both versions, the merge logic will return 1 or 0 objects. Example:  Version B derives off Version A. An object, with the same elemental id \"foo\" exists on both. If Version B over A is selected and merge is turned on: + The \"foo\" present on Version B is returned  + If the \"foo\" on version B is deleted, no \"foo\" is returned.
         :param int show_deleted: Include in the return set objects that have `variant_deleted` set to True.
+        :param int show_all_marks: Include in the return set all marks, not just the latest.
         :param list[str] attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
         :param list[str] attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
         :param list[str] attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
         :param int start: Pagination start index. Index of the first item in a larger list to return.
         :param int stop: Pagination stop index. Non-inclusive index of the last item in a larger list to return.
         :param str encoded_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec
-        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                          | Name              | Description                            | Localizations | States | Medias | Leaves | Files |      |-------------------|----------------------------------------|---------------|--------|--------|--------|-------|     | section           | Media section                          |       X       |   X    |   X    |        |       |     | created_datetime  | The time of creation for this datum    |       X       |   X    |   X    |    X   |   X   |     | created_by        | The user id who created this datum     |       X       |   X    |   X    |    X   |   X   |     | modified_datetime | The last modification time             |       X       |   X    |   X    |    X   |   X   |     | modified_by       | The last modification user             |       X       |   X    |   X    |    X   |   X   |     | name              | The name of the element                |               |        |   X    |    X   |   X   |     | fps               | The frames per second                  |               |        |   X    |        |       |     | deleted           | Whether the media is marked deleted    |               |        |   X    |    X   |   X   |     | variant_deleted   | Whether the metadata is marked deleted |       X       |   X    |        |        |       |     | archive_state     | The current archive state of the media |               |        |   X    |        |       |     | x, y, u, or v     | Geometric coordinates                  |               |        |        |        |       |     | width or height   | Geometric sizes                        |               |        |        |        |       |     | incident          | Available when doing a related search  |               |        |   X    |        |       |    
+        :param list[str] sort_by: Field names to sort results by. Built-in names should be prefixed with '$', attributes must not be.                   Because the schema supports sorting by a list of attributes (effectively grouping), we have to utilize a special character to inform direction.         Uses the common convention of '-'; thus `[\"$name\", \"-$id\"]` would sort by name ascending and break tie-breakers(grouping) by descending by id.          An example REST query will sort all localizations in project 1, by label descending and sort any ties by ascending x.          `rest/Localizations/1?sort_by=-Label&sort_by=$x`           A table of built-ins available for a given type:                      <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr> </table> 
         :param list[str] related_attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param list[str] related_attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.This filter is applied to related data of the primary object.On the Media endpoint, this searches on related metadata(States/Localizations).On metadata endpoints, this searches on related media.
         :param str encoded_related_search: Base64 encoded string representing an `Object_Search` defined in /components/AttributeOperationSpec applied against related objects
+        :param int count: Expected count of elements affected by this operation. If the number of elements differs from this count, the operation is aborted and 400 response is returned.
         :param _return_http_data_only: response data without head status code
                                        and headers
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
@@ -30260,14 +32239,15 @@
             'section',
             'type',
             'version',
             'after',
             'elemental_id',
             'merge',
             'show_deleted',
+            'show_all_marks',
             'attribute',
             'attribute_lt',
             'attribute_lte',
             'attribute_gt',
             'attribute_gte',
             'attribute_contains',
             'attribute_distance',
@@ -30280,15 +32260,16 @@
             'related_attribute_lt',
             'related_attribute_lte',
             'related_attribute_gt',
             'related_attribute_gte',
             'related_attribute_contains',
             'related_attribute_distance',
             'related_attribute_null',
-            'encoded_related_search'
+            'encoded_related_search',
+            'count'
         ]
         all_params.extend(
             [
                 'async_req',
                 '_return_http_data_only',
                 '_preload_content',
                 '_request_timeout'
@@ -30316,14 +32297,20 @@
             raise ApiValueError("Invalid value for parameter `merge` when calling `update_state_list`, must be a value less than or equal to `1`")  # noqa: E501
         if self.api_client.client_side_validation and 'merge' in local_var_params and local_var_params['merge'] < 0:  # noqa: E501
             raise ApiValueError("Invalid value for parameter `merge` when calling `update_state_list`, must be a value greater than or equal to `0`")  # noqa: E501
         if self.api_client.client_side_validation and 'show_deleted' in local_var_params and local_var_params['show_deleted'] > 1:  # noqa: E501
             raise ApiValueError("Invalid value for parameter `show_deleted` when calling `update_state_list`, must be a value less than or equal to `1`")  # noqa: E501
         if self.api_client.client_side_validation and 'show_deleted' in local_var_params and local_var_params['show_deleted'] < 0:  # noqa: E501
             raise ApiValueError("Invalid value for parameter `show_deleted` when calling `update_state_list`, must be a value greater than or equal to `0`")  # noqa: E501
+        if self.api_client.client_side_validation and 'show_all_marks' in local_var_params and local_var_params['show_all_marks'] > 1:  # noqa: E501
+            raise ApiValueError("Invalid value for parameter `show_all_marks` when calling `update_state_list`, must be a value less than or equal to `1`")  # noqa: E501
+        if self.api_client.client_side_validation and 'show_all_marks' in local_var_params and local_var_params['show_all_marks'] < 0:  # noqa: E501
+            raise ApiValueError("Invalid value for parameter `show_all_marks` when calling `update_state_list`, must be a value greater than or equal to `0`")  # noqa: E501
+        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
+            raise ApiValueError("Invalid value for parameter `count` when calling `update_state_list`, must be a value greater than or equal to `0`")  # noqa: E501
         collection_formats = {}
 
         path_params = {}
         if 'project' in local_var_params:
             path_params['project'] = local_var_params['project']  # noqa: E501
 
         query_params = []
@@ -30344,14 +32331,16 @@
             query_params.append(('after', local_var_params['after']))  # noqa: E501
         if 'elemental_id' in local_var_params and local_var_params['elemental_id'] is not None:  # noqa: E501
             query_params.append(('elemental_id', local_var_params['elemental_id']))  # noqa: E501
         if 'merge' in local_var_params and local_var_params['merge'] is not None:  # noqa: E501
             query_params.append(('merge', local_var_params['merge']))  # noqa: E501
         if 'show_deleted' in local_var_params and local_var_params['show_deleted'] is not None:  # noqa: E501
             query_params.append(('show_deleted', local_var_params['show_deleted']))  # noqa: E501
+        if 'show_all_marks' in local_var_params and local_var_params['show_all_marks'] is not None:  # noqa: E501
+            query_params.append(('show_all_marks', local_var_params['show_all_marks']))  # noqa: E501
         if 'attribute' in local_var_params and local_var_params['attribute'] is not None:  # noqa: E501
             query_params.append(('attribute', local_var_params['attribute']))  # noqa: E501
             collection_formats['attribute'] = 'csv'  # noqa: E501
         if 'attribute_lt' in local_var_params and local_var_params['attribute_lt'] is not None:  # noqa: E501
             query_params.append(('attribute_lt', local_var_params['attribute_lt']))  # noqa: E501
             collection_formats['attribute_lt'] = 'csv'  # noqa: E501
         if 'attribute_lte' in local_var_params and local_var_params['attribute_lte'] is not None:  # noqa: E501
@@ -30403,14 +32392,16 @@
             query_params.append(('related_attribute_distance', local_var_params['related_attribute_distance']))  # noqa: E501
             collection_formats['related_attribute_distance'] = 'csv'  # noqa: E501
         if 'related_attribute_null' in local_var_params and local_var_params['related_attribute_null'] is not None:  # noqa: E501
             query_params.append(('related_attribute_null', local_var_params['related_attribute_null']))  # noqa: E501
             collection_formats['related_attribute_null'] = 'csv'  # noqa: E501
         if 'encoded_related_search' in local_var_params and local_var_params['encoded_related_search'] is not None:  # noqa: E501
             query_params.append(('encoded_related_search', local_var_params['encoded_related_search']))  # noqa: E501
+        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
+            query_params.append(('count', local_var_params['count']))  # noqa: E501
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/api_client.py` & `tator-1.3.0/tator/openapi/tator_openapi/api_client.py`

 * *Files 1% similar despite different names*

```diff
@@ -75,15 +75,15 @@
 
         self.rest_client = rest.RESTClientObject(configuration)
         self.default_headers = {}
         if header_name is not None:
             self.default_headers[header_name] = header_value
         self.cookie = cookie
         # Set default User-Agent.
-        self.user_agent = 'OpenAPI-Generator/1.2.9/python'
+        self.user_agent = 'OpenAPI-Generator/1.3.0/python'
         self.client_side_validation = configuration.client_side_validation
 
     def __enter__(self):
         return self
 
     def __exit__(self, exc_type, exc_value, traceback):
         self.close()
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/configuration.py` & `tator-1.3.0/tator/openapi/tator_openapi/configuration.py`

 * *Files 0% similar despite different names*

```diff
@@ -355,15 +355,15 @@
 
         :return: The report for debugging.
         """
         return "Python SDK Debug Report:\n"\
                "OS: {env}\n"\
                "Python Version: {pyversion}\n"\
                "Version of the API: v1\n"\
-               "SDK Package Version: 1.2.9".\
+               "SDK Package Version: 1.3.0".\
                format(env=sys.platform, pyversion=sys.version)
 
     def get_host_settings(self):
         """Gets an array of host settings
 
         :return: An array of host settings
         """
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/exceptions.py` & `tator-1.3.0/tator/openapi/tator_openapi/exceptions.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/__init__.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/__init__.py`

 * *Files 1% similar despite different names*

```diff
@@ -73,15 +73,20 @@
 from tator.openapi.tator_openapi.models.file_type_update import FileTypeUpdate
 from tator.openapi.tator_openapi.models.file_update import FileUpdate
 from tator.openapi.tator_openapi.models.fill import Fill
 from tator.openapi.tator_openapi.models.float_array_query import FloatArrayQuery
 from tator.openapi.tator_openapi.models.generic_file import GenericFile
 from tator.openapi.tator_openapi.models.generic_file_spec import GenericFileSpec
 from tator.openapi.tator_openapi.models.get_cloned_media_response import GetClonedMediaResponse
+from tator.openapi.tator_openapi.models.hosted_template import HostedTemplate
+from tator.openapi.tator_openapi.models.hosted_template_spec import HostedTemplateSpec
 from tator.openapi.tator_openapi.models.image_definition import ImageDefinition
+from tator.openapi.tator_openapi.models.inline_response200 import InlineResponse200
+from tator.openapi.tator_openapi.models.inline_response2001 import InlineResponse2001
+from tator.openapi.tator_openapi.models.inline_response2002 import InlineResponse2002
 from tator.openapi.tator_openapi.models.invitation import Invitation
 from tator.openapi.tator_openapi.models.invitation_spec import InvitationSpec
 from tator.openapi.tator_openapi.models.invitation_update import InvitationUpdate
 from tator.openapi.tator_openapi.models.job import Job
 from tator.openapi.tator_openapi.models.job_cluster import JobCluster
 from tator.openapi.tator_openapi.models.job_cluster_spec import JobClusterSpec
 from tator.openapi.tator_openapi.models.job_node import JobNode
@@ -126,21 +131,24 @@
 from tator.openapi.tator_openapi.models.message_response import MessageResponse
 from tator.openapi.tator_openapi.models.multi_definition import MultiDefinition
 from tator.openapi.tator_openapi.models.not_found_response import NotFoundResponse
 from tator.openapi.tator_openapi.models.notify_spec import NotifySpec
 from tator.openapi.tator_openapi.models.organization import Organization
 from tator.openapi.tator_openapi.models.organization_spec import OrganizationSpec
 from tator.openapi.tator_openapi.models.organization_update import OrganizationUpdate
+from tator.openapi.tator_openapi.models.parameter import Parameter
 from tator.openapi.tator_openapi.models.password_reset_spec import PasswordResetSpec
 from tator.openapi.tator_openapi.models.project import Project
 from tator.openapi.tator_openapi.models.project_spec import ProjectSpec
 from tator.openapi.tator_openapi.models.project_update import ProjectUpdate
 from tator.openapi.tator_openapi.models.resolution_config import ResolutionConfig
 from tator.openapi.tator_openapi.models.s3_storage_config import S3StorageConfig
 from tator.openapi.tator_openapi.models.section import Section
+from tator.openapi.tator_openapi.models.section_bulk_update import SectionBulkUpdate
+from tator.openapi.tator_openapi.models.section_bulk_update_path_substitution import SectionBulkUpdatePathSubstitution
 from tator.openapi.tator_openapi.models.section_spec import SectionSpec
 from tator.openapi.tator_openapi.models.section_update import SectionUpdate
 from tator.openapi.tator_openapi.models.state import State
 from tator.openapi.tator_openapi.models.state_bulk_delete import StateBulkDelete
 from tator.openapi.tator_openapi.models.state_bulk_update import StateBulkUpdate
 from tator.openapi.tator_openapi.models.state_delete import StateDelete
 from tator.openapi.tator_openapi.models.state_id_query import StateIdQuery
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/affiliation.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/affiliation.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/affiliation_spec.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/affiliation_spec.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/affiliation_update.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/affiliation_update.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/algorithm.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/version.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,298 +14,273 @@
 import re  # noqa: F401
 
 import six
 
 from ..configuration import Configuration
 
 
-class Algorithm(object):
+class Version(object):
     """
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
-        'categories': 'list[str]',
-        'cluster': 'int',
+        'bases': 'list[int]',
+        'created_by': 'str',
         'description': 'str',
-        'files_per_job': 'int',
+        'elemental_id': 'str',
         'id': 'int',
-        'manifest': 'str',
         'name': 'str',
-        'parameters': 'list[AlgorithmParameter]',
+        'number': 'int',
         'project': 'int',
-        'user': 'int'
+        'show_empty': 'bool'
     }
 
     attribute_map = {
-        'categories': 'categories',
-        'cluster': 'cluster',
+        'bases': 'bases',
+        'created_by': 'created_by',
         'description': 'description',
-        'files_per_job': 'files_per_job',
+        'elemental_id': 'elemental_id',
         'id': 'id',
-        'manifest': 'manifest',
         'name': 'name',
-        'parameters': 'parameters',
+        'number': 'number',
         'project': 'project',
-        'user': 'user'
+        'show_empty': 'show_empty'
     }
 
-    def __init__(self, categories=None, cluster=None, description=None, files_per_job=None, id=None, manifest=None, name=None, parameters=None, project=None, user=None, local_vars_configuration=None):  # noqa: E501
-        """Algorithm - a model defined in OpenAPI"""
+    def __init__(self, bases=None, created_by=None, description='', elemental_id=None, id=None, name=None, number=None, project=None, show_empty=True, local_vars_configuration=None):  # noqa: E501
+        """Version - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration()
         self.local_vars_configuration = local_vars_configuration
 
-        self._categories = None
-        self._cluster = None
+        self._bases = None
+        self._created_by = None
         self._description = None
-        self._files_per_job = None
+        self._elemental_id = None
         self._id = None
-        self._manifest = None
         self._name = None
-        self._parameters = None
+        self._number = None
         self._project = None
-        self._user = None
+        self._show_empty = None
         self.discriminator = None
 
-        if categories is not None:
-            self.categories = categories
-        self.cluster = cluster
+        if bases is not None:
+            self.bases = bases
+        if created_by is not None:
+            self.created_by = created_by
         if description is not None:
             self.description = description
-        if files_per_job is not None:
-            self.files_per_job = files_per_job
+        if elemental_id is not None:
+            self.elemental_id = elemental_id
         if id is not None:
             self.id = id
-        if manifest is not None:
-            self.manifest = manifest
         if name is not None:
             self.name = name
-        if parameters is not None:
-            self.parameters = parameters
+        if number is not None:
+            self.number = number
         if project is not None:
             self.project = project
-        if user is not None:
-            self.user = user
+        if show_empty is not None:
+            self.show_empty = show_empty
 
     @property
-    def categories(self):
+    def bases(self):
         """
-        List of categories the algorithm workflow belongs to
+        Array of other version IDs that are dependencies of this version.
 
-        :return: The categories of this Algorithm. 
-        :rtype: list[str]
+        :return: The bases of this Version. 
+        :rtype: list[int]
         """
-        return self._categories
+        return self._bases
 
-    @categories.setter
-    def categories(self, categories):
+    @bases.setter
+    def bases(self, bases):
         """
-        List of categories the algorithm workflow belongs to
+        Array of other version IDs that are dependencies of this version.
 
-        :param categories: The categories of this Algorithm.
-        :type: list[str]
+        :param bases: The bases of this Version.
+        :type: list[int]
         """
 
-        self._categories = categories
+        self._bases = bases
 
     @property
-    def cluster(self):
+    def created_by(self):
         """
-        Unique integer identifying the job cluster.
+        Name of user who created the last unmodified annotation in this version.
 
-        :return: The cluster of this Algorithm. 
-        :rtype: int
+        :return: The created_by of this Version. 
+        :rtype: str
         """
-        return self._cluster
+        return self._created_by
 
-    @cluster.setter
-    def cluster(self, cluster):
+    @created_by.setter
+    def created_by(self, created_by):
         """
-        Unique integer identifying the job cluster.
+        Name of user who created the last unmodified annotation in this version.
 
-        :param cluster: The cluster of this Algorithm.
-        :type: int
+        :param created_by: The created_by of this Version.
+        :type: str
         """
 
-        self._cluster = cluster
+        self._created_by = created_by
 
     @property
     def description(self):
         """
-        Description of the algorithm.
+        Description of the version.
 
-        :return: The description of this Algorithm. 
+        :return: The description of this Version. 
         :rtype: str
         """
         return self._description
 
     @description.setter
     def description(self, description):
         """
-        Description of the algorithm.
+        Description of the version.
 
-        :param description: The description of this Algorithm.
+        :param description: The description of this Version.
         :type: str
         """
 
         self._description = description
 
     @property
-    def files_per_job(self):
+    def elemental_id(self):
         """
-        Number of media files to be submitted to each workflow.
+        Unique ID of an element
 
-        :return: The files_per_job of this Algorithm. 
-        :rtype: int
+        :return: The elemental_id of this Version. 
+        :rtype: str
         """
-        return self._files_per_job
+        return self._elemental_id
 
-    @files_per_job.setter
-    def files_per_job(self, files_per_job):
+    @elemental_id.setter
+    def elemental_id(self, elemental_id):
         """
-        Number of media files to be submitted to each workflow.
+        Unique ID of an element
 
-        :param files_per_job: The files_per_job of this Algorithm.
-        :type: int
+        :param elemental_id: The elemental_id of this Version.
+        :type: str
         """
 
-        self._files_per_job = files_per_job
+        self._elemental_id = elemental_id
 
     @property
     def id(self):
         """
-        Unique integer identifying the registered algorithm.
+        Unique integer identifying a membership.
 
-        :return: The id of this Algorithm. 
+        :return: The id of this Version. 
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """
-        Unique integer identifying the registered algorithm.
+        Unique integer identifying a membership.
 
-        :param id: The id of this Algorithm.
+        :param id: The id of this Version.
         :type: int
         """
 
         self._id = id
 
     @property
-    def manifest(self):
-        """
-        Server URL to argo manifest file (.yaml)
-
-        :return: The manifest of this Algorithm. 
-        :rtype: str
-        """
-        return self._manifest
-
-    @manifest.setter
-    def manifest(self, manifest):
-        """
-        Server URL to argo manifest file (.yaml)
-
-        :param manifest: The manifest of this Algorithm.
-        :type: str
-        """
-
-        self._manifest = manifest
-
-    @property
     def name(self):
         """
-        Unique name of the algorithm workflow.
+        Name of the version.
 
-        :return: The name of this Algorithm. 
+        :return: The name of this Version. 
         :rtype: str
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """
-        Unique name of the algorithm workflow.
+        Name of the version.
 
-        :param name: The name of this Algorithm.
+        :param name: The name of this Version.
         :type: str
         """
 
         self._name = name
 
     @property
-    def parameters(self):
+    def number(self):
         """
-        List of algorithm workflow parameters
+        Version number.
 
-        :return: The parameters of this Algorithm. 
-        :rtype: list[AlgorithmParameter]
+        :return: The number of this Version. 
+        :rtype: int
         """
-        return self._parameters
+        return self._number
 
-    @parameters.setter
-    def parameters(self, parameters):
+    @number.setter
+    def number(self, number):
         """
-        List of algorithm workflow parameters
+        Version number.
 
-        :param parameters: The parameters of this Algorithm.
-        :type: list[AlgorithmParameter]
+        :param number: The number of this Version.
+        :type: int
         """
 
-        self._parameters = parameters
+        self._number = number
 
     @property
     def project(self):
         """
-        Unique integer identifying the project associated with the algorithm.
+        Unique integer identifying a project.
 
-        :return: The project of this Algorithm. 
+        :return: The project of this Version. 
         :rtype: int
         """
         return self._project
 
     @project.setter
     def project(self, project):
         """
-        Unique integer identifying the project associated with the algorithm.
+        Unique integer identifying a project.
 
-        :param project: The project of this Algorithm.
+        :param project: The project of this Version.
         :type: int
         """
 
         self._project = project
 
     @property
-    def user(self):
+    def show_empty(self):
         """
-        Unique integer identifying the user registering the algorithm.
+        Whether to show this version on media for which no annotations exist.
 
-        :return: The user of this Algorithm. 
-        :rtype: int
+        :return: The show_empty of this Version. 
+        :rtype: bool
         """
-        return self._user
+        return self._show_empty
 
-    @user.setter
-    def user(self, user):
+    @show_empty.setter
+    def show_empty(self, show_empty):
         """
-        Unique integer identifying the user registering the algorithm.
+        Whether to show this version on media for which no annotations exist.
 
-        :param user: The user of this Algorithm.
-        :type: int
+        :param show_empty: The show_empty of this Version.
+        :type: bool
         """
 
-        self._user = user
+        self._show_empty = show_empty
 
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.openapi_types):
             value = getattr(self, attr)
@@ -333,18 +308,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, Algorithm):
+        if not isinstance(other, Version):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, Algorithm):
+        if not isinstance(other, Version):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/algorithm_manifest.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/algorithm_manifest.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/algorithm_manifest_spec.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/algorithm_manifest_spec.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/algorithm_parameter.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/algorithm_parameter.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/algorithm_spec.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/algorithm_spec.py`

 * *Files 16% similar despite different names*

```diff
@@ -30,57 +30,72 @@
                             and the value is json key in definition.
     """
     openapi_types = {
         'categories': 'list[str]',
         'cluster': 'int',
         'description': 'str',
         'files_per_job': 'int',
+        'headers': 'list[Parameter]',
         'manifest': 'str',
         'name': 'str',
         'parameters': 'list[AlgorithmParameter]',
+        'template': 'int',
+        'tparams': 'list[Parameter]',
         'user': 'int'
     }
 
     attribute_map = {
         'categories': 'categories',
         'cluster': 'cluster',
         'description': 'description',
         'files_per_job': 'files_per_job',
+        'headers': 'headers',
         'manifest': 'manifest',
         'name': 'name',
         'parameters': 'parameters',
+        'template': 'template',
+        'tparams': 'tparams',
         'user': 'user'
     }
 
-    def __init__(self, categories=None, cluster=None, description=None, files_per_job=None, manifest=None, name=None, parameters=None, user=None, local_vars_configuration=None):  # noqa: E501
+    def __init__(self, categories=None, cluster=None, description=None, files_per_job=None, headers=[], manifest=None, name=None, parameters=None, template=None, tparams=[], user=None, local_vars_configuration=None):  # noqa: E501
         """AlgorithmSpec - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration()
         self.local_vars_configuration = local_vars_configuration
 
         self._categories = None
         self._cluster = None
         self._description = None
         self._files_per_job = None
+        self._headers = None
         self._manifest = None
         self._name = None
         self._parameters = None
+        self._template = None
+        self._tparams = None
         self._user = None
         self.discriminator = None
 
         if categories is not None:
             self.categories = categories
         self.cluster = cluster
         if description is not None:
             self.description = description
         self.files_per_job = files_per_job
-        self.manifest = manifest
+        if headers is not None:
+            self.headers = headers
+        if manifest is not None:
+            self.manifest = manifest
         self.name = name
         if parameters is not None:
             self.parameters = parameters
+        self.template = template
+        if tparams is not None:
+            self.tparams = tparams
         self.user = user
 
     @property
     def categories(self):
         """
         List of categories the algorithm workflow belongs to
 
@@ -162,14 +177,35 @@
         """
         if self.local_vars_configuration.client_side_validation and files_per_job is None:  # noqa: E501
             raise ValueError("Invalid value for `files_per_job`, must not be `None`")  # noqa: E501
 
         self._files_per_job = files_per_job
 
     @property
+    def headers(self):
+        """
+        Headers used to retrieve hosted template, if set.
+
+        :return: The headers of this AlgorithmSpec. 
+        :rtype: list[Parameter]
+        """
+        return self._headers
+
+    @headers.setter
+    def headers(self, headers):
+        """
+        Headers used to retrieve hosted template, if set.
+
+        :param headers: The headers of this AlgorithmSpec.
+        :type: list[Parameter]
+        """
+
+        self._headers = headers
+
+    @property
     def manifest(self):
         """
         Server URL to argo manifest file (.yaml)
 
         :return: The manifest of this AlgorithmSpec. 
         :rtype: str
         """
@@ -179,16 +215,14 @@
     def manifest(self, manifest):
         """
         Server URL to argo manifest file (.yaml)
 
         :param manifest: The manifest of this AlgorithmSpec.
         :type: str
         """
-        if self.local_vars_configuration.client_side_validation and manifest is None:  # noqa: E501
-            raise ValueError("Invalid value for `manifest`, must not be `None`")  # noqa: E501
 
         self._manifest = manifest
 
     @property
     def name(self):
         """
         Unique name of the algorithm workflow.
@@ -229,14 +263,56 @@
         :param parameters: The parameters of this AlgorithmSpec.
         :type: list[AlgorithmParameter]
         """
 
         self._parameters = parameters
 
     @property
+    def template(self):
+        """
+        Unique integer identifying a hosted template. If set, `manifest` is ignored.
+
+        :return: The template of this AlgorithmSpec. 
+        :rtype: int
+        """
+        return self._template
+
+    @template.setter
+    def template(self, template):
+        """
+        Unique integer identifying a hosted template. If set, `manifest` is ignored.
+
+        :param template: The template of this AlgorithmSpec.
+        :type: int
+        """
+
+        self._template = template
+
+    @property
+    def tparams(self):
+        """
+        Template parameters used for rendering hosted template, if set.
+
+        :return: The tparams of this AlgorithmSpec. 
+        :rtype: list[Parameter]
+        """
+        return self._tparams
+
+    @tparams.setter
+    def tparams(self, tparams):
+        """
+        Template parameters used for rendering hosted template, if set.
+
+        :param tparams: The tparams of this AlgorithmSpec.
+        :type: list[Parameter]
+        """
+
+        self._tparams = tparams
+
+    @property
     def user(self):
         """
         Unique integer identifying the user registering the algorithm.
 
         :return: The user of this AlgorithmSpec. 
         :rtype: int
         """
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/announcement.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/announcement.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/applet.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/file_spec.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,195 +14,193 @@
 import re  # noqa: F401
 
 import six
 
 from ..configuration import Configuration
 
 
-class Applet(object):
+class FileSpec(object):
     """
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
-        'categories': 'list[str]',
+        'attributes': 'dict(str, object)',
         'description': 'str',
-        'html_file': 'str',
-        'id': 'int',
+        'elemental_id': 'str',
         'name': 'str',
-        'project': 'int'
+        'type': 'int',
+        'user_elemental_id': 'str'
     }
 
     attribute_map = {
-        'categories': 'categories',
+        'attributes': 'attributes',
         'description': 'description',
-        'html_file': 'html_file',
-        'id': 'id',
+        'elemental_id': 'elemental_id',
         'name': 'name',
-        'project': 'project'
+        'type': 'type',
+        'user_elemental_id': 'user_elemental_id'
     }
 
-    def __init__(self, categories=None, description=None, html_file=None, id=None, name=None, project=None, local_vars_configuration=None):  # noqa: E501
-        """Applet - a model defined in OpenAPI"""
+    def __init__(self, attributes=None, description=None, elemental_id=None, name=None, type=None, user_elemental_id=None, local_vars_configuration=None):  # noqa: E501
+        """FileSpec - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration()
         self.local_vars_configuration = local_vars_configuration
 
-        self._categories = None
+        self._attributes = None
         self._description = None
-        self._html_file = None
-        self._id = None
+        self._elemental_id = None
         self._name = None
-        self._project = None
+        self._type = None
+        self._user_elemental_id = None
         self.discriminator = None
 
-        if categories is not None:
-            self.categories = categories
+        if attributes is not None:
+            self.attributes = attributes
         if description is not None:
             self.description = description
-        if html_file is not None:
-            self.html_file = html_file
-        if id is not None:
-            self.id = id
+        self.elemental_id = elemental_id
         if name is not None:
             self.name = name
-        if project is not None:
-            self.project = project
+        if type is not None:
+            self.type = type
+        self.user_elemental_id = user_elemental_id
 
     @property
-    def categories(self):
+    def attributes(self):
         """
-        List of categories the applet belongs to
+        Object containing attribute values
 
-        :return: The categories of this Applet. 
-        :rtype: list[str]
+        :return: The attributes of this FileSpec. 
+        :rtype: dict(str, object)
         """
-        return self._categories
+        return self._attributes
 
-    @categories.setter
-    def categories(self, categories):
+    @attributes.setter
+    def attributes(self, attributes):
         """
-        List of categories the applet belongs to
+        Object containing attribute values
 
-        :param categories: The categories of this Applet.
-        :type: list[str]
+        :param attributes: The attributes of this FileSpec.
+        :type: dict(str, object)
         """
 
-        self._categories = categories
+        self._attributes = attributes
 
     @property
     def description(self):
         """
-        Description of applet
+        Description of file
 
-        :return: The description of this Applet. 
+        :return: The description of this FileSpec. 
         :rtype: str
         """
         return self._description
 
     @description.setter
     def description(self, description):
         """
-        Description of applet
+        Description of file
 
-        :param description: The description of this Applet.
+        :param description: The description of this FileSpec.
         :type: str
         """
 
         self._description = description
 
     @property
-    def html_file(self):
+    def elemental_id(self):
         """
-        Server URL to applet HTML file
+        The elemental ID of the object.
 
-        :return: The html_file of this Applet. 
+        :return: The elemental_id of this FileSpec. 
         :rtype: str
         """
-        return self._html_file
+        return self._elemental_id
 
-    @html_file.setter
-    def html_file(self, html_file):
+    @elemental_id.setter
+    def elemental_id(self, elemental_id):
         """
-        Server URL to applet HTML file
+        The elemental ID of the object.
 
-        :param html_file: The html_file of this Applet.
+        :param elemental_id: The elemental_id of this FileSpec.
         :type: str
         """
 
-        self._html_file = html_file
+        self._elemental_id = elemental_id
 
     @property
-    def id(self):
+    def name(self):
         """
-        Unique integer identifying the applet
+        Name of file
 
-        :return: The id of this Applet. 
-        :rtype: int
+        :return: The name of this FileSpec. 
+        :rtype: str
         """
-        return self._id
+        return self._name
 
-    @id.setter
-    def id(self, id):
+    @name.setter
+    def name(self, name):
         """
-        Unique integer identifying the applet
+        Name of file
 
-        :param id: The id of this Applet.
-        :type: int
+        :param name: The name of this FileSpec.
+        :type: str
         """
 
-        self._id = id
+        self._name = name
 
     @property
-    def name(self):
+    def type(self):
         """
-        Name of applet
+        Unique integer identifying FileType of this File object.
 
-        :return: The name of this Applet. 
-        :rtype: str
+        :return: The type of this FileSpec. 
+        :rtype: int
         """
-        return self._name
+        return self._type
 
-    @name.setter
-    def name(self, name):
+    @type.setter
+    def type(self, type):
         """
-        Name of applet
+        Unique integer identifying FileType of this File object.
 
-        :param name: The name of this Applet.
-        :type: str
+        :param type: The type of this FileSpec.
+        :type: int
         """
 
-        self._name = name
+        self._type = type
 
     @property
-    def project(self):
+    def user_elemental_id(self):
         """
-        Unique integer identifying the project associated with the applet
+        The elemental ID of the object.
 
-        :return: The project of this Applet. 
-        :rtype: int
+        :return: The user_elemental_id of this FileSpec. 
+        :rtype: str
         """
-        return self._project
+        return self._user_elemental_id
 
-    @project.setter
-    def project(self, project):
+    @user_elemental_id.setter
+    def user_elemental_id(self, user_elemental_id):
         """
-        Unique integer identifying the project associated with the applet
+        The elemental ID of the object.
 
-        :param project: The project of this Applet.
-        :type: int
+        :param user_elemental_id: The user_elemental_id of this FileSpec.
+        :type: str
         """
 
-        self._project = project
+        self._user_elemental_id = user_elemental_id
 
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.openapi_types):
             value = getattr(self, attr)
@@ -230,18 +228,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, Applet):
+        if not isinstance(other, FileSpec):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, Applet):
+        if not isinstance(other, FileSpec):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/applet_spec.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/bookmark.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,143 +14,172 @@
 import re  # noqa: F401
 
 import six
 
 from ..configuration import Configuration
 
 
-class AppletSpec(object):
+class Bookmark(object):
     """
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
-        'categories': 'list[str]',
-        'description': 'str',
-        'html_file': 'str',
-        'name': 'str'
+        'id': 'int',
+        'name': 'str',
+        'project': 'int',
+        'uri': 'str',
+        'user': 'int'
     }
 
     attribute_map = {
-        'categories': 'categories',
-        'description': 'description',
-        'html_file': 'html_file',
-        'name': 'name'
+        'id': 'id',
+        'name': 'name',
+        'project': 'project',
+        'uri': 'uri',
+        'user': 'user'
     }
 
-    def __init__(self, categories=None, description=None, html_file=None, name=None, local_vars_configuration=None):  # noqa: E501
-        """AppletSpec - a model defined in OpenAPI"""
+    def __init__(self, id=None, name=None, project=None, uri=None, user=None, local_vars_configuration=None):  # noqa: E501
+        """Bookmark - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration()
         self.local_vars_configuration = local_vars_configuration
 
-        self._categories = None
-        self._description = None
-        self._html_file = None
+        self._id = None
         self._name = None
+        self._project = None
+        self._uri = None
+        self._user = None
         self.discriminator = None
 
-        if categories is not None:
-            self.categories = categories
-        if description is not None:
-            self.description = description
-        if html_file is not None:
-            self.html_file = html_file
+        if id is not None:
+            self.id = id
         if name is not None:
             self.name = name
+        if project is not None:
+            self.project = project
+        if uri is not None:
+            self.uri = uri
+        if user is not None:
+            self.user = user
 
     @property
-    def categories(self):
+    def id(self):
         """
-        List of categories the applet belongs to
+        Unique integer identifying a bookmark.
 
-        :return: The categories of this AppletSpec. 
-        :rtype: list[str]
+        :return: The id of this Bookmark. 
+        :rtype: int
         """
-        return self._categories
+        return self._id
 
-    @categories.setter
-    def categories(self, categories):
+    @id.setter
+    def id(self, id):
         """
-        List of categories the applet belongs to
+        Unique integer identifying a bookmark.
 
-        :param categories: The categories of this AppletSpec.
-        :type: list[str]
+        :param id: The id of this Bookmark.
+        :type: int
         """
 
-        self._categories = categories
+        self._id = id
 
     @property
-    def description(self):
+    def name(self):
         """
-        Description of applet
+        Name of the bookmark.
 
-        :return: The description of this AppletSpec. 
+        :return: The name of this Bookmark. 
         :rtype: str
         """
-        return self._description
+        return self._name
 
-    @description.setter
-    def description(self, description):
+    @name.setter
+    def name(self, name):
         """
-        Description of applet
+        Name of the bookmark.
 
-        :param description: The description of this AppletSpec.
+        :param name: The name of this Bookmark.
         :type: str
         """
 
-        self._description = description
+        self._name = name
 
     @property
-    def html_file(self):
+    def project(self):
         """
-        Server URL to applet HTML file
+        Unique integer identifying a project.
 
-        :return: The html_file of this AppletSpec. 
-        :rtype: str
+        :return: The project of this Bookmark. 
+        :rtype: int
         """
-        return self._html_file
+        return self._project
 
-    @html_file.setter
-    def html_file(self, html_file):
+    @project.setter
+    def project(self, project):
         """
-        Server URL to applet HTML file
+        Unique integer identifying a project.
 
-        :param html_file: The html_file of this AppletSpec.
-        :type: str
+        :param project: The project of this Bookmark.
+        :type: int
         """
 
-        self._html_file = html_file
+        self._project = project
 
     @property
-    def name(self):
+    def uri(self):
         """
-        Name of applet
+        URI to the saved link.
 
-        :return: The name of this AppletSpec. 
+        :return: The uri of this Bookmark. 
         :rtype: str
         """
-        return self._name
+        return self._uri
 
-    @name.setter
-    def name(self, name):
+    @uri.setter
+    def uri(self, uri):
         """
-        Name of applet
+        URI to the saved link.
 
-        :param name: The name of this AppletSpec.
+        :param uri: The uri of this Bookmark.
         :type: str
         """
 
-        self._name = name
+        self._uri = uri
+
+    @property
+    def user(self):
+        """
+        Unique integer identifying a user.
+
+        :return: The user of this Bookmark. 
+        :rtype: int
+        """
+        return self._user
+
+    @user.setter
+    def user(self, user):
+        """
+        Unique integer identifying a user.
+
+        :param user: The user of this Bookmark.
+        :type: int
+        """
+        if (self.local_vars_configuration.client_side_validation and
+                user is not None and user < 1):  # noqa: E501
+            raise ValueError("Invalid value for `user`, must be a value greater than or equal to `1`")  # noqa: E501
+
+        self._user = user
 
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.openapi_types):
             value = getattr(self, attr)
@@ -178,18 +207,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, AppletSpec):
+        if not isinstance(other, Bookmark):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, AppletSpec):
+        if not isinstance(other, Bookmark):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/archive_config.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/archive_config.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/attribute_combinator_spec.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/attribute_combinator_spec.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/attribute_type.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/attribute_type.py`

 * *Files 0% similar despite different names*

```diff
@@ -213,15 +213,15 @@
     def dtype(self, dtype):
         """
         Data type of the attribute.
 
         :param dtype: The dtype of this AttributeType.
         :type: str
         """
-        allowed_values = ["bool", "int", "float", "enum", "string", "datetime", "geopos", "float_array"]  # noqa: E501
+        allowed_values = ["bool", "int", "float", "enum", "string", "datetime", "geopos", "float_array", "blob"]  # noqa: E501
         if self.local_vars_configuration.client_side_validation and dtype not in allowed_values:  # noqa: E501
             raise ValueError(
                 "Invalid value for `dtype` ({0}), must be one of {1}"  # noqa: E501
                 .format(dtype, allowed_values)
             )
 
         self._dtype = dtype
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/attribute_type_delete.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/attribute_type_spec.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,91 +14,95 @@
 import re  # noqa: F401
 
 import six
 
 from ..configuration import Configuration
 
 
-class AttributeTypeDelete(object):
+class AttributeTypeSpec(object):
     """
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
-        'entity_type': 'str',
-        'name': 'str'
+        'addition': 'AttributeType',
+        'entity_type': 'str'
     }
 
     attribute_map = {
-        'entity_type': 'entity_type',
-        'name': 'name'
+        'addition': 'addition',
+        'entity_type': 'entity_type'
     }
 
-    def __init__(self, entity_type=None, name=None, local_vars_configuration=None):  # noqa: E501
-        """AttributeTypeDelete - a model defined in OpenAPI"""
+    def __init__(self, addition=None, entity_type=None, local_vars_configuration=None):  # noqa: E501
+        """AttributeTypeSpec - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration()
         self.local_vars_configuration = local_vars_configuration
 
+        self._addition = None
         self._entity_type = None
-        self._name = None
         self.discriminator = None
 
+        if addition is not None:
+            self.addition = addition
         if entity_type is not None:
             self.entity_type = entity_type
-        if name is not None:
-            self.name = name
 
     @property
-    def entity_type(self):
+    def addition(self):
         """
-        The entity type containing the attribute to rename.
 
-        :return: The entity_type of this AttributeTypeDelete. 
-        :rtype: str
+        :return: The addition of this AttributeTypeSpec. 
+        :rtype: AttributeType
         """
-        return self._entity_type
+        return self._addition
 
-    @entity_type.setter
-    def entity_type(self, entity_type):
+    @addition.setter
+    def addition(self, addition):
         """
-        The entity type containing the attribute to rename.
 
-        :param entity_type: The entity_type of this AttributeTypeDelete.
-        :type: str
+        :param addition: The addition of this AttributeTypeSpec.
+        :type: AttributeType
         """
 
-        self._entity_type = entity_type
+        self._addition = addition
 
     @property
-    def name(self):
+    def entity_type(self):
         """
-        The attribute to delete.
+        The entity type containing the attribute to rename.
 
-        :return: The name of this AttributeTypeDelete. 
+        :return: The entity_type of this AttributeTypeSpec. 
         :rtype: str
         """
-        return self._name
+        return self._entity_type
 
-    @name.setter
-    def name(self, name):
+    @entity_type.setter
+    def entity_type(self, entity_type):
         """
-        The attribute to delete.
+        The entity type containing the attribute to rename.
 
-        :param name: The name of this AttributeTypeDelete.
+        :param entity_type: The entity_type of this AttributeTypeSpec.
         :type: str
         """
+        allowed_values = ["FileType", "MediaType", "LocalizationType", "StateType", "LeafType", "Section"]  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and entity_type not in allowed_values:  # noqa: E501
+            raise ValueError(
+                "Invalid value for `entity_type` ({0}), must be one of {1}"  # noqa: E501
+                .format(entity_type, allowed_values)
+            )
 
-        self._name = name
+        self._entity_type = entity_type
 
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.openapi_types):
             value = getattr(self, attr)
@@ -126,18 +130,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, AttributeTypeDelete):
+        if not isinstance(other, AttributeTypeSpec):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, AttributeTypeDelete):
+        if not isinstance(other, AttributeTypeSpec):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/attribute_type_spec.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/section_bulk_update.py`

 * *Files 23% similar despite different names*

```diff
@@ -14,89 +14,63 @@
 import re  # noqa: F401
 
 import six
 
 from ..configuration import Configuration
 
 
-class AttributeTypeSpec(object):
+class SectionBulkUpdate(object):
     """
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
-        'addition': 'AttributeType',
-        'entity_type': 'str'
+        'path_substitution': 'SectionBulkUpdatePathSubstitution'
     }
 
     attribute_map = {
-        'addition': 'addition',
-        'entity_type': 'entity_type'
+        'path_substitution': 'path_substitution'
     }
 
-    def __init__(self, addition=None, entity_type=None, local_vars_configuration=None):  # noqa: E501
-        """AttributeTypeSpec - a model defined in OpenAPI"""
+    def __init__(self, path_substitution=None, local_vars_configuration=None):  # noqa: E501
+        """SectionBulkUpdate - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration()
         self.local_vars_configuration = local_vars_configuration
 
-        self._addition = None
-        self._entity_type = None
+        self._path_substitution = None
         self.discriminator = None
 
-        if addition is not None:
-            self.addition = addition
-        if entity_type is not None:
-            self.entity_type = entity_type
+        if path_substitution is not None:
+            self.path_substitution = path_substitution
 
     @property
-    def addition(self):
+    def path_substitution(self):
         """
 
-        :return: The addition of this AttributeTypeSpec. 
-        :rtype: AttributeType
+        :return: The path_substitution of this SectionBulkUpdate. 
+        :rtype: SectionBulkUpdatePathSubstitution
         """
-        return self._addition
+        return self._path_substitution
 
-    @addition.setter
-    def addition(self, addition):
+    @path_substitution.setter
+    def path_substitution(self, path_substitution):
         """
 
-        :param addition: The addition of this AttributeTypeSpec.
-        :type: AttributeType
+        :param path_substitution: The path_substitution of this SectionBulkUpdate.
+        :type: SectionBulkUpdatePathSubstitution
         """
 
-        self._addition = addition
-
-    @property
-    def entity_type(self):
-        """
-        The entity type containing the attribute to rename.
-
-        :return: The entity_type of this AttributeTypeSpec. 
-        :rtype: str
-        """
-        return self._entity_type
-
-    @entity_type.setter
-    def entity_type(self, entity_type):
-        """
-        The entity type containing the attribute to rename.
-
-        :param entity_type: The entity_type of this AttributeTypeSpec.
-        :type: str
-        """
-
-        self._entity_type = entity_type
+        self._path_substitution = path_substitution
 
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.openapi_types):
             value = getattr(self, attr)
@@ -124,18 +98,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, AttributeTypeSpec):
+        if not isinstance(other, SectionBulkUpdate):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, AttributeTypeSpec):
+        if not isinstance(other, SectionBulkUpdate):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/attribute_type_update.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/attribute_type_update.py`

 * *Files 16% similar despite different names*

```diff
@@ -116,14 +116,20 @@
         The entity type containing the attribute to rename.
 
         :param entity_type: The entity_type of this AttributeTypeUpdate.
         :type: str
         """
         if self.local_vars_configuration.client_side_validation and entity_type is None:  # noqa: E501
             raise ValueError("Invalid value for `entity_type`, must not be `None`")  # noqa: E501
+        allowed_values = ["FileType", "MediaType", "LocalizationType", "StateType", "LeafType", "Section"]  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and entity_type not in allowed_values:  # noqa: E501
+            raise ValueError(
+                "Invalid value for `entity_type` ({0}), must be one of {1}"  # noqa: E501
+                .format(entity_type, allowed_values)
+            )
 
         self._entity_type = entity_type
 
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/attribute_type_update_attribute_type_update.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/attribute_type_update_attribute_type_update.py`

 * *Files 1% similar despite different names*

```diff
@@ -213,15 +213,15 @@
     def dtype(self, dtype):
         """
         Data type of the attribute.
 
         :param dtype: The dtype of this AttributeTypeUpdateAttributeTypeUpdate.
         :type: str
         """
-        allowed_values = ["bool", "int", "float", "enum", "string", "datetime", "geopos", "float_array"]  # noqa: E501
+        allowed_values = ["bool", "int", "float", "enum", "string", "datetime", "geopos", "float_array", "blob"]  # noqa: E501
         if self.local_vars_configuration.client_side_validation and dtype not in allowed_values:  # noqa: E501
             raise ValueError(
                 "Invalid value for `dtype` ({0}), must be one of {1}"  # noqa: E501
                 .format(dtype, allowed_values)
             )
 
         self._dtype = dtype
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/audio_definition.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/audio_definition.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/autocomplete_service.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/autocomplete_service.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/auxiliary_file_definition.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/auxiliary_file_definition.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/bad_request_response.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/bad_request_response.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/bookmark.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/generic_file.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,172 +14,143 @@
 import re  # noqa: F401
 
 import six
 
 from ..configuration import Configuration
 
 
-class Bookmark(object):
+class GenericFile(object):
     """
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
-        'id': 'int',
         'name': 'str',
         'project': 'int',
-        'uri': 'str',
-        'user': 'int'
+        'upload_url': 'str',
+        'url': 'str'
     }
 
     attribute_map = {
-        'id': 'id',
         'name': 'name',
         'project': 'project',
-        'uri': 'uri',
-        'user': 'user'
+        'upload_url': 'upload_url',
+        'url': 'url'
     }
 
-    def __init__(self, id=None, name=None, project=None, uri=None, user=None, local_vars_configuration=None):  # noqa: E501
-        """Bookmark - a model defined in OpenAPI"""
+    def __init__(self, name=None, project=None, upload_url=None, url=None, local_vars_configuration=None):  # noqa: E501
+        """GenericFile - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration()
         self.local_vars_configuration = local_vars_configuration
 
-        self._id = None
         self._name = None
         self._project = None
-        self._uri = None
-        self._user = None
+        self._upload_url = None
+        self._url = None
         self.discriminator = None
 
-        if id is not None:
-            self.id = id
         if name is not None:
             self.name = name
         if project is not None:
             self.project = project
-        if uri is not None:
-            self.uri = uri
-        if user is not None:
-            self.user = user
-
-    @property
-    def id(self):
-        """
-        Unique integer identifying a bookmark.
-
-        :return: The id of this Bookmark. 
-        :rtype: int
-        """
-        return self._id
-
-    @id.setter
-    def id(self, id):
-        """
-        Unique integer identifying a bookmark.
-
-        :param id: The id of this Bookmark.
-        :type: int
-        """
-
-        self._id = id
+        if upload_url is not None:
+            self.upload_url = upload_url
+        if url is not None:
+            self.url = url
 
     @property
     def name(self):
         """
-        Name of the bookmark.
+        Name of generic, non-media file
 
-        :return: The name of this Bookmark. 
+        :return: The name of this GenericFile. 
         :rtype: str
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """
-        Name of the bookmark.
+        Name of generic, non-media file
 
-        :param name: The name of this Bookmark.
+        :param name: The name of this GenericFile.
         :type: str
         """
 
         self._name = name
 
     @property
     def project(self):
         """
-        Unique integer identifying a project.
+        Unique integer identifying project to store the file in
 
-        :return: The project of this Bookmark. 
+        :return: The project of this GenericFile. 
         :rtype: int
         """
         return self._project
 
     @project.setter
     def project(self, project):
         """
-        Unique integer identifying a project.
+        Unique integer identifying project to store the file in
 
-        :param project: The project of this Bookmark.
+        :param project: The project of this GenericFile.
         :type: int
         """
 
         self._project = project
 
     @property
-    def uri(self):
+    def upload_url(self):
         """
-        URI to the saved link.
+        URL of the uploaded file
 
-        :return: The uri of this Bookmark. 
+        :return: The upload_url of this GenericFile. 
         :rtype: str
         """
-        return self._uri
+        return self._upload_url
 
-    @uri.setter
-    def uri(self, uri):
+    @upload_url.setter
+    def upload_url(self, upload_url):
         """
-        URI to the saved link.
+        URL of the uploaded file
 
-        :param uri: The uri of this Bookmark.
+        :param upload_url: The upload_url of this GenericFile.
         :type: str
         """
 
-        self._uri = uri
+        self._upload_url = upload_url
 
     @property
-    def user(self):
+    def url(self):
         """
-        Unique integer identifying a user.
+        Name of generic, non-media file
 
-        :return: The user of this Bookmark. 
-        :rtype: int
+        :return: The url of this GenericFile. 
+        :rtype: str
         """
-        return self._user
+        return self._url
 
-    @user.setter
-    def user(self, user):
+    @url.setter
+    def url(self, url):
         """
-        Unique integer identifying a user.
+        Name of generic, non-media file
 
-        :param user: The user of this Bookmark.
-        :type: int
+        :param url: The url of this GenericFile.
+        :type: str
         """
-        if (self.local_vars_configuration.client_side_validation and
-                user is not None and user < 1):  # noqa: E501
-            raise ValueError("Invalid value for `user`, must be a value greater than or equal to `1`")  # noqa: E501
 
-        self._user = user
+        self._url = url
 
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.openapi_types):
             value = getattr(self, attr)
@@ -207,18 +178,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, Bookmark):
+        if not isinstance(other, GenericFile):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, Bookmark):
+        if not isinstance(other, GenericFile):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/bookmark_spec.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/bookmark_spec.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/bookmark_update.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/bookmark_update.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/bucket.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/bucket.py`

 * *Files 0% similar despite different names*

```diff
@@ -257,15 +257,15 @@
     def store_type(self, store_type):
         """
         Type of object store on which the bucket is hosted.
 
         :param store_type: The store_type of this Bucket.
         :type: str
         """
-        allowed_values = ["AWS", "MINIO", "GCP", "OCI"]  # noqa: E501
+        allowed_values = ["AWS", "MINIO", "GCP", "OCI", "VAST"]  # noqa: E501
         if self.local_vars_configuration.client_side_validation and store_type not in allowed_values:  # noqa: E501
             raise ValueError(
                 "Invalid value for `store_type` ({0}), must be one of {1}"  # noqa: E501
                 .format(store_type, allowed_values)
             )
 
         self._store_type = store_type
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/bucket_gcp_config.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/bucket_gcp_config.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/bucket_oci_config.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/bucket_oci_config.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/bucket_oci_native_config.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/bucket_oci_native_config.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/bucket_s3_config.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/bucket_s3_config.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/bucket_spec.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/bucket_spec.py`

 * *Files 1% similar despite different names*

```diff
@@ -208,15 +208,15 @@
         Type of object store on which the bucket is hosted.
 
         :param store_type: The store_type of this BucketSpec.
         :type: str
         """
         if self.local_vars_configuration.client_side_validation and store_type is None:  # noqa: E501
             raise ValueError("Invalid value for `store_type`, must not be `None`")  # noqa: E501
-        allowed_values = ["AWS", "MINIO", "GCP", "OCI"]  # noqa: E501
+        allowed_values = ["AWS", "MINIO", "GCP", "OCI", "VAST"]  # noqa: E501
         if self.local_vars_configuration.client_side_validation and store_type not in allowed_values:  # noqa: E501
             raise ValueError(
                 "Invalid value for `store_type` ({0}), must be one of {1}"  # noqa: E501
                 .format(store_type, allowed_values)
             )
 
         self._store_type = store_type
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/bucket_update.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/bucket_update.py`

 * *Files 1% similar despite different names*

```diff
@@ -205,15 +205,15 @@
     def store_type(self, store_type):
         """
         Type of object store on which the bucket is hosted.
 
         :param store_type: The store_type of this BucketUpdate.
         :type: str
         """
-        allowed_values = ["AWS", "MINIO", "GCP", "OCI"]  # noqa: E501
+        allowed_values = ["AWS", "MINIO", "GCP", "OCI", "VAST"]  # noqa: E501
         if self.local_vars_configuration.client_side_validation and store_type not in allowed_values:  # noqa: E501
             raise ValueError(
                 "Invalid value for `store_type` ({0}), must be one of {1}"  # noqa: E501
                 .format(store_type, allowed_values)
             )
 
         self._store_type = store_type
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/change_log.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/change_log.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/change_log_description_of_change.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/change_log_description_of_change.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/change_log_description_of_change_new.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/change_log_description_of_change_new.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/clone_media_spec.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/clone_media_spec.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/color_map.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/color_map.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/concat_definition.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/concat_definition.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/create_list_response.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/create_list_response.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/create_response.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/create_response.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/credentials.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/credentials.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/download_info.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/download_info.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/download_info_spec.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/download_info_spec.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/email_attachment_spec.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/email_attachment_spec.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/email_spec.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/email_spec.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/encode_config.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/encode_config.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/favorite.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/favorite.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/favorite_spec.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/favorite_spec.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/favorite_update.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/favorite_update.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/feed_definition.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/feed_definition.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/file.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/file.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/file_spec.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/file_type.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,193 +14,194 @@
 import re  # noqa: F401
 
 import six
 
 from ..configuration import Configuration
 
 
-class FileSpec(object):
+class FileType(object):
     """
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
-        'attributes': 'dict(str, object)',
+        'attribute_types': 'list[AttributeType]',
         'description': 'str',
         'elemental_id': 'str',
+        'id': 'int',
         'name': 'str',
-        'type': 'int',
-        'user_elemental_id': 'str'
+        'project': 'int'
     }
 
     attribute_map = {
-        'attributes': 'attributes',
+        'attribute_types': 'attribute_types',
         'description': 'description',
         'elemental_id': 'elemental_id',
+        'id': 'id',
         'name': 'name',
-        'type': 'type',
-        'user_elemental_id': 'user_elemental_id'
+        'project': 'project'
     }
 
-    def __init__(self, attributes=None, description=None, elemental_id=None, name=None, type=None, user_elemental_id=None, local_vars_configuration=None):  # noqa: E501
-        """FileSpec - a model defined in OpenAPI"""
+    def __init__(self, attribute_types=None, description='', elemental_id=None, id=None, name=None, project=None, local_vars_configuration=None):  # noqa: E501
+        """FileType - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration()
         self.local_vars_configuration = local_vars_configuration
 
-        self._attributes = None
+        self._attribute_types = None
         self._description = None
         self._elemental_id = None
+        self._id = None
         self._name = None
-        self._type = None
-        self._user_elemental_id = None
+        self._project = None
         self.discriminator = None
 
-        if attributes is not None:
-            self.attributes = attributes
+        if attribute_types is not None:
+            self.attribute_types = attribute_types
         if description is not None:
             self.description = description
         self.elemental_id = elemental_id
+        if id is not None:
+            self.id = id
         if name is not None:
             self.name = name
-        if type is not None:
-            self.type = type
-        self.user_elemental_id = user_elemental_id
+        if project is not None:
+            self.project = project
 
     @property
-    def attributes(self):
+    def attribute_types(self):
         """
-        Object containing attribute values
+        Attribute type definitions.
 
-        :return: The attributes of this FileSpec. 
-        :rtype: dict(str, object)
+        :return: The attribute_types of this FileType. 
+        :rtype: list[AttributeType]
         """
-        return self._attributes
+        return self._attribute_types
 
-    @attributes.setter
-    def attributes(self, attributes):
+    @attribute_types.setter
+    def attribute_types(self, attribute_types):
         """
-        Object containing attribute values
+        Attribute type definitions.
 
-        :param attributes: The attributes of this FileSpec.
-        :type: dict(str, object)
+        :param attribute_types: The attribute_types of this FileType.
+        :type: list[AttributeType]
         """
 
-        self._attributes = attributes
+        self._attribute_types = attribute_types
 
     @property
     def description(self):
         """
-        Description of file
+        Description of the file type.
 
-        :return: The description of this FileSpec. 
+        :return: The description of this FileType. 
         :rtype: str
         """
         return self._description
 
     @description.setter
     def description(self, description):
         """
-        Description of file
+        Description of the file type.
 
-        :param description: The description of this FileSpec.
+        :param description: The description of this FileType.
         :type: str
         """
 
         self._description = description
 
     @property
     def elemental_id(self):
         """
         The elemental ID of the object.
 
-        :return: The elemental_id of this FileSpec. 
+        :return: The elemental_id of this FileType. 
         :rtype: str
         """
         return self._elemental_id
 
     @elemental_id.setter
     def elemental_id(self, elemental_id):
         """
         The elemental ID of the object.
 
-        :param elemental_id: The elemental_id of this FileSpec.
+        :param elemental_id: The elemental_id of this FileType.
         :type: str
         """
 
         self._elemental_id = elemental_id
 
     @property
-    def name(self):
+    def id(self):
         """
-        Name of file
+        Unique integer identifying a file type.
 
-        :return: The name of this FileSpec. 
-        :rtype: str
+        :return: The id of this FileType. 
+        :rtype: int
         """
-        return self._name
+        return self._id
 
-    @name.setter
-    def name(self, name):
+    @id.setter
+    def id(self, id):
         """
-        Name of file
+        Unique integer identifying a file type.
 
-        :param name: The name of this FileSpec.
-        :type: str
+        :param id: The id of this FileType.
+        :type: int
         """
 
-        self._name = name
+        self._id = id
 
     @property
-    def type(self):
+    def name(self):
         """
-        Unique integer identifying FileType of this File object.
+        Name of the file type.
 
-        :return: The type of this FileSpec. 
-        :rtype: int
+        :return: The name of this FileType. 
+        :rtype: str
         """
-        return self._type
+        return self._name
 
-    @type.setter
-    def type(self, type):
+    @name.setter
+    def name(self, name):
         """
-        Unique integer identifying FileType of this File object.
+        Name of the file type.
 
-        :param type: The type of this FileSpec.
-        :type: int
+        :param name: The name of this FileType.
+        :type: str
         """
 
-        self._type = type
+        self._name = name
 
     @property
-    def user_elemental_id(self):
+    def project(self):
         """
-        The elemental ID of the object.
+        Unique integer identifying project for this file type.
 
-        :return: The user_elemental_id of this FileSpec. 
-        :rtype: str
+        :return: The project of this FileType. 
+        :rtype: int
         """
-        return self._user_elemental_id
+        return self._project
 
-    @user_elemental_id.setter
-    def user_elemental_id(self, user_elemental_id):
+    @project.setter
+    def project(self, project):
         """
-        The elemental ID of the object.
+        Unique integer identifying project for this file type.
 
-        :param user_elemental_id: The user_elemental_id of this FileSpec.
-        :type: str
+        :param project: The project of this FileType.
+        :type: int
         """
 
-        self._user_elemental_id = user_elemental_id
+        self._project = project
 
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.openapi_types):
             value = getattr(self, attr)
@@ -228,18 +229,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, FileSpec):
+        if not isinstance(other, FileType):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, FileSpec):
+        if not isinstance(other, FileType):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/file_type.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/leaf_type.py`

 * *Files 10% similar despite different names*

```diff
@@ -14,190 +14,216 @@
 import re  # noqa: F401
 
 import six
 
 from ..configuration import Configuration
 
 
-class FileType(object):
+class LeafType(object):
     """
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
         'attribute_types': 'list[AttributeType]',
         'description': 'str',
+        'dtype': 'str',
         'elemental_id': 'str',
         'id': 'int',
         'name': 'str',
         'project': 'int'
     }
 
     attribute_map = {
         'attribute_types': 'attribute_types',
         'description': 'description',
+        'dtype': 'dtype',
         'elemental_id': 'elemental_id',
         'id': 'id',
         'name': 'name',
         'project': 'project'
     }
 
-    def __init__(self, attribute_types=None, description='', elemental_id=None, id=None, name=None, project=None, local_vars_configuration=None):  # noqa: E501
-        """FileType - a model defined in OpenAPI"""
+    def __init__(self, attribute_types=None, description='', dtype=None, elemental_id=None, id=None, name=None, project=None, local_vars_configuration=None):  # noqa: E501
+        """LeafType - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration()
         self.local_vars_configuration = local_vars_configuration
 
         self._attribute_types = None
         self._description = None
+        self._dtype = None
         self._elemental_id = None
         self._id = None
         self._name = None
         self._project = None
         self.discriminator = None
 
         if attribute_types is not None:
             self.attribute_types = attribute_types
         if description is not None:
             self.description = description
+        if dtype is not None:
+            self.dtype = dtype
         self.elemental_id = elemental_id
         if id is not None:
             self.id = id
         if name is not None:
             self.name = name
         if project is not None:
             self.project = project
 
     @property
     def attribute_types(self):
         """
         Attribute type definitions.
 
-        :return: The attribute_types of this FileType. 
+        :return: The attribute_types of this LeafType. 
         :rtype: list[AttributeType]
         """
         return self._attribute_types
 
     @attribute_types.setter
     def attribute_types(self, attribute_types):
         """
         Attribute type definitions.
 
-        :param attribute_types: The attribute_types of this FileType.
+        :param attribute_types: The attribute_types of this LeafType.
         :type: list[AttributeType]
         """
 
         self._attribute_types = attribute_types
 
     @property
     def description(self):
         """
-        Description of the file type.
+        Description of the leaf type.
 
-        :return: The description of this FileType. 
+        :return: The description of this LeafType. 
         :rtype: str
         """
         return self._description
 
     @description.setter
     def description(self, description):
         """
-        Description of the file type.
+        Description of the leaf type.
 
-        :param description: The description of this FileType.
+        :param description: The description of this LeafType.
         :type: str
         """
 
         self._description = description
 
     @property
+    def dtype(self):
+        """
+        Name of this data type, value is always \"leaf\".
+
+        :return: The dtype of this LeafType. 
+        :rtype: str
+        """
+        return self._dtype
+
+    @dtype.setter
+    def dtype(self, dtype):
+        """
+        Name of this data type, value is always \"leaf\".
+
+        :param dtype: The dtype of this LeafType.
+        :type: str
+        """
+
+        self._dtype = dtype
+
+    @property
     def elemental_id(self):
         """
         The elemental ID of the object.
 
-        :return: The elemental_id of this FileType. 
+        :return: The elemental_id of this LeafType. 
         :rtype: str
         """
         return self._elemental_id
 
     @elemental_id.setter
     def elemental_id(self, elemental_id):
         """
         The elemental ID of the object.
 
-        :param elemental_id: The elemental_id of this FileType.
+        :param elemental_id: The elemental_id of this LeafType.
         :type: str
         """
 
         self._elemental_id = elemental_id
 
     @property
     def id(self):
         """
-        Unique integer identifying a file type.
+        Unique integer identifying a leaf type.
 
-        :return: The id of this FileType. 
+        :return: The id of this LeafType. 
         :rtype: int
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """
-        Unique integer identifying a file type.
+        Unique integer identifying a leaf type.
 
-        :param id: The id of this FileType.
+        :param id: The id of this LeafType.
         :type: int
         """
 
         self._id = id
 
     @property
     def name(self):
         """
-        Name of the file type.
+        Name of the leaf type.
 
-        :return: The name of this FileType. 
+        :return: The name of this LeafType. 
         :rtype: str
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """
-        Name of the file type.
+        Name of the leaf type.
 
-        :param name: The name of this FileType.
+        :param name: The name of this LeafType.
         :type: str
         """
 
         self._name = name
 
     @property
     def project(self):
         """
-        Unique integer identifying project for this file type.
+        Unique integer identifying project for this leaf type.
 
-        :return: The project of this FileType. 
+        :return: The project of this LeafType. 
         :rtype: int
         """
         return self._project
 
     @project.setter
     def project(self, project):
         """
-        Unique integer identifying project for this file type.
+        Unique integer identifying project for this leaf type.
 
-        :param project: The project of this FileType.
+        :param project: The project of this LeafType.
         :type: int
         """
 
         self._project = project
 
     def to_dict(self):
         """Returns the model properties as a dict"""
@@ -229,18 +255,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, FileType):
+        if not isinstance(other, LeafType):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, FileType):
+        if not isinstance(other, LeafType):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/file_type_spec.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/file_type_spec.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/file_type_update.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/file_type_update.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/file_update.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/file_update.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/fill.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/fill.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/float_array_query.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/float_array_query.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/generic_file.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/leaf_spec.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,143 +14,144 @@
 import re  # noqa: F401
 
 import six
 
 from ..configuration import Configuration
 
 
-class GenericFile(object):
+class LeafSpec(object):
     """
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
+        'attributes': 'dict(str, object)',
         'name': 'str',
-        'project': 'int',
-        'upload_url': 'str',
-        'url': 'str'
+        'parent': 'int',
+        'type': 'int'
     }
 
     attribute_map = {
+        'attributes': 'attributes',
         'name': 'name',
-        'project': 'project',
-        'upload_url': 'upload_url',
-        'url': 'url'
+        'parent': 'parent',
+        'type': 'type'
     }
 
-    def __init__(self, name=None, project=None, upload_url=None, url=None, local_vars_configuration=None):  # noqa: E501
-        """GenericFile - a model defined in OpenAPI"""
+    def __init__(self, attributes=None, name=None, parent=None, type=None, local_vars_configuration=None):  # noqa: E501
+        """LeafSpec - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration()
         self.local_vars_configuration = local_vars_configuration
 
+        self._attributes = None
         self._name = None
-        self._project = None
-        self._upload_url = None
-        self._url = None
+        self._parent = None
+        self._type = None
         self.discriminator = None
 
-        if name is not None:
-            self.name = name
-        if project is not None:
-            self.project = project
-        if upload_url is not None:
-            self.upload_url = upload_url
-        if url is not None:
-            self.url = url
+        if attributes is not None:
+            self.attributes = attributes
+        self.name = name
+        self.parent = parent
+        self.type = type
 
     @property
-    def name(self):
+    def attributes(self):
         """
-        Name of generic, non-media file
+        Object containing attribute values.
 
-        :return: The name of this GenericFile. 
-        :rtype: str
+        :return: The attributes of this LeafSpec. 
+        :rtype: dict(str, object)
         """
-        return self._name
+        return self._attributes
 
-    @name.setter
-    def name(self, name):
+    @attributes.setter
+    def attributes(self, attributes):
         """
-        Name of generic, non-media file
+        Object containing attribute values.
 
-        :param name: The name of this GenericFile.
-        :type: str
+        :param attributes: The attributes of this LeafSpec.
+        :type: dict(str, object)
         """
 
-        self._name = name
+        self._attributes = attributes
 
     @property
-    def project(self):
+    def name(self):
         """
-        Unique integer identifying project to store the file in
+        Name of the leaf.
 
-        :return: The project of this GenericFile. 
-        :rtype: int
+        :return: The name of this LeafSpec. 
+        :rtype: str
         """
-        return self._project
+        return self._name
 
-    @project.setter
-    def project(self, project):
+    @name.setter
+    def name(self, name):
         """
-        Unique integer identifying project to store the file in
+        Name of the leaf.
 
-        :param project: The project of this GenericFile.
-        :type: int
+        :param name: The name of this LeafSpec.
+        :type: str
         """
+        if self.local_vars_configuration.client_side_validation and name is None:  # noqa: E501
+            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501
 
-        self._project = project
+        self._name = name
 
     @property
-    def upload_url(self):
+    def parent(self):
         """
-        URL of the uploaded file
+        ID to use as parent if there is one.
 
-        :return: The upload_url of this GenericFile. 
-        :rtype: str
+        :return: The parent of this LeafSpec. 
+        :rtype: int
         """
-        return self._upload_url
+        return self._parent
 
-    @upload_url.setter
-    def upload_url(self, upload_url):
+    @parent.setter
+    def parent(self, parent):
         """
-        URL of the uploaded file
+        ID to use as parent if there is one.
 
-        :param upload_url: The upload_url of this GenericFile.
-        :type: str
+        :param parent: The parent of this LeafSpec.
+        :type: int
         """
 
-        self._upload_url = upload_url
+        self._parent = parent
 
     @property
-    def url(self):
+    def type(self):
         """
-        Name of generic, non-media file
+        Unique integer identifying a leaf type.
 
-        :return: The url of this GenericFile. 
-        :rtype: str
+        :return: The type of this LeafSpec. 
+        :rtype: int
         """
-        return self._url
+        return self._type
 
-    @url.setter
-    def url(self, url):
+    @type.setter
+    def type(self, type):
         """
-        Name of generic, non-media file
+        Unique integer identifying a leaf type.
 
-        :param url: The url of this GenericFile.
-        :type: str
+        :param type: The type of this LeafSpec.
+        :type: int
         """
+        if self.local_vars_configuration.client_side_validation and type is None:  # noqa: E501
+            raise ValueError("Invalid value for `type`, must not be `None`")  # noqa: E501
 
-        self._url = url
+        self._type = type
 
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.openapi_types):
             value = getattr(self, attr)
@@ -178,18 +179,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, GenericFile):
+        if not isinstance(other, LeafSpec):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, GenericFile):
+        if not isinstance(other, LeafSpec):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/generic_file_spec.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/generic_file_spec.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/get_cloned_media_response.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/get_cloned_media_response.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/image_definition.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/image_definition.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/invitation.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/invitation.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/invitation_spec.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/invitation_spec.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/invitation_update.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/invitation_update.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/job.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/job.py`

 * *Files 4% similar despite different names*

```diff
@@ -28,56 +28,61 @@
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
         'gid': 'str',
         'id': 'str',
+        'media_ids': 'list[int]',
         'nodes': 'list[JobNode]',
         'project': 'int',
         'start_time': 'datetime',
         'status': 'str',
         'stop_time': 'datetime',
         'uid': 'str',
         'user': 'int'
     }
 
     attribute_map = {
         'gid': 'gid',
         'id': 'id',
+        'media_ids': 'media_ids',
         'nodes': 'nodes',
         'project': 'project',
         'start_time': 'start_time',
         'status': 'status',
         'stop_time': 'stop_time',
         'uid': 'uid',
         'user': 'user'
     }
 
-    def __init__(self, gid=None, id=None, nodes=None, project=None, start_time=None, status=None, stop_time=None, uid=None, user=None, local_vars_configuration=None):  # noqa: E501
+    def __init__(self, gid=None, id=None, media_ids=None, nodes=None, project=None, start_time=None, status=None, stop_time=None, uid=None, user=None, local_vars_configuration=None):  # noqa: E501
         """Job - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration()
         self.local_vars_configuration = local_vars_configuration
 
         self._gid = None
         self._id = None
+        self._media_ids = None
         self._nodes = None
         self._project = None
         self._start_time = None
         self._status = None
         self._stop_time = None
         self._uid = None
         self._user = None
         self.discriminator = None
 
         if gid is not None:
             self.gid = gid
         if id is not None:
             self.id = id
+        if media_ids is not None:
+            self.media_ids = media_ids
         if nodes is not None:
             self.nodes = nodes
         if project is not None:
             self.project = project
         self.start_time = start_time
         if status is not None:
             self.status = status
@@ -126,14 +131,33 @@
         :param id: The id of this Job.
         :type: str
         """
 
         self._id = id
 
     @property
+    def media_ids(self):
+        """
+
+        :return: The media_ids of this Job. 
+        :rtype: list[int]
+        """
+        return self._media_ids
+
+    @media_ids.setter
+    def media_ids(self, media_ids):
+        """
+
+        :param media_ids: The media_ids of this Job.
+        :type: list[int]
+        """
+
+        self._media_ids = media_ids
+
+    @property
     def nodes(self):
         """
 
         :return: The nodes of this Job. 
         :rtype: list[JobNode]
         """
         return self._nodes
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/job_cluster.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/job_cluster.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/job_cluster_spec.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/job_cluster_spec.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/job_node.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/job_node.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/job_spec.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/job_spec.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/job_spec_failure_email_spec.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/job_spec_failure_email_spec.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/leaf.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/leaf.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/leaf_bulk_update.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/leaf_bulk_update.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/leaf_id_query.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/leaf_id_query.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/leaf_spec.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/upload_info.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,144 +14,117 @@
 import re  # noqa: F401
 
 import six
 
 from ..configuration import Configuration
 
 
-class LeafSpec(object):
+class UploadInfo(object):
     """
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
-        'attributes': 'dict(str, object)',
-        'name': 'str',
-        'parent': 'int',
-        'type': 'int'
+        'key': 'str',
+        'upload_id': 'str',
+        'urls': 'list[str]'
     }
 
     attribute_map = {
-        'attributes': 'attributes',
-        'name': 'name',
-        'parent': 'parent',
-        'type': 'type'
+        'key': 'key',
+        'upload_id': 'upload_id',
+        'urls': 'urls'
     }
 
-    def __init__(self, attributes=None, name=None, parent=None, type=None, local_vars_configuration=None):  # noqa: E501
-        """LeafSpec - a model defined in OpenAPI"""
+    def __init__(self, key=None, upload_id=None, urls=None, local_vars_configuration=None):  # noqa: E501
+        """UploadInfo - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration()
         self.local_vars_configuration = local_vars_configuration
 
-        self._attributes = None
-        self._name = None
-        self._parent = None
-        self._type = None
+        self._key = None
+        self._upload_id = None
+        self._urls = None
         self.discriminator = None
 
-        if attributes is not None:
-            self.attributes = attributes
-        self.name = name
-        self.parent = parent
-        self.type = type
+        if key is not None:
+            self.key = key
+        if upload_id is not None:
+            self.upload_id = upload_id
+        if urls is not None:
+            self.urls = urls
 
     @property
-    def attributes(self):
+    def key(self):
         """
-        Object containing attribute values.
+        An object key that can be supplied to the `Transcode` or `Media` or `File` endpoint after the file has been uploaded.
 
-        :return: The attributes of this LeafSpec. 
-        :rtype: dict(str, object)
-        """
-        return self._attributes
-
-    @attributes.setter
-    def attributes(self, attributes):
-        """
-        Object containing attribute values.
-
-        :param attributes: The attributes of this LeafSpec.
-        :type: dict(str, object)
-        """
-
-        self._attributes = attributes
-
-    @property
-    def name(self):
-        """
-        Name of the leaf.
-
-        :return: The name of this LeafSpec. 
+        :return: The key of this UploadInfo. 
         :rtype: str
         """
-        return self._name
+        return self._key
 
-    @name.setter
-    def name(self, name):
+    @key.setter
+    def key(self, key):
         """
-        Name of the leaf.
+        An object key that can be supplied to the `Transcode` or `Media` or `File` endpoint after the file has been uploaded.
 
-        :param name: The name of this LeafSpec.
+        :param key: The key of this UploadInfo.
         :type: str
         """
-        if self.local_vars_configuration.client_side_validation and name is None:  # noqa: E501
-            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501
 
-        self._name = name
+        self._key = key
 
     @property
-    def parent(self):
+    def upload_id(self):
         """
-        ID to use as parent if there is one.
+        An upload ID that can be supplied to the `UploadCompletion` endpoint after the file has been uploaded. Only contains a value if `num_parts` > 1.
 
-        :return: The parent of this LeafSpec. 
-        :rtype: int
+        :return: The upload_id of this UploadInfo. 
+        :rtype: str
         """
-        return self._parent
+        return self._upload_id
 
-    @parent.setter
-    def parent(self, parent):
+    @upload_id.setter
+    def upload_id(self, upload_id):
         """
-        ID to use as parent if there is one.
+        An upload ID that can be supplied to the `UploadCompletion` endpoint after the file has been uploaded. Only contains a value if `num_parts` > 1.
 
-        :param parent: The parent of this LeafSpec.
-        :type: int
+        :param upload_id: The upload_id of this UploadInfo.
+        :type: str
         """
 
-        self._parent = parent
+        self._upload_id = upload_id
 
     @property
-    def type(self):
+    def urls(self):
         """
-        Unique integer identifying a leaf type.
+        One or more URLs for upload via one PUT request per URL.
 
-        :return: The type of this LeafSpec. 
-        :rtype: int
+        :return: The urls of this UploadInfo. 
+        :rtype: list[str]
         """
-        return self._type
+        return self._urls
 
-    @type.setter
-    def type(self, type):
+    @urls.setter
+    def urls(self, urls):
         """
-        Unique integer identifying a leaf type.
+        One or more URLs for upload via one PUT request per URL.
 
-        :param type: The type of this LeafSpec.
-        :type: int
+        :param urls: The urls of this UploadInfo.
+        :type: list[str]
         """
-        if self.local_vars_configuration.client_side_validation and type is None:  # noqa: E501
-            raise ValueError("Invalid value for `type`, must not be `None`")  # noqa: E501
 
-        self._type = type
+        self._urls = urls
 
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.openapi_types):
             value = getattr(self, attr)
@@ -179,18 +152,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, LeafSpec):
+        if not isinstance(other, UploadInfo):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, LeafSpec):
+        if not isinstance(other, UploadInfo):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/leaf_suggestion.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/leaf_suggestion.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/leaf_type.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/state_type_update.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,220 +14,194 @@
 import re  # noqa: F401
 
 import six
 
 from ..configuration import Configuration
 
 
-class LeafType(object):
+class StateTypeUpdate(object):
     """
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
-        'attribute_types': 'list[AttributeType]',
+        'delete_child_localizations': 'bool',
         'description': 'str',
-        'dtype': 'str',
         'elemental_id': 'str',
-        'id': 'int',
+        'grouping_default': 'bool',
         'name': 'str',
-        'project': 'int'
+        'visible': 'bool'
     }
 
     attribute_map = {
-        'attribute_types': 'attribute_types',
+        'delete_child_localizations': 'delete_child_localizations',
         'description': 'description',
-        'dtype': 'dtype',
         'elemental_id': 'elemental_id',
-        'id': 'id',
+        'grouping_default': 'grouping_default',
         'name': 'name',
-        'project': 'project'
+        'visible': 'visible'
     }
 
-    def __init__(self, attribute_types=None, description='', dtype=None, elemental_id=None, id=None, name=None, project=None, local_vars_configuration=None):  # noqa: E501
-        """LeafType - a model defined in OpenAPI"""
+    def __init__(self, delete_child_localizations=None, description=None, elemental_id=None, grouping_default=None, name=None, visible=None, local_vars_configuration=None):  # noqa: E501
+        """StateTypeUpdate - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration()
         self.local_vars_configuration = local_vars_configuration
 
-        self._attribute_types = None
+        self._delete_child_localizations = None
         self._description = None
-        self._dtype = None
         self._elemental_id = None
-        self._id = None
+        self._grouping_default = None
         self._name = None
-        self._project = None
+        self._visible = None
         self.discriminator = None
 
-        if attribute_types is not None:
-            self.attribute_types = attribute_types
+        if delete_child_localizations is not None:
+            self.delete_child_localizations = delete_child_localizations
         if description is not None:
             self.description = description
-        if dtype is not None:
-            self.dtype = dtype
         self.elemental_id = elemental_id
-        if id is not None:
-            self.id = id
+        if grouping_default is not None:
+            self.grouping_default = grouping_default
         if name is not None:
             self.name = name
-        if project is not None:
-            self.project = project
+        if visible is not None:
+            self.visible = visible
 
     @property
-    def attribute_types(self):
+    def delete_child_localizations(self):
         """
-        Attribute type definitions.
+        True if child localizations should be deleted when this state is deleted. Localizations will only be deleted if they are not associated with another state. 
 
-        :return: The attribute_types of this LeafType. 
-        :rtype: list[AttributeType]
+        :return: The delete_child_localizations of this StateTypeUpdate. 
+        :rtype: bool
         """
-        return self._attribute_types
+        return self._delete_child_localizations
 
-    @attribute_types.setter
-    def attribute_types(self, attribute_types):
+    @delete_child_localizations.setter
+    def delete_child_localizations(self, delete_child_localizations):
         """
-        Attribute type definitions.
+        True if child localizations should be deleted when this state is deleted. Localizations will only be deleted if they are not associated with another state. 
 
-        :param attribute_types: The attribute_types of this LeafType.
-        :type: list[AttributeType]
+        :param delete_child_localizations: The delete_child_localizations of this StateTypeUpdate.
+        :type: bool
         """
 
-        self._attribute_types = attribute_types
+        self._delete_child_localizations = delete_child_localizations
 
     @property
     def description(self):
         """
-        Description of the leaf type.
+        Description of the state type.
 
-        :return: The description of this LeafType. 
+        :return: The description of this StateTypeUpdate. 
         :rtype: str
         """
         return self._description
 
     @description.setter
     def description(self, description):
         """
-        Description of the leaf type.
+        Description of the state type.
 
-        :param description: The description of this LeafType.
+        :param description: The description of this StateTypeUpdate.
         :type: str
         """
 
         self._description = description
 
     @property
-    def dtype(self):
-        """
-        Name of this data type, value is always \"leaf\".
-
-        :return: The dtype of this LeafType. 
-        :rtype: str
-        """
-        return self._dtype
-
-    @dtype.setter
-    def dtype(self, dtype):
-        """
-        Name of this data type, value is always \"leaf\".
-
-        :param dtype: The dtype of this LeafType.
-        :type: str
-        """
-
-        self._dtype = dtype
-
-    @property
     def elemental_id(self):
         """
         The elemental ID of the object.
 
-        :return: The elemental_id of this LeafType. 
+        :return: The elemental_id of this StateTypeUpdate. 
         :rtype: str
         """
         return self._elemental_id
 
     @elemental_id.setter
     def elemental_id(self, elemental_id):
         """
         The elemental ID of the object.
 
-        :param elemental_id: The elemental_id of this LeafType.
+        :param elemental_id: The elemental_id of this StateTypeUpdate.
         :type: str
         """
 
         self._elemental_id = elemental_id
 
     @property
-    def id(self):
+    def grouping_default(self):
         """
-        Unique integer identifying a leaf type.
+        Whether to group elements in the UI by default.
 
-        :return: The id of this LeafType. 
-        :rtype: int
+        :return: The grouping_default of this StateTypeUpdate. 
+        :rtype: bool
         """
-        return self._id
+        return self._grouping_default
 
-    @id.setter
-    def id(self, id):
+    @grouping_default.setter
+    def grouping_default(self, grouping_default):
         """
-        Unique integer identifying a leaf type.
+        Whether to group elements in the UI by default.
 
-        :param id: The id of this LeafType.
-        :type: int
+        :param grouping_default: The grouping_default of this StateTypeUpdate.
+        :type: bool
         """
 
-        self._id = id
+        self._grouping_default = grouping_default
 
     @property
     def name(self):
         """
-        Name of the leaf type.
+        Name of the state type.
 
-        :return: The name of this LeafType. 
+        :return: The name of this StateTypeUpdate. 
         :rtype: str
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """
-        Name of the leaf type.
+        Name of the state type.
 
-        :param name: The name of this LeafType.
+        :param name: The name of this StateTypeUpdate.
         :type: str
         """
 
         self._name = name
 
     @property
-    def project(self):
+    def visible(self):
         """
-        Unique integer identifying project for this leaf type.
+        Whether this state type should be displayed.
 
-        :return: The project of this LeafType. 
-        :rtype: int
+        :return: The visible of this StateTypeUpdate. 
+        :rtype: bool
         """
-        return self._project
+        return self._visible
 
-    @project.setter
-    def project(self, project):
+    @visible.setter
+    def visible(self, visible):
         """
-        Unique integer identifying project for this leaf type.
+        Whether this state type should be displayed.
 
-        :param project: The project of this LeafType.
-        :type: int
+        :param visible: The visible of this StateTypeUpdate.
+        :type: bool
         """
 
-        self._project = project
+        self._visible = visible
 
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.openapi_types):
             value = getattr(self, attr)
@@ -255,18 +229,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, LeafType):
+        if not isinstance(other, StateTypeUpdate):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, LeafType):
+        if not isinstance(other, StateTypeUpdate):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/leaf_type_spec.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/leaf_type_spec.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/leaf_type_update.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/leaf_type_update.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/leaf_update.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/leaf_update.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/live_definition.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/live_definition.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/live_update_definition.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/live_update_definition.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/localization.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/localization.py`

 * *Files 1% similar despite different names*

```diff
@@ -33,14 +33,15 @@
         'attributes': 'dict(str, object)',
         'created_by': 'int',
         'created_datetime': 'datetime',
         'elemental_id': 'str',
         'frame': 'int',
         'height': 'float',
         'id': 'int',
+        'mark': 'int',
         'media': 'int',
         'modified_by': 'int',
         'modified_datetime': 'datetime',
         'parent': 'float',
         'points': 'list[list[float]]',
         'project': 'int',
         'thumbnail_image': 'str',
@@ -59,14 +60,15 @@
         'attributes': 'attributes',
         'created_by': 'created_by',
         'created_datetime': 'created_datetime',
         'elemental_id': 'elemental_id',
         'frame': 'frame',
         'height': 'height',
         'id': 'id',
+        'mark': 'mark',
         'media': 'media',
         'modified_by': 'modified_by',
         'modified_datetime': 'modified_datetime',
         'parent': 'parent',
         'points': 'points',
         'project': 'project',
         'thumbnail_image': 'thumbnail_image',
@@ -77,27 +79,28 @@
         'variant_deleted': 'variant_deleted',
         'version': 'version',
         'width': 'width',
         'x': 'x',
         'y': 'y'
     }
 
-    def __init__(self, attributes=None, created_by=None, created_datetime=None, elemental_id=None, frame=None, height=None, id=None, media=None, modified_by=None, modified_datetime=None, parent=None, points=None, project=None, thumbnail_image=None, type=None, u=None, user=None, v=None, variant_deleted=None, version=None, width=None, x=None, y=None, local_vars_configuration=None):  # noqa: E501
+    def __init__(self, attributes=None, created_by=None, created_datetime=None, elemental_id=None, frame=None, height=None, id=None, mark=None, media=None, modified_by=None, modified_datetime=None, parent=None, points=None, project=None, thumbnail_image=None, type=None, u=None, user=None, v=None, variant_deleted=None, version=None, width=None, x=None, y=None, local_vars_configuration=None):  # noqa: E501
         """Localization - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration()
         self.local_vars_configuration = local_vars_configuration
 
         self._attributes = None
         self._created_by = None
         self._created_datetime = None
         self._elemental_id = None
         self._frame = None
         self._height = None
         self._id = None
+        self._mark = None
         self._media = None
         self._modified_by = None
         self._modified_datetime = None
         self._parent = None
         self._points = None
         self._project = None
         self._thumbnail_image = None
@@ -120,14 +123,16 @@
             self.created_datetime = created_datetime
         self.elemental_id = elemental_id
         if frame is not None:
             self.frame = frame
         self.height = height
         if id is not None:
             self.id = id
+        if mark is not None:
+            self.mark = mark
         if media is not None:
             self.media = media
         if modified_by is not None:
             self.modified_by = modified_by
         if modified_datetime is not None:
             self.modified_datetime = modified_datetime
         self.parent = parent
@@ -300,14 +305,35 @@
         :param id: The id of this Localization.
         :type: int
         """
 
         self._id = id
 
     @property
+    def mark(self):
+        """
+        Revision number of this object on this version branch
+
+        :return: The mark of this Localization. 
+        :rtype: int
+        """
+        return self._mark
+
+    @mark.setter
+    def mark(self, mark):
+        """
+        Revision number of this object on this version branch
+
+        :param mark: The mark of this Localization.
+        :type: int
+        """
+
+        self._mark = mark
+
+    @property
     def media(self):
         """
         Unique integer identifying media of this localization.
 
         :return: The media of this Localization. 
         :rtype: int
         """
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/localization_bulk_delete.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/localization_bulk_delete.py`

 * *Files 18% similar despite different names*

```diff
@@ -26,74 +26,100 @@
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
+        'elemental_ids': 'list[str]',
         'float_array': 'list[FloatArrayQuery]',
+        'frame_state_ids': 'list[int]',
         'ids': 'list[int]',
         'media_ids': 'list[int]',
         'media_query': 'str',
-        'null_attributes': 'list[str]',
         'object_search': 'AttributeOperationSpec',
+        'pedantic': 'int',
         'prune': 'int',
-        'reset_attributes': 'list[str]',
         'state_ids': 'list[int]'
     }
 
     attribute_map = {
+        'elemental_ids': 'elemental_ids',
         'float_array': 'float_array',
+        'frame_state_ids': 'frame_state_ids',
         'ids': 'ids',
         'media_ids': 'media_ids',
         'media_query': 'media_query',
-        'null_attributes': 'null_attributes',
         'object_search': 'object_search',
+        'pedantic': 'pedantic',
         'prune': 'prune',
-        'reset_attributes': 'reset_attributes',
         'state_ids': 'state_ids'
     }
 
-    def __init__(self, float_array=None, ids=None, media_ids=None, media_query=None, null_attributes=None, object_search=None, prune=0, reset_attributes=None, state_ids=None, local_vars_configuration=None):  # noqa: E501
+    def __init__(self, elemental_ids=None, float_array=None, frame_state_ids=None, ids=None, media_ids=None, media_query=None, object_search=None, pedantic=0, prune=0, state_ids=None, local_vars_configuration=None):  # noqa: E501
         """LocalizationBulkDelete - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration()
         self.local_vars_configuration = local_vars_configuration
 
+        self._elemental_ids = None
         self._float_array = None
+        self._frame_state_ids = None
         self._ids = None
         self._media_ids = None
         self._media_query = None
-        self._null_attributes = None
         self._object_search = None
+        self._pedantic = None
         self._prune = None
-        self._reset_attributes = None
         self._state_ids = None
         self.discriminator = None
 
+        if elemental_ids is not None:
+            self.elemental_ids = elemental_ids
         if float_array is not None:
             self.float_array = float_array
+        if frame_state_ids is not None:
+            self.frame_state_ids = frame_state_ids
         if ids is not None:
             self.ids = ids
         if media_ids is not None:
             self.media_ids = media_ids
         if media_query is not None:
             self.media_query = media_query
-        if null_attributes is not None:
-            self.null_attributes = null_attributes
         if object_search is not None:
             self.object_search = object_search
+        if pedantic is not None:
+            self.pedantic = pedantic
         if prune is not None:
             self.prune = prune
-        if reset_attributes is not None:
-            self.reset_attributes = reset_attributes
         if state_ids is not None:
             self.state_ids = state_ids
 
     @property
+    def elemental_ids(self):
+        """
+        Array of localizations to retrieve.
+
+        :return: The elemental_ids of this LocalizationBulkDelete. 
+        :rtype: list[str]
+        """
+        return self._elemental_ids
+
+    @elemental_ids.setter
+    def elemental_ids(self, elemental_ids):
+        """
+        Array of localizations to retrieve.
+
+        :param elemental_ids: The elemental_ids of this LocalizationBulkDelete.
+        :type: list[str]
+        """
+
+        self._elemental_ids = elemental_ids
+
+    @property
     def float_array(self):
         """
         Searches on `float_array` attributes.
 
         :return: The float_array of this LocalizationBulkDelete. 
         :rtype: list[FloatArrayQuery]
         """
@@ -107,14 +133,35 @@
         :param float_array: The float_array of this LocalizationBulkDelete.
         :type: list[FloatArrayQuery]
         """
 
         self._float_array = float_array
 
     @property
+    def frame_state_ids(self):
+        """
+        Array of frame state IDs for which localizations present in the same media/frame will be retrieved.
+
+        :return: The frame_state_ids of this LocalizationBulkDelete. 
+        :rtype: list[int]
+        """
+        return self._frame_state_ids
+
+    @frame_state_ids.setter
+    def frame_state_ids(self, frame_state_ids):
+        """
+        Array of frame state IDs for which localizations present in the same media/frame will be retrieved.
+
+        :param frame_state_ids: The frame_state_ids of this LocalizationBulkDelete.
+        :type: list[int]
+        """
+
+        self._frame_state_ids = frame_state_ids
+
+    @property
     def ids(self):
         """
         Array of localization IDs to retrieve.
 
         :return: The ids of this LocalizationBulkDelete. 
         :rtype: list[int]
         """
@@ -170,52 +217,58 @@
         :param media_query: The media_query of this LocalizationBulkDelete.
         :type: str
         """
 
         self._media_query = media_query
 
     @property
-    def null_attributes(self):
+    def object_search(self):
         """
-        Null a value in the attributes body
 
-        :return: The null_attributes of this LocalizationBulkDelete. 
-        :rtype: list[str]
+        :return: The object_search of this LocalizationBulkDelete. 
+        :rtype: AttributeOperationSpec
         """
-        return self._null_attributes
+        return self._object_search
 
-    @null_attributes.setter
-    def null_attributes(self, null_attributes):
+    @object_search.setter
+    def object_search(self, object_search):
         """
-        Null a value in the attributes body
 
-        :param null_attributes: The null_attributes of this LocalizationBulkDelete.
-        :type: list[str]
+        :param object_search: The object_search of this LocalizationBulkDelete.
+        :type: AttributeOperationSpec
         """
 
-        self._null_attributes = null_attributes
+        self._object_search = object_search
 
     @property
-    def object_search(self):
+    def pedantic(self):
         """
+        Set to 1 to enforce that this is the latest mark; else push edits to end of branch.
 
-        :return: The object_search of this LocalizationBulkDelete. 
-        :rtype: AttributeOperationSpec
+        :return: The pedantic of this LocalizationBulkDelete. 
+        :rtype: int
         """
-        return self._object_search
+        return self._pedantic
 
-    @object_search.setter
-    def object_search(self, object_search):
+    @pedantic.setter
+    def pedantic(self, pedantic):
         """
+        Set to 1 to enforce that this is the latest mark; else push edits to end of branch.
 
-        :param object_search: The object_search of this LocalizationBulkDelete.
-        :type: AttributeOperationSpec
+        :param pedantic: The pedantic of this LocalizationBulkDelete.
+        :type: int
         """
+        if (self.local_vars_configuration.client_side_validation and
+                pedantic is not None and pedantic > 1):  # noqa: E501
+            raise ValueError("Invalid value for `pedantic`, must be a value less than or equal to `1`")  # noqa: E501
+        if (self.local_vars_configuration.client_side_validation and
+                pedantic is not None and pedantic < 0):  # noqa: E501
+            raise ValueError("Invalid value for `pedantic`, must be a value greater than or equal to `0`")  # noqa: E501
 
-        self._object_search = object_search
+        self._pedantic = pedantic
 
     @property
     def prune(self):
         """
         If set to 1 will purge the object from the database entirely. This removes any record, change-log, that this metadatum ever existed.
 
         :return: The prune of this LocalizationBulkDelete. 
@@ -237,48 +290,27 @@
         if (self.local_vars_configuration.client_side_validation and
                 prune is not None and prune < 0):  # noqa: E501
             raise ValueError("Invalid value for `prune`, must be a value greater than or equal to `0`")  # noqa: E501
 
         self._prune = prune
 
     @property
-    def reset_attributes(self):
-        """
-        Reset an attribute to the default value specified in the Type object
-
-        :return: The reset_attributes of this LocalizationBulkDelete. 
-        :rtype: list[str]
-        """
-        return self._reset_attributes
-
-    @reset_attributes.setter
-    def reset_attributes(self, reset_attributes):
-        """
-        Reset an attribute to the default value specified in the Type object
-
-        :param reset_attributes: The reset_attributes of this LocalizationBulkDelete.
-        :type: list[str]
-        """
-
-        self._reset_attributes = reset_attributes
-
-    @property
     def state_ids(self):
         """
-        Array of parent state IDs for which localizations should be retrieved.
+        Array of parent localization state (track) IDs for which localizations should be retrieved.
 
         :return: The state_ids of this LocalizationBulkDelete. 
         :rtype: list[int]
         """
         return self._state_ids
 
     @state_ids.setter
     def state_ids(self, state_ids):
         """
-        Array of parent state IDs for which localizations should be retrieved.
+        Array of parent localization state (track) IDs for which localizations should be retrieved.
 
         :param state_ids: The state_ids of this LocalizationBulkDelete.
         :type: list[int]
         """
 
         self._state_ids = state_ids
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/localization_bulk_update.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/user_update.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,297 +14,299 @@
 import re  # noqa: F401
 
 import six
 
 from ..configuration import Configuration
 
 
-class LocalizationBulkUpdate(object):
+class UserUpdate(object):
     """
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
-        'attributes': 'dict(str, object)',
-        'float_array': 'list[FloatArrayQuery]',
-        'ids': 'list[int]',
-        'media_ids': 'list[int]',
-        'media_query': 'str',
-        'new_elemental_id': 'str',
-        'new_version': 'int',
-        'object_search': 'AttributeOperationSpec',
-        'state_ids': 'list[int]',
-        'user_elemental_id': 'str'
+        'clear_avatar': 'int',
+        'clear_profile_keys': 'list[str]',
+        'elemental_id': 'str',
+        'email': 'str',
+        'first_name': 'str',
+        'last_name': 'str',
+        'new_avatar': 'str',
+        'password': 'str',
+        'reset_token': 'str',
+        'set_profile_keys': 'object'
     }
 
     attribute_map = {
-        'attributes': 'attributes',
-        'float_array': 'float_array',
-        'ids': 'ids',
-        'media_ids': 'media_ids',
-        'media_query': 'media_query',
-        'new_elemental_id': 'new_elemental_id',
-        'new_version': 'new_version',
-        'object_search': 'object_search',
-        'state_ids': 'state_ids',
-        'user_elemental_id': 'user_elemental_id'
+        'clear_avatar': 'clear_avatar',
+        'clear_profile_keys': 'clear_profile_keys',
+        'elemental_id': 'elemental_id',
+        'email': 'email',
+        'first_name': 'first_name',
+        'last_name': 'last_name',
+        'new_avatar': 'new_avatar',
+        'password': 'password',
+        'reset_token': 'reset_token',
+        'set_profile_keys': 'set_profile_keys'
     }
 
-    def __init__(self, attributes=None, float_array=None, ids=None, media_ids=None, media_query=None, new_elemental_id=None, new_version=None, object_search=None, state_ids=None, user_elemental_id=None, local_vars_configuration=None):  # noqa: E501
-        """LocalizationBulkUpdate - a model defined in OpenAPI"""
+    def __init__(self, clear_avatar=0, clear_profile_keys=None, elemental_id=None, email=None, first_name=None, last_name=None, new_avatar=None, password=None, reset_token=None, set_profile_keys=None, local_vars_configuration=None):  # noqa: E501
+        """UserUpdate - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration()
         self.local_vars_configuration = local_vars_configuration
 
-        self._attributes = None
-        self._float_array = None
-        self._ids = None
-        self._media_ids = None
-        self._media_query = None
-        self._new_elemental_id = None
-        self._new_version = None
-        self._object_search = None
-        self._state_ids = None
-        self._user_elemental_id = None
+        self._clear_avatar = None
+        self._clear_profile_keys = None
+        self._elemental_id = None
+        self._email = None
+        self._first_name = None
+        self._last_name = None
+        self._new_avatar = None
+        self._password = None
+        self._reset_token = None
+        self._set_profile_keys = None
         self.discriminator = None
 
-        if attributes is not None:
-            self.attributes = attributes
-        if float_array is not None:
-            self.float_array = float_array
-        if ids is not None:
-            self.ids = ids
-        if media_ids is not None:
-            self.media_ids = media_ids
-        if media_query is not None:
-            self.media_query = media_query
-        if new_elemental_id is not None:
-            self.new_elemental_id = new_elemental_id
-        if new_version is not None:
-            self.new_version = new_version
-        if object_search is not None:
-            self.object_search = object_search
-        if state_ids is not None:
-            self.state_ids = state_ids
-        if user_elemental_id is not None:
-            self.user_elemental_id = user_elemental_id
+        if clear_avatar is not None:
+            self.clear_avatar = clear_avatar
+        if clear_profile_keys is not None:
+            self.clear_profile_keys = clear_profile_keys
+        if elemental_id is not None:
+            self.elemental_id = elemental_id
+        if email is not None:
+            self.email = email
+        if first_name is not None:
+            self.first_name = first_name
+        if last_name is not None:
+            self.last_name = last_name
+        if new_avatar is not None:
+            self.new_avatar = new_avatar
+        if password is not None:
+            self.password = password
+        if reset_token is not None:
+            self.reset_token = reset_token
+        if set_profile_keys is not None:
+            self.set_profile_keys = set_profile_keys
 
     @property
-    def attributes(self):
+    def clear_avatar(self):
         """
-        Attribute values to bulk update an entity list.
+        Set to >0 to clear the current avatar of the user
 
-        :return: The attributes of this LocalizationBulkUpdate. 
-        :rtype: dict(str, object)
+        :return: The clear_avatar of this UserUpdate. 
+        :rtype: int
         """
-        return self._attributes
+        return self._clear_avatar
 
-    @attributes.setter
-    def attributes(self, attributes):
+    @clear_avatar.setter
+    def clear_avatar(self, clear_avatar):
         """
-        Attribute values to bulk update an entity list.
+        Set to >0 to clear the current avatar of the user
 
-        :param attributes: The attributes of this LocalizationBulkUpdate.
-        :type: dict(str, object)
+        :param clear_avatar: The clear_avatar of this UserUpdate.
+        :type: int
         """
 
-        self._attributes = attributes
+        self._clear_avatar = clear_avatar
 
     @property
-    def float_array(self):
+    def clear_profile_keys(self):
         """
-        Searches on `float_array` attributes.
+        Clear the given keys from the profile dictionary
 
-        :return: The float_array of this LocalizationBulkUpdate. 
-        :rtype: list[FloatArrayQuery]
+        :return: The clear_profile_keys of this UserUpdate. 
+        :rtype: list[str]
         """
-        return self._float_array
+        return self._clear_profile_keys
 
-    @float_array.setter
-    def float_array(self, float_array):
+    @clear_profile_keys.setter
+    def clear_profile_keys(self, clear_profile_keys):
         """
-        Searches on `float_array` attributes.
+        Clear the given keys from the profile dictionary
 
-        :param float_array: The float_array of this LocalizationBulkUpdate.
-        :type: list[FloatArrayQuery]
+        :param clear_profile_keys: The clear_profile_keys of this UserUpdate.
+        :type: list[str]
         """
 
-        self._float_array = float_array
+        self._clear_profile_keys = clear_profile_keys
 
     @property
-    def ids(self):
+    def elemental_id(self):
         """
-        Array of localization IDs to retrieve.
+        Unique ID for a user across clusters/deployments
 
-        :return: The ids of this LocalizationBulkUpdate. 
-        :rtype: list[int]
+        :return: The elemental_id of this UserUpdate. 
+        :rtype: str
         """
-        return self._ids
+        return self._elemental_id
 
-    @ids.setter
-    def ids(self, ids):
+    @elemental_id.setter
+    def elemental_id(self, elemental_id):
         """
-        Array of localization IDs to retrieve.
+        Unique ID for a user across clusters/deployments
 
-        :param ids: The ids of this LocalizationBulkUpdate.
-        :type: list[int]
+        :param elemental_id: The elemental_id of this UserUpdate.
+        :type: str
         """
 
-        self._ids = ids
+        self._elemental_id = elemental_id
 
     @property
-    def media_ids(self):
+    def email(self):
         """
-        Array of parent media IDs for which localizations should be retrieved.
+        Email address of user.
 
-        :return: The media_ids of this LocalizationBulkUpdate. 
-        :rtype: list[int]
+        :return: The email of this UserUpdate. 
+        :rtype: str
         """
-        return self._media_ids
+        return self._email
 
-    @media_ids.setter
-    def media_ids(self, media_ids):
+    @email.setter
+    def email(self, email):
         """
-        Array of parent media IDs for which localizations should be retrieved.
+        Email address of user.
 
-        :param media_ids: The media_ids of this LocalizationBulkUpdate.
-        :type: list[int]
+        :param email: The email of this UserUpdate.
+        :type: str
         """
 
-        self._media_ids = media_ids
+        self._email = email
 
     @property
-    def media_query(self):
+    def first_name(self):
         """
-        Query string used to filter media IDs. This can be used to avoid serialization and download of a media ID list.
+        First name of user.
 
-        :return: The media_query of this LocalizationBulkUpdate. 
+        :return: The first_name of this UserUpdate. 
         :rtype: str
         """
-        return self._media_query
+        return self._first_name
 
-    @media_query.setter
-    def media_query(self, media_query):
+    @first_name.setter
+    def first_name(self, first_name):
         """
-        Query string used to filter media IDs. This can be used to avoid serialization and download of a media ID list.
+        First name of user.
 
-        :param media_query: The media_query of this LocalizationBulkUpdate.
+        :param first_name: The first_name of this UserUpdate.
         :type: str
         """
 
-        self._media_query = media_query
+        self._first_name = first_name
 
     @property
-    def new_elemental_id(self):
+    def last_name(self):
         """
-        The new elemental ID for these objects
+        Last name of user.
 
-        :return: The new_elemental_id of this LocalizationBulkUpdate. 
+        :return: The last_name of this UserUpdate. 
         :rtype: str
         """
-        return self._new_elemental_id
+        return self._last_name
 
-    @new_elemental_id.setter
-    def new_elemental_id(self, new_elemental_id):
+    @last_name.setter
+    def last_name(self, last_name):
         """
-        The new elemental ID for these objects
+        Last name of user.
 
-        :param new_elemental_id: The new_elemental_id of this LocalizationBulkUpdate.
+        :param last_name: The last_name of this UserUpdate.
         :type: str
         """
 
-        self._new_elemental_id = new_elemental_id
+        self._last_name = last_name
 
     @property
-    def new_version(self):
+    def new_avatar(self):
         """
-        Unique integer identifying a new version for these objects
+        b64 encoded image to use for the avatar of the user.This file is verified to meet system constraints:    - Less than 1Mb     - a mimetype of image/png or image/jpg
 
-        :return: The new_version of this LocalizationBulkUpdate. 
-        :rtype: int
+        :return: The new_avatar of this UserUpdate. 
+        :rtype: str
         """
-        return self._new_version
+        return self._new_avatar
 
-    @new_version.setter
-    def new_version(self, new_version):
+    @new_avatar.setter
+    def new_avatar(self, new_avatar):
         """
-        Unique integer identifying a new version for these objects
+        b64 encoded image to use for the avatar of the user.This file is verified to meet system constraints:    - Less than 1Mb     - a mimetype of image/png or image/jpg
 
-        :param new_version: The new_version of this LocalizationBulkUpdate.
-        :type: int
+        :param new_avatar: The new_avatar of this UserUpdate.
+        :type: str
         """
 
-        self._new_version = new_version
+        self._new_avatar = new_avatar
 
     @property
-    def object_search(self):
+    def password(self):
         """
+        Account password.
 
-        :return: The object_search of this LocalizationBulkUpdate. 
-        :rtype: AttributeOperationSpec
+        :return: The password of this UserUpdate. 
+        :rtype: str
         """
-        return self._object_search
+        return self._password
 
-    @object_search.setter
-    def object_search(self, object_search):
+    @password.setter
+    def password(self, password):
         """
+        Account password.
 
-        :param object_search: The object_search of this LocalizationBulkUpdate.
-        :type: AttributeOperationSpec
+        :param password: The password of this UserUpdate.
+        :type: str
         """
 
-        self._object_search = object_search
+        self._password = password
 
     @property
-    def state_ids(self):
+    def reset_token(self):
         """
-        Array of parent state IDs for which localizations should be retrieved.
+        Password reset token generated by PasswordReset object.
 
-        :return: The state_ids of this LocalizationBulkUpdate. 
-        :rtype: list[int]
+        :return: The reset_token of this UserUpdate. 
+        :rtype: str
         """
-        return self._state_ids
+        return self._reset_token
 
-    @state_ids.setter
-    def state_ids(self, state_ids):
+    @reset_token.setter
+    def reset_token(self, reset_token):
         """
-        Array of parent state IDs for which localizations should be retrieved.
+        Password reset token generated by PasswordReset object.
 
-        :param state_ids: The state_ids of this LocalizationBulkUpdate.
-        :type: list[int]
+        :param reset_token: The reset_token of this UserUpdate.
+        :type: str
         """
 
-        self._state_ids = state_ids
+        self._reset_token = reset_token
 
     @property
-    def user_elemental_id(self):
+    def set_profile_keys(self):
         """
-        Unique ID of the original user who created this. If permissions allow, will change the creating user to the one referenced by this elemental_id
+        Key/Value Pairs to set atomically
 
-        :return: The user_elemental_id of this LocalizationBulkUpdate. 
-        :rtype: str
+        :return: The set_profile_keys of this UserUpdate. 
+        :rtype: object
         """
-        return self._user_elemental_id
+        return self._set_profile_keys
 
-    @user_elemental_id.setter
-    def user_elemental_id(self, user_elemental_id):
+    @set_profile_keys.setter
+    def set_profile_keys(self, set_profile_keys):
         """
-        Unique ID of the original user who created this. If permissions allow, will change the creating user to the one referenced by this elemental_id
+        Key/Value Pairs to set atomically
 
-        :param user_elemental_id: The user_elemental_id of this LocalizationBulkUpdate.
-        :type: str
+        :param set_profile_keys: The set_profile_keys of this UserUpdate.
+        :type: object
         """
 
-        self._user_elemental_id = user_elemental_id
+        self._set_profile_keys = set_profile_keys
 
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.openapi_types):
             value = getattr(self, attr)
@@ -332,18 +334,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, LocalizationBulkUpdate):
+        if not isinstance(other, UserUpdate):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, LocalizationBulkUpdate):
+        if not isinstance(other, UserUpdate):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/localization_delete.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/parameter.py`

 * *Files 13% similar despite different names*

```diff
@@ -14,71 +14,93 @@
 import re  # noqa: F401
 
 import six
 
 from ..configuration import Configuration
 
 
-class LocalizationDelete(object):
+class Parameter(object):
     """
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
-        'prune': 'int'
+        'name': 'str',
+        'value': 'str'
     }
 
     attribute_map = {
-        'prune': 'prune'
+        'name': 'name',
+        'value': 'value'
     }
 
-    def __init__(self, prune=0, local_vars_configuration=None):  # noqa: E501
-        """LocalizationDelete - a model defined in OpenAPI"""
+    def __init__(self, name=None, value=None, local_vars_configuration=None):  # noqa: E501
+        """Parameter - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration()
         self.local_vars_configuration = local_vars_configuration
 
-        self._prune = None
+        self._name = None
+        self._value = None
         self.discriminator = None
 
-        if prune is not None:
-            self.prune = prune
+        self.name = name
+        self.value = value
 
     @property
-    def prune(self):
+    def name(self):
         """
-        If set to 1 will purge the object from the database entirely. This removes any record, change-log, that this metadatum ever existed.
+        Name of parameter
 
-        :return: The prune of this LocalizationDelete. 
-        :rtype: int
+        :return: The name of this Parameter. 
+        :rtype: str
         """
-        return self._prune
+        return self._name
 
-    @prune.setter
-    def prune(self, prune):
+    @name.setter
+    def name(self, name):
         """
-        If set to 1 will purge the object from the database entirely. This removes any record, change-log, that this metadatum ever existed.
+        Name of parameter
 
-        :param prune: The prune of this LocalizationDelete.
-        :type: int
+        :param name: The name of this Parameter.
+        :type: str
         """
-        if (self.local_vars_configuration.client_side_validation and
-                prune is not None and prune > 1):  # noqa: E501
-            raise ValueError("Invalid value for `prune`, must be a value less than or equal to `1`")  # noqa: E501
-        if (self.local_vars_configuration.client_side_validation and
-                prune is not None and prune < 0):  # noqa: E501
-            raise ValueError("Invalid value for `prune`, must be a value greater than or equal to `0`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and name is None:  # noqa: E501
+            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501
 
-        self._prune = prune
+        self._name = name
+
+    @property
+    def value(self):
+        """
+        Value of parameter
+
+        :return: The value of this Parameter. 
+        :rtype: str
+        """
+        return self._value
+
+    @value.setter
+    def value(self, value):
+        """
+        Value of parameter
+
+        :param value: The value of this Parameter.
+        :type: str
+        """
+        if self.local_vars_configuration.client_side_validation and value is None:  # noqa: E501
+            raise ValueError("Invalid value for `value`, must not be `None`")  # noqa: E501
+
+        self._value = value
 
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.openapi_types):
             value = getattr(self, attr)
@@ -106,18 +128,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, LocalizationDelete):
+        if not isinstance(other, Parameter):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, LocalizationDelete):
+        if not isinstance(other, Parameter):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/localization_id_query.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/state_id_query.py`

 * *Files 6% similar despite different names*

```diff
@@ -14,194 +14,194 @@
 import re  # noqa: F401
 
 import six
 
 from ..configuration import Configuration
 
 
-class LocalizationIdQuery(object):
+class StateIdQuery(object):
     """
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
         'float_array': 'list[FloatArrayQuery]',
         'ids': 'list[int]',
+        'localization_ids': 'list[int]',
         'media_ids': 'list[int]',
         'media_query': 'str',
-        'object_search': 'AttributeOperationSpec',
-        'state_ids': 'list[int]'
+        'object_search': 'AttributeOperationSpec'
     }
 
     attribute_map = {
         'float_array': 'float_array',
         'ids': 'ids',
+        'localization_ids': 'localization_ids',
         'media_ids': 'media_ids',
         'media_query': 'media_query',
-        'object_search': 'object_search',
-        'state_ids': 'state_ids'
+        'object_search': 'object_search'
     }
 
-    def __init__(self, float_array=None, ids=None, media_ids=None, media_query=None, object_search=None, state_ids=None, local_vars_configuration=None):  # noqa: E501
-        """LocalizationIdQuery - a model defined in OpenAPI"""
+    def __init__(self, float_array=None, ids=None, localization_ids=None, media_ids=None, media_query=None, object_search=None, local_vars_configuration=None):  # noqa: E501
+        """StateIdQuery - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration()
         self.local_vars_configuration = local_vars_configuration
 
         self._float_array = None
         self._ids = None
+        self._localization_ids = None
         self._media_ids = None
         self._media_query = None
         self._object_search = None
-        self._state_ids = None
         self.discriminator = None
 
         if float_array is not None:
             self.float_array = float_array
         if ids is not None:
             self.ids = ids
+        if localization_ids is not None:
+            self.localization_ids = localization_ids
         if media_ids is not None:
             self.media_ids = media_ids
         if media_query is not None:
             self.media_query = media_query
         if object_search is not None:
             self.object_search = object_search
-        if state_ids is not None:
-            self.state_ids = state_ids
 
     @property
     def float_array(self):
         """
         Searches on `float_array` attributes.
 
-        :return: The float_array of this LocalizationIdQuery. 
+        :return: The float_array of this StateIdQuery. 
         :rtype: list[FloatArrayQuery]
         """
         return self._float_array
 
     @float_array.setter
     def float_array(self, float_array):
         """
         Searches on `float_array` attributes.
 
-        :param float_array: The float_array of this LocalizationIdQuery.
+        :param float_array: The float_array of this StateIdQuery.
         :type: list[FloatArrayQuery]
         """
 
         self._float_array = float_array
 
     @property
     def ids(self):
         """
-        Array of localization IDs to retrieve.
+        Array of state IDs to retrieve.
 
-        :return: The ids of this LocalizationIdQuery. 
+        :return: The ids of this StateIdQuery. 
         :rtype: list[int]
         """
         return self._ids
 
     @ids.setter
     def ids(self, ids):
         """
-        Array of localization IDs to retrieve.
+        Array of state IDs to retrieve.
 
-        :param ids: The ids of this LocalizationIdQuery.
+        :param ids: The ids of this StateIdQuery.
         :type: list[int]
         """
 
         self._ids = ids
 
     @property
+    def localization_ids(self):
+        """
+        Array of child localization IDs for which states should be retrieved.
+
+        :return: The localization_ids of this StateIdQuery. 
+        :rtype: list[int]
+        """
+        return self._localization_ids
+
+    @localization_ids.setter
+    def localization_ids(self, localization_ids):
+        """
+        Array of child localization IDs for which states should be retrieved.
+
+        :param localization_ids: The localization_ids of this StateIdQuery.
+        :type: list[int]
+        """
+
+        self._localization_ids = localization_ids
+
+    @property
     def media_ids(self):
         """
-        Array of parent media IDs for which localizations should be retrieved.
+        Array of parent media IDs for which states should be retrieved.
 
-        :return: The media_ids of this LocalizationIdQuery. 
+        :return: The media_ids of this StateIdQuery. 
         :rtype: list[int]
         """
         return self._media_ids
 
     @media_ids.setter
     def media_ids(self, media_ids):
         """
-        Array of parent media IDs for which localizations should be retrieved.
+        Array of parent media IDs for which states should be retrieved.
 
-        :param media_ids: The media_ids of this LocalizationIdQuery.
+        :param media_ids: The media_ids of this StateIdQuery.
         :type: list[int]
         """
 
         self._media_ids = media_ids
 
     @property
     def media_query(self):
         """
         Query string used to filter media IDs. This can be used to avoid serialization and download of a media ID list.
 
-        :return: The media_query of this LocalizationIdQuery. 
+        :return: The media_query of this StateIdQuery. 
         :rtype: str
         """
         return self._media_query
 
     @media_query.setter
     def media_query(self, media_query):
         """
         Query string used to filter media IDs. This can be used to avoid serialization and download of a media ID list.
 
-        :param media_query: The media_query of this LocalizationIdQuery.
+        :param media_query: The media_query of this StateIdQuery.
         :type: str
         """
 
         self._media_query = media_query
 
     @property
     def object_search(self):
         """
 
-        :return: The object_search of this LocalizationIdQuery. 
+        :return: The object_search of this StateIdQuery. 
         :rtype: AttributeOperationSpec
         """
         return self._object_search
 
     @object_search.setter
     def object_search(self, object_search):
         """
 
-        :param object_search: The object_search of this LocalizationIdQuery.
+        :param object_search: The object_search of this StateIdQuery.
         :type: AttributeOperationSpec
         """
 
         self._object_search = object_search
 
-    @property
-    def state_ids(self):
-        """
-        Array of parent state IDs for which localizations should be retrieved.
-
-        :return: The state_ids of this LocalizationIdQuery. 
-        :rtype: list[int]
-        """
-        return self._state_ids
-
-    @state_ids.setter
-    def state_ids(self, state_ids):
-        """
-        Array of parent state IDs for which localizations should be retrieved.
-
-        :param state_ids: The state_ids of this LocalizationIdQuery.
-        :type: list[int]
-        """
-
-        self._state_ids = state_ids
-
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.openapi_types):
             value = getattr(self, attr)
             if isinstance(value, list):
@@ -228,18 +228,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, LocalizationIdQuery):
+        if not isinstance(other, StateIdQuery):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, LocalizationIdQuery):
+        if not isinstance(other, StateIdQuery):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/localization_spec.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/localization_spec.py`

 * *Files 1% similar despite different names*

```diff
@@ -30,14 +30,15 @@
                             and the value is json key in definition.
     """
     openapi_types = {
         'attributes': 'dict(str, object)',
         'elemental_id': 'str',
         'frame': 'int',
         'height': 'float',
+        'mark': 'int',
         'media_id': 'int',
         'parent': 'float',
         'points': 'list[list[float]]',
         'type': 'int',
         'u': 'float',
         'user_elemental_id': 'str',
         'v': 'float',
@@ -48,37 +49,39 @@
     }
 
     attribute_map = {
         'attributes': 'attributes',
         'elemental_id': 'elemental_id',
         'frame': 'frame',
         'height': 'height',
+        'mark': 'mark',
         'media_id': 'media_id',
         'parent': 'parent',
         'points': 'points',
         'type': 'type',
         'u': 'u',
         'user_elemental_id': 'user_elemental_id',
         'v': 'v',
         'version': 'version',
         'width': 'width',
         'x': 'x',
         'y': 'y'
     }
 
-    def __init__(self, attributes=None, elemental_id=None, frame=None, height=None, media_id=None, parent=None, points=None, type=None, u=None, user_elemental_id=None, v=None, version=None, width=None, x=None, y=None, local_vars_configuration=None):  # noqa: E501
+    def __init__(self, attributes=None, elemental_id=None, frame=None, height=None, mark=None, media_id=None, parent=None, points=None, type=None, u=None, user_elemental_id=None, v=None, version=None, width=None, x=None, y=None, local_vars_configuration=None):  # noqa: E501
         """LocalizationSpec - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration()
         self.local_vars_configuration = local_vars_configuration
 
         self._attributes = None
         self._elemental_id = None
         self._frame = None
         self._height = None
+        self._mark = None
         self._media_id = None
         self._parent = None
         self._points = None
         self._type = None
         self._u = None
         self._user_elemental_id = None
         self._v = None
@@ -89,14 +92,16 @@
         self.discriminator = None
 
         if attributes is not None:
             self.attributes = attributes
         self.elemental_id = elemental_id
         self.frame = frame
         self.height = height
+        if mark is not None:
+            self.mark = mark
         self.media_id = media_id
         self.parent = parent
         self.points = points
         self.type = type
         self.u = u
         if user_elemental_id is not None:
             self.user_elemental_id = user_elemental_id
@@ -196,14 +201,35 @@
         if (self.local_vars_configuration.client_side_validation and
                 height is not None and height < 0.0):  # noqa: E501
             raise ValueError("Invalid value for `height`, must be a value greater than or equal to `0.0`")  # noqa: E501
 
         self._height = height
 
     @property
+    def mark(self):
+        """
+        Revision number of this object on this version branch
+
+        :return: The mark of this LocalizationSpec. 
+        :rtype: int
+        """
+        return self._mark
+
+    @mark.setter
+    def mark(self, mark):
+        """
+        Revision number of this object on this version branch
+
+        :param mark: The mark of this LocalizationSpec.
+        :type: int
+        """
+
+        self._mark = mark
+
+    @property
     def media_id(self):
         """
         Unique integer identifying a media.
 
         :return: The media_id of this LocalizationSpec. 
         :rtype: int
         """
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/localization_type.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/localization_type.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/localization_type_spec.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/localization_type_spec.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/localization_type_update.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/localization_type_update.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/localization_update.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/localization_update.py`

 * *Files 11% similar despite different names*

```diff
@@ -30,16 +30,19 @@
                             and the value is json key in definition.
     """
     openapi_types = {
         'attributes': 'dict(str, object)',
         'elemental_id': 'str',
         'frame': 'int',
         'height': 'float',
+        'in_place': 'int',
+        'mark': 'int',
         'null_attributes': 'list[str]',
         'parent': 'float',
+        'pedantic': 'int',
         'points': 'list[list[float]]',
         'reset_attributes': 'list[str]',
         'u': 'float',
         'user_elemental_id': 'str',
         'v': 'float',
         'width': 'float',
         'x': 'float',
@@ -47,38 +50,44 @@
     }
 
     attribute_map = {
         'attributes': 'attributes',
         'elemental_id': 'elemental_id',
         'frame': 'frame',
         'height': 'height',
+        'in_place': 'in_place',
+        'mark': 'mark',
         'null_attributes': 'null_attributes',
         'parent': 'parent',
+        'pedantic': 'pedantic',
         'points': 'points',
         'reset_attributes': 'reset_attributes',
         'u': 'u',
         'user_elemental_id': 'user_elemental_id',
         'v': 'v',
         'width': 'width',
         'x': 'x',
         'y': 'y'
     }
 
-    def __init__(self, attributes=None, elemental_id=None, frame=None, height=None, null_attributes=None, parent=None, points=None, reset_attributes=None, u=None, user_elemental_id=None, v=None, width=None, x=None, y=None, local_vars_configuration=None):  # noqa: E501
+    def __init__(self, attributes=None, elemental_id=None, frame=None, height=None, in_place=0, mark=None, null_attributes=None, parent=None, pedantic=0, points=None, reset_attributes=None, u=None, user_elemental_id=None, v=None, width=None, x=None, y=None, local_vars_configuration=None):  # noqa: E501
         """LocalizationUpdate - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration()
         self.local_vars_configuration = local_vars_configuration
 
         self._attributes = None
         self._elemental_id = None
         self._frame = None
         self._height = None
+        self._in_place = None
+        self._mark = None
         self._null_attributes = None
         self._parent = None
+        self._pedantic = None
         self._points = None
         self._reset_attributes = None
         self._u = None
         self._user_elemental_id = None
         self._v = None
         self._width = None
         self._x = None
@@ -87,17 +96,23 @@
 
         if attributes is not None:
             self.attributes = attributes
         self.elemental_id = elemental_id
         if frame is not None:
             self.frame = frame
         self.height = height
+        if in_place is not None:
+            self.in_place = in_place
+        if mark is not None:
+            self.mark = mark
         if null_attributes is not None:
             self.null_attributes = null_attributes
         self.parent = parent
+        if pedantic is not None:
+            self.pedantic = pedantic
         self.points = points
         if reset_attributes is not None:
             self.reset_attributes = reset_attributes
         self.u = u
         if user_elemental_id is not None:
             self.user_elemental_id = user_elemental_id
         self.v = v
@@ -192,14 +207,62 @@
         if (self.local_vars_configuration.client_side_validation and
                 height is not None and height < 0.0):  # noqa: E501
             raise ValueError("Invalid value for `height`, must be a value greater than or equal to `0.0`")  # noqa: E501
 
         self._height = height
 
     @property
+    def in_place(self):
+        """
+        Set to 1 to edit this record in-place, else mark-based versioning rules apply. This changes to 1 for authorship changes automatically.
+
+        :return: The in_place of this LocalizationUpdate. 
+        :rtype: int
+        """
+        return self._in_place
+
+    @in_place.setter
+    def in_place(self, in_place):
+        """
+        Set to 1 to edit this record in-place, else mark-based versioning rules apply. This changes to 1 for authorship changes automatically.
+
+        :param in_place: The in_place of this LocalizationUpdate.
+        :type: int
+        """
+        if (self.local_vars_configuration.client_side_validation and
+                in_place is not None and in_place > 1):  # noqa: E501
+            raise ValueError("Invalid value for `in_place`, must be a value less than or equal to `1`")  # noqa: E501
+        if (self.local_vars_configuration.client_side_validation and
+                in_place is not None and in_place < 0):  # noqa: E501
+            raise ValueError("Invalid value for `in_place`, must be a value greater than or equal to `0`")  # noqa: E501
+
+        self._in_place = in_place
+
+    @property
+    def mark(self):
+        """
+        Revision number of this object on this version branch
+
+        :return: The mark of this LocalizationUpdate. 
+        :rtype: int
+        """
+        return self._mark
+
+    @mark.setter
+    def mark(self, mark):
+        """
+        Revision number of this object on this version branch
+
+        :param mark: The mark of this LocalizationUpdate.
+        :type: int
+        """
+
+        self._mark = mark
+
+    @property
     def null_attributes(self):
         """
         Null a value in the attributes body
 
         :return: The null_attributes of this LocalizationUpdate. 
         :rtype: list[str]
         """
@@ -234,14 +297,41 @@
         :param parent: The parent of this LocalizationUpdate.
         :type: float
         """
 
         self._parent = parent
 
     @property
+    def pedantic(self):
+        """
+        Set to 1 to enforce that this is the latest mark; else push edits to end of branch.
+
+        :return: The pedantic of this LocalizationUpdate. 
+        :rtype: int
+        """
+        return self._pedantic
+
+    @pedantic.setter
+    def pedantic(self, pedantic):
+        """
+        Set to 1 to enforce that this is the latest mark; else push edits to end of branch.
+
+        :param pedantic: The pedantic of this LocalizationUpdate.
+        :type: int
+        """
+        if (self.local_vars_configuration.client_side_validation and
+                pedantic is not None and pedantic > 1):  # noqa: E501
+            raise ValueError("Invalid value for `pedantic`, must be a value less than or equal to `1`")  # noqa: E501
+        if (self.local_vars_configuration.client_side_validation and
+                pedantic is not None and pedantic < 0):  # noqa: E501
+            raise ValueError("Invalid value for `pedantic`, must be a value greater than or equal to `0`")  # noqa: E501
+
+        self._pedantic = pedantic
+
+    @property
     def points(self):
         """
         List of normalized [x, y] pairs for `poly` localization types.
 
         :return: The points of this LocalizationUpdate. 
         :rtype: list[list[float]]
         """
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/media.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/media.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/media_bulk_update.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/media_bulk_update.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/media_files.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/media_files.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/media_id_query.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/media_id_query.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/media_next.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/media_next.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/media_prev.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/media_prev.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/media_spec.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/media_spec.py`

 * *Files 7% similar despite different names*

```diff
@@ -37,14 +37,15 @@
         'gid': 'str',
         'height': 'int',
         'md5': 'str',
         'name': 'str',
         'num_frames': 'int',
         'reference_only': 'int',
         'section': 'str',
+        'section_id': 'int',
         'summary_level': 'int',
         'thumbnail_gif_url': 'str',
         'thumbnail_url': 'str',
         'type': 'int',
         'uid': 'str',
         'url': 'str',
         'user_elemental_id': 'str',
@@ -59,25 +60,26 @@
         'gid': 'gid',
         'height': 'height',
         'md5': 'md5',
         'name': 'name',
         'num_frames': 'num_frames',
         'reference_only': 'reference_only',
         'section': 'section',
+        'section_id': 'section_id',
         'summary_level': 'summary_level',
         'thumbnail_gif_url': 'thumbnail_gif_url',
         'thumbnail_url': 'thumbnail_url',
         'type': 'type',
         'uid': 'uid',
         'url': 'url',
         'user_elemental_id': 'user_elemental_id',
         'width': 'width'
     }
 
-    def __init__(self, attributes=None, codec=None, elemental_id=None, fps=None, gid=None, height=None, md5=None, name=None, num_frames=None, reference_only=0, section=None, summary_level=None, thumbnail_gif_url=None, thumbnail_url=None, type=None, uid=None, url=None, user_elemental_id=None, width=None, local_vars_configuration=None):  # noqa: E501
+    def __init__(self, attributes=None, codec=None, elemental_id=None, fps=None, gid=None, height=None, md5=None, name=None, num_frames=None, reference_only=0, section=None, section_id=None, summary_level=None, thumbnail_gif_url=None, thumbnail_url=None, type=None, uid=None, url=None, user_elemental_id=None, width=None, local_vars_configuration=None):  # noqa: E501
         """MediaSpec - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration()
         self.local_vars_configuration = local_vars_configuration
 
         self._attributes = None
         self._codec = None
@@ -86,14 +88,15 @@
         self._gid = None
         self._height = None
         self._md5 = None
         self._name = None
         self._num_frames = None
         self._reference_only = None
         self._section = None
+        self._section_id = None
         self._summary_level = None
         self._thumbnail_gif_url = None
         self._thumbnail_url = None
         self._type = None
         self._uid = None
         self._url = None
         self._user_elemental_id = None
@@ -109,15 +112,18 @@
             self.gid = gid
         self.height = height
         self.md5 = md5
         self.name = name
         self.num_frames = num_frames
         if reference_only is not None:
             self.reference_only = reference_only
-        self.section = section
+        if section is not None:
+            self.section = section
+        if section_id is not None:
+            self.section_id = section_id
         if summary_level is not None:
             self.summary_level = summary_level
         if thumbnail_gif_url is not None:
             self.thumbnail_gif_url = thumbnail_gif_url
         if thumbnail_url is not None:
             self.thumbnail_url = thumbnail_url
         self.type = type
@@ -360,20 +366,39 @@
     def section(self, section):
         """
         Media section name.
 
         :param section: The section of this MediaSpec.
         :type: str
         """
-        if self.local_vars_configuration.client_side_validation and section is None:  # noqa: E501
-            raise ValueError("Invalid value for `section`, must not be `None`")  # noqa: E501
 
         self._section = section
 
     @property
+    def section_id(self):
+        """
+        Media section ID. If given `section` is ignored.
+
+        :return: The section_id of this MediaSpec. 
+        :rtype: int
+        """
+        return self._section_id
+
+    @section_id.setter
+    def section_id(self, section_id):
+        """
+        Media section ID. If given `section` is ignored.
+
+        :param section_id: The section_id of this MediaSpec.
+        :type: int
+        """
+
+        self._section_id = section_id
+
+    @property
     def summary_level(self):
         """
         If supplied, this video is best summarized at this frame interval
 
         :return: The summary_level of this MediaSpec. 
         :rtype: int
         """
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/media_stats.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/media_stats.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/media_type.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/media_type.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/media_type_spec.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/media_type_spec.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/media_type_update.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/media_type_update.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/media_update.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/media_update.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/membership.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/membership.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/membership_spec.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/membership_spec.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/membership_update.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/membership_update.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/message_response.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/message_response.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/multi_definition.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/multi_definition.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/not_found_response.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/not_found_response.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/notify_spec.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/notify_spec.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/organization.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/organization.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/organization_spec.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/organization_spec.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/organization_update.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/organization_update.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/password_reset_spec.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/password_reset_spec.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/project.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/project.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/project_spec.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/project_spec.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/project_update.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/project_update.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/resolution_config.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/resolution_config.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/s3_storage_config.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/s3_storage_config.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/section.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/section.py`

 * *Files 18% similar despite different names*

```diff
@@ -26,57 +26,81 @@
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
+        'attributes': 'dict(str, object)',
+        'created_by': 'int',
+        'created_datetime': 'datetime',
         'elemental_id': 'str',
+        'explicit_listing': 'bool',
         'id': 'int',
+        'media': 'list[int]',
         'name': 'str',
         'object_search': 'AttributeOperationSpec',
         'path': 'str',
         'project': 'int',
         'related_search': 'AttributeOperationSpec',
         'tator_user_sections': 'str',
         'visible': 'bool'
     }
 
     attribute_map = {
+        'attributes': 'attributes',
+        'created_by': 'created_by',
+        'created_datetime': 'created_datetime',
         'elemental_id': 'elemental_id',
+        'explicit_listing': 'explicit_listing',
         'id': 'id',
+        'media': 'media',
         'name': 'name',
         'object_search': 'object_search',
         'path': 'path',
         'project': 'project',
         'related_search': 'related_search',
         'tator_user_sections': 'tator_user_sections',
         'visible': 'visible'
     }
 
-    def __init__(self, elemental_id=None, id=None, name=None, object_search=None, path=None, project=None, related_search=None, tator_user_sections=None, visible=None, local_vars_configuration=None):  # noqa: E501
+    def __init__(self, attributes=None, created_by=None, created_datetime=None, elemental_id=None, explicit_listing=None, id=None, media=None, name=None, object_search=None, path=None, project=None, related_search=None, tator_user_sections=None, visible=None, local_vars_configuration=None):  # noqa: E501
         """Section - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration()
         self.local_vars_configuration = local_vars_configuration
 
+        self._attributes = None
+        self._created_by = None
+        self._created_datetime = None
         self._elemental_id = None
+        self._explicit_listing = None
         self._id = None
+        self._media = None
         self._name = None
         self._object_search = None
         self._path = None
         self._project = None
         self._related_search = None
         self._tator_user_sections = None
         self._visible = None
         self.discriminator = None
 
+        if attributes is not None:
+            self.attributes = attributes
+        if created_by is not None:
+            self.created_by = created_by
+        self.created_datetime = created_datetime
         self.elemental_id = elemental_id
+        if explicit_listing is not None:
+            self.explicit_listing = explicit_listing
         if id is not None:
             self.id = id
+        if media is not None:
+            self.media = media
         if name is not None:
             self.name = name
         if object_search is not None:
             self.object_search = object_search
         self.path = path
         if project is not None:
             self.project = project
@@ -84,14 +108,77 @@
             self.related_search = related_search
         if tator_user_sections is not None:
             self.tator_user_sections = tator_user_sections
         if visible is not None:
             self.visible = visible
 
     @property
+    def attributes(self):
+        """
+        Object containing attribute values.
+
+        :return: The attributes of this Section. 
+        :rtype: dict(str, object)
+        """
+        return self._attributes
+
+    @attributes.setter
+    def attributes(self, attributes):
+        """
+        Object containing attribute values.
+
+        :param attributes: The attributes of this Section.
+        :type: dict(str, object)
+        """
+
+        self._attributes = attributes
+
+    @property
+    def created_by(self):
+        """
+        Unique integer identifying the user who created this localization.
+
+        :return: The created_by of this Section. 
+        :rtype: int
+        """
+        return self._created_by
+
+    @created_by.setter
+    def created_by(self, created_by):
+        """
+        Unique integer identifying the user who created this localization.
+
+        :param created_by: The created_by of this Section.
+        :type: int
+        """
+
+        self._created_by = created_by
+
+    @property
+    def created_datetime(self):
+        """
+        The elemental ID of the object.
+
+        :return: The created_datetime of this Section. 
+        :rtype: datetime
+        """
+        return self._created_datetime
+
+    @created_datetime.setter
+    def created_datetime(self, created_datetime):
+        """
+        The elemental ID of the object.
+
+        :param created_datetime: The created_datetime of this Section.
+        :type: datetime
+        """
+
+        self._created_datetime = created_datetime
+
+    @property
     def elemental_id(self):
         """
         The elemental ID of the object.
 
         :return: The elemental_id of this Section. 
         :rtype: str
         """
@@ -105,14 +192,35 @@
         :param elemental_id: The elemental_id of this Section.
         :type: str
         """
 
         self._elemental_id = elemental_id
 
     @property
+    def explicit_listing(self):
+        """
+        Determines whether the section is explicitly made up of media IDs.
+
+        :return: The explicit_listing of this Section. 
+        :rtype: bool
+        """
+        return self._explicit_listing
+
+    @explicit_listing.setter
+    def explicit_listing(self, explicit_listing):
+        """
+        Determines whether the section is explicitly made up of media IDs.
+
+        :param explicit_listing: The explicit_listing of this Section.
+        :type: bool
+        """
+
+        self._explicit_listing = explicit_listing
+
+    @property
     def id(self):
         """
         Unique integer identifying the section.
 
         :return: The id of this Section. 
         :rtype: int
         """
@@ -126,14 +234,35 @@
         :param id: The id of this Section.
         :type: int
         """
 
         self._id = id
 
     @property
+    def media(self):
+        """
+        List of media IDs that belong in this section.
+
+        :return: The media of this Section. 
+        :rtype: list[int]
+        """
+        return self._media
+
+    @media.setter
+    def media(self, media):
+        """
+        List of media IDs that belong in this section.
+
+        :param media: The media of this Section.
+        :type: list[int]
+        """
+
+        self._media = media
+
+    @property
     def name(self):
         """
         Unique name of the section.
 
         :return: The name of this Section. 
         :rtype: str
         """
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/section_spec.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/section_spec.py`

 * *Files 22% similar despite different names*

```diff
@@ -26,61 +26,97 @@
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
+        'attributes': 'dict(str, object)',
         'elemental_id': 'str',
+        'explicit_listing': 'bool',
+        'media': 'list[int]',
         'name': 'str',
         'object_search': 'AttributeOperationSpec',
         'path': 'str',
         'related_search': 'AttributeOperationSpec',
         'tator_user_sections': 'str',
         'visible': 'bool'
     }
 
     attribute_map = {
+        'attributes': 'attributes',
         'elemental_id': 'elemental_id',
+        'explicit_listing': 'explicit_listing',
+        'media': 'media',
         'name': 'name',
         'object_search': 'object_search',
         'path': 'path',
         'related_search': 'related_search',
         'tator_user_sections': 'tator_user_sections',
         'visible': 'visible'
     }
 
-    def __init__(self, elemental_id=None, name=None, object_search=None, path=None, related_search=None, tator_user_sections=None, visible=None, local_vars_configuration=None):  # noqa: E501
+    def __init__(self, attributes=None, elemental_id=None, explicit_listing=None, media=None, name=None, object_search=None, path=None, related_search=None, tator_user_sections=None, visible=None, local_vars_configuration=None):  # noqa: E501
         """SectionSpec - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration()
         self.local_vars_configuration = local_vars_configuration
 
+        self._attributes = None
         self._elemental_id = None
+        self._explicit_listing = None
+        self._media = None
         self._name = None
         self._object_search = None
         self._path = None
         self._related_search = None
         self._tator_user_sections = None
         self._visible = None
         self.discriminator = None
 
+        if attributes is not None:
+            self.attributes = attributes
         self.elemental_id = elemental_id
+        if explicit_listing is not None:
+            self.explicit_listing = explicit_listing
+        if media is not None:
+            self.media = media
         self.name = name
         if object_search is not None:
             self.object_search = object_search
         self.path = path
         if related_search is not None:
             self.related_search = related_search
         if tator_user_sections is not None:
             self.tator_user_sections = tator_user_sections
         if visible is not None:
             self.visible = visible
 
     @property
+    def attributes(self):
+        """
+        Object containing attribute values.
+
+        :return: The attributes of this SectionSpec. 
+        :rtype: dict(str, object)
+        """
+        return self._attributes
+
+    @attributes.setter
+    def attributes(self, attributes):
+        """
+        Object containing attribute values.
+
+        :param attributes: The attributes of this SectionSpec.
+        :type: dict(str, object)
+        """
+
+        self._attributes = attributes
+
+    @property
     def elemental_id(self):
         """
         The elemental ID of the object.
 
         :return: The elemental_id of this SectionSpec. 
         :rtype: str
         """
@@ -94,14 +130,56 @@
         :param elemental_id: The elemental_id of this SectionSpec.
         :type: str
         """
 
         self._elemental_id = elemental_id
 
     @property
+    def explicit_listing(self):
+        """
+        Determines whether the section is explicitly made up of media IDs.
+
+        :return: The explicit_listing of this SectionSpec. 
+        :rtype: bool
+        """
+        return self._explicit_listing
+
+    @explicit_listing.setter
+    def explicit_listing(self, explicit_listing):
+        """
+        Determines whether the section is explicitly made up of media IDs.
+
+        :param explicit_listing: The explicit_listing of this SectionSpec.
+        :type: bool
+        """
+
+        self._explicit_listing = explicit_listing
+
+    @property
+    def media(self):
+        """
+        List of mediia IDs that this state applies to (if explicit_listing is True)
+
+        :return: The media of this SectionSpec. 
+        :rtype: list[int]
+        """
+        return self._media
+
+    @media.setter
+    def media(self, media):
+        """
+        List of mediia IDs that this state applies to (if explicit_listing is True)
+
+        :param media: The media of this SectionSpec.
+        :type: list[int]
+        """
+
+        self._media = media
+
+    @property
     def name(self):
         """
         Unique name of the section.
 
         :return: The name of this SectionSpec. 
         :rtype: str
         """
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/section_update.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/applet_spec.py`

 * *Files 21% similar despite different names*

```diff
@@ -14,215 +14,220 @@
 import re  # noqa: F401
 
 import six
 
 from ..configuration import Configuration
 
 
-class SectionUpdate(object):
+class AppletSpec(object):
     """
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
-        'elemental_id': 'str',
+        'categories': 'list[str]',
+        'description': 'str',
+        'headers': 'list[Parameter]',
+        'html_file': 'str',
         'name': 'str',
-        'object_search': 'AttributeOperationSpec',
-        'path': 'str',
-        'related_search': 'AttributeOperationSpec',
-        'tator_user_sections': 'str',
-        'visible': 'bool'
+        'template': 'int',
+        'tparams': 'list[Parameter]'
     }
 
     attribute_map = {
-        'elemental_id': 'elemental_id',
+        'categories': 'categories',
+        'description': 'description',
+        'headers': 'headers',
+        'html_file': 'html_file',
         'name': 'name',
-        'object_search': 'object_search',
-        'path': 'path',
-        'related_search': 'related_search',
-        'tator_user_sections': 'tator_user_sections',
-        'visible': 'visible'
+        'template': 'template',
+        'tparams': 'tparams'
     }
 
-    def __init__(self, elemental_id=None, name=None, object_search=None, path=None, related_search=None, tator_user_sections=None, visible=None, local_vars_configuration=None):  # noqa: E501
-        """SectionUpdate - a model defined in OpenAPI"""
+    def __init__(self, categories=None, description=None, headers=[], html_file=None, name=None, template=None, tparams=[], local_vars_configuration=None):  # noqa: E501
+        """AppletSpec - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration()
         self.local_vars_configuration = local_vars_configuration
 
-        self._elemental_id = None
+        self._categories = None
+        self._description = None
+        self._headers = None
+        self._html_file = None
         self._name = None
-        self._object_search = None
-        self._path = None
-        self._related_search = None
-        self._tator_user_sections = None
-        self._visible = None
+        self._template = None
+        self._tparams = None
         self.discriminator = None
 
-        self.elemental_id = elemental_id
+        if categories is not None:
+            self.categories = categories
+        if description is not None:
+            self.description = description
+        if headers is not None:
+            self.headers = headers
+        if html_file is not None:
+            self.html_file = html_file
         if name is not None:
             self.name = name
-        if object_search is not None:
-            self.object_search = object_search
-        self.path = path
-        if related_search is not None:
-            self.related_search = related_search
-        if tator_user_sections is not None:
-            self.tator_user_sections = tator_user_sections
-        if visible is not None:
-            self.visible = visible
+        self.template = template
+        if tparams is not None:
+            self.tparams = tparams
 
     @property
-    def elemental_id(self):
+    def categories(self):
         """
-        The elemental ID of the object.
+        List of categories the applet belongs to
 
-        :return: The elemental_id of this SectionUpdate. 
-        :rtype: str
+        :return: The categories of this AppletSpec. 
+        :rtype: list[str]
         """
-        return self._elemental_id
+        return self._categories
 
-    @elemental_id.setter
-    def elemental_id(self, elemental_id):
+    @categories.setter
+    def categories(self, categories):
         """
-        The elemental ID of the object.
+        List of categories the applet belongs to
 
-        :param elemental_id: The elemental_id of this SectionUpdate.
-        :type: str
+        :param categories: The categories of this AppletSpec.
+        :type: list[str]
         """
 
-        self._elemental_id = elemental_id
+        self._categories = categories
 
     @property
-    def name(self):
+    def description(self):
         """
-        Unique name of the section.
+        Description of applet
 
-        :return: The name of this SectionUpdate. 
+        :return: The description of this AppletSpec. 
         :rtype: str
         """
-        return self._name
+        return self._description
 
-    @name.setter
-    def name(self, name):
+    @description.setter
+    def description(self, description):
         """
-        Unique name of the section.
+        Description of applet
 
-        :param name: The name of this SectionUpdate.
+        :param description: The description of this AppletSpec.
         :type: str
         """
 
-        self._name = name
+        self._description = description
 
     @property
-    def object_search(self):
+    def headers(self):
         """
+        Headers used to retrieve hosted template, if set.
 
-        :return: The object_search of this SectionUpdate. 
-        :rtype: AttributeOperationSpec
+        :return: The headers of this AppletSpec. 
+        :rtype: list[Parameter]
         """
-        return self._object_search
+        return self._headers
 
-    @object_search.setter
-    def object_search(self, object_search):
+    @headers.setter
+    def headers(self, headers):
         """
+        Headers used to retrieve hosted template, if set.
 
-        :param object_search: The object_search of this SectionUpdate.
-        :type: AttributeOperationSpec
+        :param headers: The headers of this AppletSpec.
+        :type: list[Parameter]
         """
 
-        self._object_search = object_search
+        self._headers = headers
 
     @property
-    def path(self):
+    def html_file(self):
         """
-        A path to represent nested sections. If not supplied, defaults to `re.sub(r'[^A-Za-z0-9_-]',path)`
+        Server URL to applet HTML file
 
-        :return: The path of this SectionUpdate. 
+        :return: The html_file of this AppletSpec. 
         :rtype: str
         """
-        return self._path
+        return self._html_file
 
-    @path.setter
-    def path(self, path):
+    @html_file.setter
+    def html_file(self, html_file):
         """
-        A path to represent nested sections. If not supplied, defaults to `re.sub(r'[^A-Za-z0-9_-]',path)`
+        Server URL to applet HTML file
 
-        :param path: The path of this SectionUpdate.
+        :param html_file: The html_file of this AppletSpec.
         :type: str
         """
 
-        self._path = path
+        self._html_file = html_file
 
     @property
-    def related_search(self):
+    def name(self):
         """
+        Name of applet
 
-        :return: The related_search of this SectionUpdate. 
-        :rtype: AttributeOperationSpec
+        :return: The name of this AppletSpec. 
+        :rtype: str
         """
-        return self._related_search
+        return self._name
 
-    @related_search.setter
-    def related_search(self, related_search):
+    @name.setter
+    def name(self, name):
         """
+        Name of applet
 
-        :param related_search: The related_search of this SectionUpdate.
-        :type: AttributeOperationSpec
+        :param name: The name of this AppletSpec.
+        :type: str
         """
 
-        self._related_search = related_search
+        self._name = name
 
     @property
-    def tator_user_sections(self):
+    def template(self):
         """
-        Attribute that is applied to media to identify membership to a section.
+        Unique integer identifying a hosted template. If set, `html_file` is ignored.
 
-        :return: The tator_user_sections of this SectionUpdate. 
-        :rtype: str
+        :return: The template of this AppletSpec. 
+        :rtype: int
         """
-        return self._tator_user_sections
+        return self._template
 
-    @tator_user_sections.setter
-    def tator_user_sections(self, tator_user_sections):
+    @template.setter
+    def template(self, template):
         """
-        Attribute that is applied to media to identify membership to a section.
+        Unique integer identifying a hosted template. If set, `html_file` is ignored.
 
-        :param tator_user_sections: The tator_user_sections of this SectionUpdate.
-        :type: str
+        :param template: The template of this AppletSpec.
+        :type: int
         """
 
-        self._tator_user_sections = tator_user_sections
+        self._template = template
 
     @property
-    def visible(self):
+    def tparams(self):
         """
-        Determines the visibility in the UI.
+        Template parameters used for rendering hosted template, if set.
 
-        :return: The visible of this SectionUpdate. 
-        :rtype: bool
+        :return: The tparams of this AppletSpec. 
+        :rtype: list[Parameter]
         """
-        return self._visible
+        return self._tparams
 
-    @visible.setter
-    def visible(self, visible):
+    @tparams.setter
+    def tparams(self, tparams):
         """
-        Determines the visibility in the UI.
+        Template parameters used for rendering hosted template, if set.
 
-        :param visible: The visible of this SectionUpdate.
-        :type: bool
+        :param tparams: The tparams of this AppletSpec.
+        :type: list[Parameter]
         """
 
-        self._visible = visible
+        self._tparams = tparams
 
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.openapi_types):
             value = getattr(self, attr)
@@ -250,18 +255,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, SectionUpdate):
+        if not isinstance(other, AppletSpec):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, SectionUpdate):
+        if not isinstance(other, AppletSpec):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/state.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/state.py`

 * *Files 3% similar despite different names*

```diff
@@ -33,14 +33,15 @@
         'attributes': 'dict(str, object)',
         'created_by': 'int',
         'created_datetime': 'datetime',
         'elemental_id': 'str',
         'frame': 'int',
         'id': 'int',
         'localizations': 'list[int]',
+        'mark': 'int',
         'media': 'list[int]',
         'modified_by': 'int',
         'modified_datetime': 'datetime',
         'parent': 'float',
         'segments': 'list[list[int]]',
         'type': 'int',
         'variant_deleted': 'bool',
@@ -51,37 +52,39 @@
         'attributes': 'attributes',
         'created_by': 'created_by',
         'created_datetime': 'created_datetime',
         'elemental_id': 'elemental_id',
         'frame': 'frame',
         'id': 'id',
         'localizations': 'localizations',
+        'mark': 'mark',
         'media': 'media',
         'modified_by': 'modified_by',
         'modified_datetime': 'modified_datetime',
         'parent': 'parent',
         'segments': 'segments',
         'type': 'type',
         'variant_deleted': 'variant_deleted',
         'version': 'version'
     }
 
-    def __init__(self, attributes=None, created_by=None, created_datetime=None, elemental_id=None, frame=None, id=None, localizations=None, media=None, modified_by=None, modified_datetime=None, parent=None, segments=None, type=None, variant_deleted=None, version=None, local_vars_configuration=None):  # noqa: E501
+    def __init__(self, attributes=None, created_by=None, created_datetime=None, elemental_id=None, frame=None, id=None, localizations=None, mark=None, media=None, modified_by=None, modified_datetime=None, parent=None, segments=None, type=None, variant_deleted=None, version=None, local_vars_configuration=None):  # noqa: E501
         """State - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration()
         self.local_vars_configuration = local_vars_configuration
 
         self._attributes = None
         self._created_by = None
         self._created_datetime = None
         self._elemental_id = None
         self._frame = None
         self._id = None
         self._localizations = None
+        self._mark = None
         self._media = None
         self._modified_by = None
         self._modified_datetime = None
         self._parent = None
         self._segments = None
         self._type = None
         self._variant_deleted = None
@@ -97,14 +100,16 @@
         self.elemental_id = elemental_id
         if frame is not None:
             self.frame = frame
         if id is not None:
             self.id = id
         if localizations is not None:
             self.localizations = localizations
+        if mark is not None:
+            self.mark = mark
         if media is not None:
             self.media = media
         if modified_by is not None:
             self.modified_by = modified_by
         if modified_datetime is not None:
             self.modified_datetime = modified_datetime
         self.parent = parent
@@ -261,14 +266,35 @@
         :param localizations: The localizations of this State.
         :type: list[int]
         """
 
         self._localizations = localizations
 
     @property
+    def mark(self):
+        """
+        Revision number of this object on this version branch
+
+        :return: The mark of this State. 
+        :rtype: int
+        """
+        return self._mark
+
+    @mark.setter
+    def mark(self, mark):
+        """
+        Revision number of this object on this version branch
+
+        :param mark: The mark of this State.
+        :type: int
+        """
+
+        self._mark = mark
+
+    @property
     def media(self):
         """
         List of media IDs that this state applies to.
 
         :return: The media of this State. 
         :rtype: list[int]
         """
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/state_bulk_delete.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/localization_id_query.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,225 +14,245 @@
 import re  # noqa: F401
 
 import six
 
 from ..configuration import Configuration
 
 
-class StateBulkDelete(object):
+class LocalizationIdQuery(object):
     """
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
+        'elemental_ids': 'list[str]',
         'float_array': 'list[FloatArrayQuery]',
+        'frame_state_ids': 'list[int]',
         'ids': 'list[int]',
-        'localization_ids': 'list[int]',
         'media_ids': 'list[int]',
         'media_query': 'str',
         'object_search': 'AttributeOperationSpec',
-        'prune': 'int'
+        'state_ids': 'list[int]'
     }
 
     attribute_map = {
+        'elemental_ids': 'elemental_ids',
         'float_array': 'float_array',
+        'frame_state_ids': 'frame_state_ids',
         'ids': 'ids',
-        'localization_ids': 'localization_ids',
         'media_ids': 'media_ids',
         'media_query': 'media_query',
         'object_search': 'object_search',
-        'prune': 'prune'
+        'state_ids': 'state_ids'
     }
 
-    def __init__(self, float_array=None, ids=None, localization_ids=None, media_ids=None, media_query=None, object_search=None, prune=0, local_vars_configuration=None):  # noqa: E501
-        """StateBulkDelete - a model defined in OpenAPI"""
+    def __init__(self, elemental_ids=None, float_array=None, frame_state_ids=None, ids=None, media_ids=None, media_query=None, object_search=None, state_ids=None, local_vars_configuration=None):  # noqa: E501
+        """LocalizationIdQuery - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration()
         self.local_vars_configuration = local_vars_configuration
 
+        self._elemental_ids = None
         self._float_array = None
+        self._frame_state_ids = None
         self._ids = None
-        self._localization_ids = None
         self._media_ids = None
         self._media_query = None
         self._object_search = None
-        self._prune = None
+        self._state_ids = None
         self.discriminator = None
 
+        if elemental_ids is not None:
+            self.elemental_ids = elemental_ids
         if float_array is not None:
             self.float_array = float_array
+        if frame_state_ids is not None:
+            self.frame_state_ids = frame_state_ids
         if ids is not None:
             self.ids = ids
-        if localization_ids is not None:
-            self.localization_ids = localization_ids
         if media_ids is not None:
             self.media_ids = media_ids
         if media_query is not None:
             self.media_query = media_query
         if object_search is not None:
             self.object_search = object_search
-        if prune is not None:
-            self.prune = prune
+        if state_ids is not None:
+            self.state_ids = state_ids
+
+    @property
+    def elemental_ids(self):
+        """
+        Array of localizations to retrieve.
+
+        :return: The elemental_ids of this LocalizationIdQuery. 
+        :rtype: list[str]
+        """
+        return self._elemental_ids
+
+    @elemental_ids.setter
+    def elemental_ids(self, elemental_ids):
+        """
+        Array of localizations to retrieve.
+
+        :param elemental_ids: The elemental_ids of this LocalizationIdQuery.
+        :type: list[str]
+        """
+
+        self._elemental_ids = elemental_ids
 
     @property
     def float_array(self):
         """
         Searches on `float_array` attributes.
 
-        :return: The float_array of this StateBulkDelete. 
+        :return: The float_array of this LocalizationIdQuery. 
         :rtype: list[FloatArrayQuery]
         """
         return self._float_array
 
     @float_array.setter
     def float_array(self, float_array):
         """
         Searches on `float_array` attributes.
 
-        :param float_array: The float_array of this StateBulkDelete.
+        :param float_array: The float_array of this LocalizationIdQuery.
         :type: list[FloatArrayQuery]
         """
 
         self._float_array = float_array
 
     @property
-    def ids(self):
+    def frame_state_ids(self):
         """
-        Array of state IDs to retrieve.
+        Array of frame state IDs for which localizations present in the same media/frame will be retrieved.
 
-        :return: The ids of this StateBulkDelete. 
+        :return: The frame_state_ids of this LocalizationIdQuery. 
         :rtype: list[int]
         """
-        return self._ids
+        return self._frame_state_ids
 
-    @ids.setter
-    def ids(self, ids):
+    @frame_state_ids.setter
+    def frame_state_ids(self, frame_state_ids):
         """
-        Array of state IDs to retrieve.
+        Array of frame state IDs for which localizations present in the same media/frame will be retrieved.
 
-        :param ids: The ids of this StateBulkDelete.
+        :param frame_state_ids: The frame_state_ids of this LocalizationIdQuery.
         :type: list[int]
         """
 
-        self._ids = ids
+        self._frame_state_ids = frame_state_ids
 
     @property
-    def localization_ids(self):
+    def ids(self):
         """
-        Array of child localization IDs for which states should be retrieved.
+        Array of localization IDs to retrieve.
 
-        :return: The localization_ids of this StateBulkDelete. 
+        :return: The ids of this LocalizationIdQuery. 
         :rtype: list[int]
         """
-        return self._localization_ids
+        return self._ids
 
-    @localization_ids.setter
-    def localization_ids(self, localization_ids):
+    @ids.setter
+    def ids(self, ids):
         """
-        Array of child localization IDs for which states should be retrieved.
+        Array of localization IDs to retrieve.
 
-        :param localization_ids: The localization_ids of this StateBulkDelete.
+        :param ids: The ids of this LocalizationIdQuery.
         :type: list[int]
         """
 
-        self._localization_ids = localization_ids
+        self._ids = ids
 
     @property
     def media_ids(self):
         """
-        Array of parent media IDs for which states should be retrieved.
+        Array of parent media IDs for which localizations should be retrieved.
 
-        :return: The media_ids of this StateBulkDelete. 
+        :return: The media_ids of this LocalizationIdQuery. 
         :rtype: list[int]
         """
         return self._media_ids
 
     @media_ids.setter
     def media_ids(self, media_ids):
         """
-        Array of parent media IDs for which states should be retrieved.
+        Array of parent media IDs for which localizations should be retrieved.
 
-        :param media_ids: The media_ids of this StateBulkDelete.
+        :param media_ids: The media_ids of this LocalizationIdQuery.
         :type: list[int]
         """
 
         self._media_ids = media_ids
 
     @property
     def media_query(self):
         """
         Query string used to filter media IDs. This can be used to avoid serialization and download of a media ID list.
 
-        :return: The media_query of this StateBulkDelete. 
+        :return: The media_query of this LocalizationIdQuery. 
         :rtype: str
         """
         return self._media_query
 
     @media_query.setter
     def media_query(self, media_query):
         """
         Query string used to filter media IDs. This can be used to avoid serialization and download of a media ID list.
 
-        :param media_query: The media_query of this StateBulkDelete.
+        :param media_query: The media_query of this LocalizationIdQuery.
         :type: str
         """
 
         self._media_query = media_query
 
     @property
     def object_search(self):
         """
 
-        :return: The object_search of this StateBulkDelete. 
+        :return: The object_search of this LocalizationIdQuery. 
         :rtype: AttributeOperationSpec
         """
         return self._object_search
 
     @object_search.setter
     def object_search(self, object_search):
         """
 
-        :param object_search: The object_search of this StateBulkDelete.
+        :param object_search: The object_search of this LocalizationIdQuery.
         :type: AttributeOperationSpec
         """
 
         self._object_search = object_search
 
     @property
-    def prune(self):
+    def state_ids(self):
         """
-        If set to 1 will purge the object from the database entirely. This removes any record, change-log, that this metadatum ever existed.
+        Array of parent localization state (track) IDs for which localizations should be retrieved.
 
-        :return: The prune of this StateBulkDelete. 
-        :rtype: int
+        :return: The state_ids of this LocalizationIdQuery. 
+        :rtype: list[int]
         """
-        return self._prune
+        return self._state_ids
 
-    @prune.setter
-    def prune(self, prune):
+    @state_ids.setter
+    def state_ids(self, state_ids):
         """
-        If set to 1 will purge the object from the database entirely. This removes any record, change-log, that this metadatum ever existed.
+        Array of parent localization state (track) IDs for which localizations should be retrieved.
 
-        :param prune: The prune of this StateBulkDelete.
-        :type: int
+        :param state_ids: The state_ids of this LocalizationIdQuery.
+        :type: list[int]
         """
-        if (self.local_vars_configuration.client_side_validation and
-                prune is not None and prune > 1):  # noqa: E501
-            raise ValueError("Invalid value for `prune`, must be a value less than or equal to `1`")  # noqa: E501
-        if (self.local_vars_configuration.client_side_validation and
-                prune is not None and prune < 0):  # noqa: E501
-            raise ValueError("Invalid value for `prune`, must be a value greater than or equal to `0`")  # noqa: E501
 
-        self._prune = prune
+        self._state_ids = state_ids
 
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.openapi_types):
             value = getattr(self, attr)
@@ -260,18 +280,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, StateBulkDelete):
+        if not isinstance(other, LocalizationIdQuery):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, StateBulkDelete):
+        if not isinstance(other, LocalizationIdQuery):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/state_bulk_update.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/state_bulk_update.py`

 * *Files 7% similar despite different names*

```diff
@@ -29,14 +29,15 @@
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
         'attributes': 'dict(str, object)',
         'float_array': 'list[FloatArrayQuery]',
         'ids': 'list[int]',
+        'in_place': 'int',
         'localization_ids': 'list[int]',
         'media_ids': 'list[int]',
         'media_query': 'str',
         'new_elemental_id': 'str',
         'new_version': 'int',
         'null_attributes': 'list[str]',
         'object_search': 'AttributeOperationSpec',
@@ -44,34 +45,36 @@
         'user_elemental_id': 'str'
     }
 
     attribute_map = {
         'attributes': 'attributes',
         'float_array': 'float_array',
         'ids': 'ids',
+        'in_place': 'in_place',
         'localization_ids': 'localization_ids',
         'media_ids': 'media_ids',
         'media_query': 'media_query',
         'new_elemental_id': 'new_elemental_id',
         'new_version': 'new_version',
         'null_attributes': 'null_attributes',
         'object_search': 'object_search',
         'reset_attributes': 'reset_attributes',
         'user_elemental_id': 'user_elemental_id'
     }
 
-    def __init__(self, attributes=None, float_array=None, ids=None, localization_ids=None, media_ids=None, media_query=None, new_elemental_id=None, new_version=None, null_attributes=None, object_search=None, reset_attributes=None, user_elemental_id=None, local_vars_configuration=None):  # noqa: E501
+    def __init__(self, attributes=None, float_array=None, ids=None, in_place=0, localization_ids=None, media_ids=None, media_query=None, new_elemental_id=None, new_version=None, null_attributes=None, object_search=None, reset_attributes=None, user_elemental_id=None, local_vars_configuration=None):  # noqa: E501
         """StateBulkUpdate - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration()
         self.local_vars_configuration = local_vars_configuration
 
         self._attributes = None
         self._float_array = None
         self._ids = None
+        self._in_place = None
         self._localization_ids = None
         self._media_ids = None
         self._media_query = None
         self._new_elemental_id = None
         self._new_version = None
         self._null_attributes = None
         self._object_search = None
@@ -81,14 +84,16 @@
 
         if attributes is not None:
             self.attributes = attributes
         if float_array is not None:
             self.float_array = float_array
         if ids is not None:
             self.ids = ids
+        if in_place is not None:
+            self.in_place = in_place
         if localization_ids is not None:
             self.localization_ids = localization_ids
         if media_ids is not None:
             self.media_ids = media_ids
         if media_query is not None:
             self.media_query = media_query
         if new_elemental_id is not None:
@@ -164,14 +169,41 @@
         :param ids: The ids of this StateBulkUpdate.
         :type: list[int]
         """
 
         self._ids = ids
 
     @property
+    def in_place(self):
+        """
+        Set to 1 to edit this record in-place, else mark-based versioning rules apply. This changes to 1 for authorship changes automatically.
+
+        :return: The in_place of this StateBulkUpdate. 
+        :rtype: int
+        """
+        return self._in_place
+
+    @in_place.setter
+    def in_place(self, in_place):
+        """
+        Set to 1 to edit this record in-place, else mark-based versioning rules apply. This changes to 1 for authorship changes automatically.
+
+        :param in_place: The in_place of this StateBulkUpdate.
+        :type: int
+        """
+        if (self.local_vars_configuration.client_side_validation and
+                in_place is not None and in_place > 1):  # noqa: E501
+            raise ValueError("Invalid value for `in_place`, must be a value less than or equal to `1`")  # noqa: E501
+        if (self.local_vars_configuration.client_side_validation and
+                in_place is not None and in_place < 0):  # noqa: E501
+            raise ValueError("Invalid value for `in_place`, must be a value greater than or equal to `0`")  # noqa: E501
+
+        self._in_place = in_place
+
+    @property
     def localization_ids(self):
         """
         Array of child localization IDs for which states should be retrieved.
 
         :return: The localization_ids of this StateBulkUpdate. 
         :rtype: list[int]
         """
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/state_delete.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/state_delete.py`

 * *Files 22% similar despite different names*

```diff
@@ -26,34 +26,66 @@
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
+        'pedantic': 'int',
         'prune': 'int'
     }
 
     attribute_map = {
+        'pedantic': 'pedantic',
         'prune': 'prune'
     }
 
-    def __init__(self, prune=0, local_vars_configuration=None):  # noqa: E501
+    def __init__(self, pedantic=0, prune=0, local_vars_configuration=None):  # noqa: E501
         """StateDelete - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration()
         self.local_vars_configuration = local_vars_configuration
 
+        self._pedantic = None
         self._prune = None
         self.discriminator = None
 
+        if pedantic is not None:
+            self.pedantic = pedantic
         if prune is not None:
             self.prune = prune
 
     @property
+    def pedantic(self):
+        """
+        Set to 1 to enforce that this is the latest mark; else push edits to end of branch.
+
+        :return: The pedantic of this StateDelete. 
+        :rtype: int
+        """
+        return self._pedantic
+
+    @pedantic.setter
+    def pedantic(self, pedantic):
+        """
+        Set to 1 to enforce that this is the latest mark; else push edits to end of branch.
+
+        :param pedantic: The pedantic of this StateDelete.
+        :type: int
+        """
+        if (self.local_vars_configuration.client_side_validation and
+                pedantic is not None and pedantic > 1):  # noqa: E501
+            raise ValueError("Invalid value for `pedantic`, must be a value less than or equal to `1`")  # noqa: E501
+        if (self.local_vars_configuration.client_side_validation and
+                pedantic is not None and pedantic < 0):  # noqa: E501
+            raise ValueError("Invalid value for `pedantic`, must be a value greater than or equal to `0`")  # noqa: E501
+
+        self._pedantic = pedantic
+
+    @property
     def prune(self):
         """
         If set to 1 will purge the object from the database entirely. This removes any record, change-log, that this metadatum ever existed.
 
         :return: The prune of this StateDelete. 
         :rtype: int
         """
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/state_id_query.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/version_update.py`

 * *Files 27% similar despite different names*

```diff
@@ -14,193 +14,169 @@
 import re  # noqa: F401
 
 import six
 
 from ..configuration import Configuration
 
 
-class StateIdQuery(object):
+class VersionUpdate(object):
     """
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
-        'float_array': 'list[FloatArrayQuery]',
-        'ids': 'list[int]',
-        'localization_ids': 'list[int]',
-        'media_ids': 'list[int]',
-        'media_query': 'str',
-        'object_search': 'AttributeOperationSpec'
+        'bases': 'list[int]',
+        'description': 'str',
+        'elemental_id': 'str',
+        'name': 'str',
+        'show_empty': 'bool'
     }
 
     attribute_map = {
-        'float_array': 'float_array',
-        'ids': 'ids',
-        'localization_ids': 'localization_ids',
-        'media_ids': 'media_ids',
-        'media_query': 'media_query',
-        'object_search': 'object_search'
+        'bases': 'bases',
+        'description': 'description',
+        'elemental_id': 'elemental_id',
+        'name': 'name',
+        'show_empty': 'show_empty'
     }
 
-    def __init__(self, float_array=None, ids=None, localization_ids=None, media_ids=None, media_query=None, object_search=None, local_vars_configuration=None):  # noqa: E501
-        """StateIdQuery - a model defined in OpenAPI"""
+    def __init__(self, bases=None, description='', elemental_id=None, name=None, show_empty=True, local_vars_configuration=None):  # noqa: E501
+        """VersionUpdate - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration()
         self.local_vars_configuration = local_vars_configuration
 
-        self._float_array = None
-        self._ids = None
-        self._localization_ids = None
-        self._media_ids = None
-        self._media_query = None
-        self._object_search = None
+        self._bases = None
+        self._description = None
+        self._elemental_id = None
+        self._name = None
+        self._show_empty = None
         self.discriminator = None
 
-        if float_array is not None:
-            self.float_array = float_array
-        if ids is not None:
-            self.ids = ids
-        if localization_ids is not None:
-            self.localization_ids = localization_ids
-        if media_ids is not None:
-            self.media_ids = media_ids
-        if media_query is not None:
-            self.media_query = media_query
-        if object_search is not None:
-            self.object_search = object_search
+        if bases is not None:
+            self.bases = bases
+        if description is not None:
+            self.description = description
+        if elemental_id is not None:
+            self.elemental_id = elemental_id
+        if name is not None:
+            self.name = name
+        if show_empty is not None:
+            self.show_empty = show_empty
 
     @property
-    def float_array(self):
+    def bases(self):
         """
-        Searches on `float_array` attributes.
+        Array of other version IDs that are dependencies of this version.
 
-        :return: The float_array of this StateIdQuery. 
-        :rtype: list[FloatArrayQuery]
-        """
-        return self._float_array
-
-    @float_array.setter
-    def float_array(self, float_array):
-        """
-        Searches on `float_array` attributes.
-
-        :param float_array: The float_array of this StateIdQuery.
-        :type: list[FloatArrayQuery]
-        """
-
-        self._float_array = float_array
-
-    @property
-    def ids(self):
-        """
-        Array of state IDs to retrieve.
-
-        :return: The ids of this StateIdQuery. 
+        :return: The bases of this VersionUpdate. 
         :rtype: list[int]
         """
-        return self._ids
+        return self._bases
 
-    @ids.setter
-    def ids(self, ids):
+    @bases.setter
+    def bases(self, bases):
         """
-        Array of state IDs to retrieve.
+        Array of other version IDs that are dependencies of this version.
 
-        :param ids: The ids of this StateIdQuery.
+        :param bases: The bases of this VersionUpdate.
         :type: list[int]
         """
 
-        self._ids = ids
+        self._bases = bases
 
     @property
-    def localization_ids(self):
+    def description(self):
         """
-        Array of child localization IDs for which states should be retrieved.
+        Description of the version.
 
-        :return: The localization_ids of this StateIdQuery. 
-        :rtype: list[int]
+        :return: The description of this VersionUpdate. 
+        :rtype: str
         """
-        return self._localization_ids
+        return self._description
 
-    @localization_ids.setter
-    def localization_ids(self, localization_ids):
+    @description.setter
+    def description(self, description):
         """
-        Array of child localization IDs for which states should be retrieved.
+        Description of the version.
 
-        :param localization_ids: The localization_ids of this StateIdQuery.
-        :type: list[int]
+        :param description: The description of this VersionUpdate.
+        :type: str
         """
 
-        self._localization_ids = localization_ids
+        self._description = description
 
     @property
-    def media_ids(self):
+    def elemental_id(self):
         """
-        Array of parent media IDs for which states should be retrieved.
+        Unique ID of an element
 
-        :return: The media_ids of this StateIdQuery. 
-        :rtype: list[int]
+        :return: The elemental_id of this VersionUpdate. 
+        :rtype: str
         """
-        return self._media_ids
+        return self._elemental_id
 
-    @media_ids.setter
-    def media_ids(self, media_ids):
+    @elemental_id.setter
+    def elemental_id(self, elemental_id):
         """
-        Array of parent media IDs for which states should be retrieved.
+        Unique ID of an element
 
-        :param media_ids: The media_ids of this StateIdQuery.
-        :type: list[int]
+        :param elemental_id: The elemental_id of this VersionUpdate.
+        :type: str
         """
 
-        self._media_ids = media_ids
+        self._elemental_id = elemental_id
 
     @property
-    def media_query(self):
+    def name(self):
         """
-        Query string used to filter media IDs. This can be used to avoid serialization and download of a media ID list.
+        Name of the version.
 
-        :return: The media_query of this StateIdQuery. 
+        :return: The name of this VersionUpdate. 
         :rtype: str
         """
-        return self._media_query
+        return self._name
 
-    @media_query.setter
-    def media_query(self, media_query):
+    @name.setter
+    def name(self, name):
         """
-        Query string used to filter media IDs. This can be used to avoid serialization and download of a media ID list.
+        Name of the version.
 
-        :param media_query: The media_query of this StateIdQuery.
+        :param name: The name of this VersionUpdate.
         :type: str
         """
 
-        self._media_query = media_query
+        self._name = name
 
     @property
-    def object_search(self):
+    def show_empty(self):
         """
+        Whether to show this version on media for which no annotations exist.
 
-        :return: The object_search of this StateIdQuery. 
-        :rtype: AttributeOperationSpec
+        :return: The show_empty of this VersionUpdate. 
+        :rtype: bool
         """
-        return self._object_search
+        return self._show_empty
 
-    @object_search.setter
-    def object_search(self, object_search):
+    @show_empty.setter
+    def show_empty(self, show_empty):
         """
+        Whether to show this version on media for which no annotations exist.
 
-        :param object_search: The object_search of this StateIdQuery.
-        :type: AttributeOperationSpec
+        :param show_empty: The show_empty of this VersionUpdate.
+        :type: bool
         """
 
-        self._object_search = object_search
+        self._show_empty = show_empty
 
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.openapi_types):
             value = getattr(self, attr)
@@ -228,18 +204,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, StateIdQuery):
+        if not isinstance(other, VersionUpdate):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, StateIdQuery):
+        if not isinstance(other, VersionUpdate):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/state_merge_update.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/state_merge_update.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/state_spec.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/state_spec.py`

 * *Files 4% similar despite different names*

```diff
@@ -30,57 +30,62 @@
                             and the value is json key in definition.
     """
     openapi_types = {
         'attributes': 'dict(str, object)',
         'elemental_id': 'str',
         'frame': 'int',
         'localization_ids': 'list[int]',
+        'mark': 'int',
         'media_ids': 'list[int]',
         'parent': 'float',
         'type': 'int',
         'user_elemental_id': 'str',
         'version': 'int'
     }
 
     attribute_map = {
         'attributes': 'attributes',
         'elemental_id': 'elemental_id',
         'frame': 'frame',
         'localization_ids': 'localization_ids',
+        'mark': 'mark',
         'media_ids': 'media_ids',
         'parent': 'parent',
         'type': 'type',
         'user_elemental_id': 'user_elemental_id',
         'version': 'version'
     }
 
-    def __init__(self, attributes=None, elemental_id=None, frame=None, localization_ids=None, media_ids=None, parent=None, type=None, user_elemental_id=None, version=None, local_vars_configuration=None):  # noqa: E501
+    def __init__(self, attributes=None, elemental_id=None, frame=None, localization_ids=None, mark=None, media_ids=None, parent=None, type=None, user_elemental_id=None, version=None, local_vars_configuration=None):  # noqa: E501
         """StateSpec - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration()
         self.local_vars_configuration = local_vars_configuration
 
         self._attributes = None
         self._elemental_id = None
         self._frame = None
         self._localization_ids = None
+        self._mark = None
         self._media_ids = None
         self._parent = None
         self._type = None
         self._user_elemental_id = None
         self._version = None
         self.discriminator = None
 
         if attributes is not None:
             self.attributes = attributes
         self.elemental_id = elemental_id
         if frame is not None:
             self.frame = frame
         if localization_ids is not None:
             self.localization_ids = localization_ids
+        if mark is not None:
+            self.mark = mark
         self.media_ids = media_ids
         self.parent = parent
         self.type = type
         if user_elemental_id is not None:
             self.user_elemental_id = user_elemental_id
         if version is not None:
             self.version = version
@@ -166,14 +171,35 @@
         :param localization_ids: The localization_ids of this StateSpec.
         :type: list[int]
         """
 
         self._localization_ids = localization_ids
 
     @property
+    def mark(self):
+        """
+        Revision number of this object on this version branch
+
+        :return: The mark of this StateSpec. 
+        :rtype: int
+        """
+        return self._mark
+
+    @mark.setter
+    def mark(self, mark):
+        """
+        Revision number of this object on this version branch
+
+        :param mark: The mark of this StateSpec.
+        :type: int
+        """
+
+        self._mark = mark
+
+    @property
     def media_ids(self):
         """
         List of media IDs that this state applies to.
 
         :return: The media_ids of this StateSpec. 
         :rtype: list[int]
         """
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/state_trim_update.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/state_trim_update.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/state_type.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/state_type.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/state_type_spec.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/state_type_spec.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/state_type_update.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/user.py`

 * *Files 24% similar despite different names*

```diff
@@ -14,194 +14,247 @@
 import re  # noqa: F401
 
 import six
 
 from ..configuration import Configuration
 
 
-class StateTypeUpdate(object):
+class User(object):
     """
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
-        'delete_child_localizations': 'bool',
-        'description': 'str',
         'elemental_id': 'str',
-        'grouping_default': 'bool',
-        'name': 'str',
-        'visible': 'bool'
+        'email': 'str',
+        'first_name': 'str',
+        'id': 'int',
+        'is_staff': 'bool',
+        'last_name': 'str',
+        'profile': 'object',
+        'username': 'str'
     }
 
     attribute_map = {
-        'delete_child_localizations': 'delete_child_localizations',
-        'description': 'description',
         'elemental_id': 'elemental_id',
-        'grouping_default': 'grouping_default',
-        'name': 'name',
-        'visible': 'visible'
+        'email': 'email',
+        'first_name': 'first_name',
+        'id': 'id',
+        'is_staff': 'is_staff',
+        'last_name': 'last_name',
+        'profile': 'profile',
+        'username': 'username'
     }
 
-    def __init__(self, delete_child_localizations=None, description=None, elemental_id=None, grouping_default=None, name=None, visible=None, local_vars_configuration=None):  # noqa: E501
-        """StateTypeUpdate - a model defined in OpenAPI"""
+    def __init__(self, elemental_id=None, email=None, first_name=None, id=None, is_staff=None, last_name=None, profile=None, username=None, local_vars_configuration=None):  # noqa: E501
+        """User - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration()
         self.local_vars_configuration = local_vars_configuration
 
-        self._delete_child_localizations = None
-        self._description = None
         self._elemental_id = None
-        self._grouping_default = None
-        self._name = None
-        self._visible = None
+        self._email = None
+        self._first_name = None
+        self._id = None
+        self._is_staff = None
+        self._last_name = None
+        self._profile = None
+        self._username = None
         self.discriminator = None
 
-        if delete_child_localizations is not None:
-            self.delete_child_localizations = delete_child_localizations
-        if description is not None:
-            self.description = description
-        self.elemental_id = elemental_id
-        if grouping_default is not None:
-            self.grouping_default = grouping_default
-        if name is not None:
-            self.name = name
-        if visible is not None:
-            self.visible = visible
+        if elemental_id is not None:
+            self.elemental_id = elemental_id
+        if email is not None:
+            self.email = email
+        if first_name is not None:
+            self.first_name = first_name
+        if id is not None:
+            self.id = id
+        if is_staff is not None:
+            self.is_staff = is_staff
+        if last_name is not None:
+            self.last_name = last_name
+        if profile is not None:
+            self.profile = profile
+        if username is not None:
+            self.username = username
 
     @property
-    def delete_child_localizations(self):
+    def elemental_id(self):
         """
-        True if child localizations should be deleted when this state is deleted. Localizations will only be deleted if they are not associated with another state. 
+        Unique ID for a user across clusters/deployments
 
-        :return: The delete_child_localizations of this StateTypeUpdate. 
-        :rtype: bool
+        :return: The elemental_id of this User. 
+        :rtype: str
         """
-        return self._delete_child_localizations
+        return self._elemental_id
 
-    @delete_child_localizations.setter
-    def delete_child_localizations(self, delete_child_localizations):
+    @elemental_id.setter
+    def elemental_id(self, elemental_id):
         """
-        True if child localizations should be deleted when this state is deleted. Localizations will only be deleted if they are not associated with another state. 
+        Unique ID for a user across clusters/deployments
 
-        :param delete_child_localizations: The delete_child_localizations of this StateTypeUpdate.
-        :type: bool
+        :param elemental_id: The elemental_id of this User.
+        :type: str
         """
 
-        self._delete_child_localizations = delete_child_localizations
+        self._elemental_id = elemental_id
 
     @property
-    def description(self):
+    def email(self):
         """
-        Description of the state type.
+        Email address of user.
 
-        :return: The description of this StateTypeUpdate. 
+        :return: The email of this User. 
         :rtype: str
         """
-        return self._description
+        return self._email
 
-    @description.setter
-    def description(self, description):
+    @email.setter
+    def email(self, email):
         """
-        Description of the state type.
+        Email address of user.
 
-        :param description: The description of this StateTypeUpdate.
+        :param email: The email of this User.
         :type: str
         """
 
-        self._description = description
+        self._email = email
 
     @property
-    def elemental_id(self):
+    def first_name(self):
         """
-        The elemental ID of the object.
+        First name of user.
 
-        :return: The elemental_id of this StateTypeUpdate. 
+        :return: The first_name of this User. 
         :rtype: str
         """
-        return self._elemental_id
+        return self._first_name
 
-    @elemental_id.setter
-    def elemental_id(self, elemental_id):
+    @first_name.setter
+    def first_name(self, first_name):
         """
-        The elemental ID of the object.
+        First name of user.
 
-        :param elemental_id: The elemental_id of this StateTypeUpdate.
+        :param first_name: The first_name of this User.
         :type: str
         """
 
-        self._elemental_id = elemental_id
+        self._first_name = first_name
+
+    @property
+    def id(self):
+        """
+        Unique integer identifying a user.
+
+        :return: The id of this User. 
+        :rtype: int
+        """
+        return self._id
+
+    @id.setter
+    def id(self, id):
+        """
+        Unique integer identifying a user.
+
+        :param id: The id of this User.
+        :type: int
+        """
+
+        self._id = id
 
     @property
-    def grouping_default(self):
+    def is_staff(self):
         """
-        Whether to group elements in the UI by default.
+        Whether this user is a system administrator.
 
-        :return: The grouping_default of this StateTypeUpdate. 
+        :return: The is_staff of this User. 
         :rtype: bool
         """
-        return self._grouping_default
+        return self._is_staff
 
-    @grouping_default.setter
-    def grouping_default(self, grouping_default):
+    @is_staff.setter
+    def is_staff(self, is_staff):
         """
-        Whether to group elements in the UI by default.
+        Whether this user is a system administrator.
 
-        :param grouping_default: The grouping_default of this StateTypeUpdate.
+        :param is_staff: The is_staff of this User.
         :type: bool
         """
 
-        self._grouping_default = grouping_default
+        self._is_staff = is_staff
 
     @property
-    def name(self):
+    def last_name(self):
         """
-        Name of the state type.
+        Last name of user.
 
-        :return: The name of this StateTypeUpdate. 
+        :return: The last_name of this User. 
         :rtype: str
         """
-        return self._name
+        return self._last_name
 
-    @name.setter
-    def name(self, name):
+    @last_name.setter
+    def last_name(self, last_name):
         """
-        Name of the state type.
+        Last name of user.
 
-        :param name: The name of this StateTypeUpdate.
+        :param last_name: The last_name of this User.
         :type: str
         """
 
-        self._name = name
+        self._last_name = last_name
 
     @property
-    def visible(self):
+    def profile(self):
         """
-        Whether this state type should be displayed.
+        User profile information
 
-        :return: The visible of this StateTypeUpdate. 
-        :rtype: bool
+        :return: The profile of this User. 
+        :rtype: object
         """
-        return self._visible
+        return self._profile
 
-    @visible.setter
-    def visible(self, visible):
+    @profile.setter
+    def profile(self, profile):
         """
-        Whether this state type should be displayed.
+        User profile information
 
-        :param visible: The visible of this StateTypeUpdate.
-        :type: bool
+        :param profile: The profile of this User.
+        :type: object
+        """
+
+        self._profile = profile
+
+    @property
+    def username(self):
+        """
+        Username of user.
+
+        :return: The username of this User. 
+        :rtype: str
+        """
+        return self._username
+
+    @username.setter
+    def username(self, username):
+        """
+        Username of user.
+
+        :param username: The username of this User.
+        :type: str
         """
 
-        self._visible = visible
+        self._username = username
 
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.openapi_types):
             value = getattr(self, attr)
@@ -229,18 +282,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, StateTypeUpdate):
+        if not isinstance(other, User):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, StateTypeUpdate):
+        if not isinstance(other, User):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/state_update.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/state_update.py`

 * *Files 16% similar despite different names*

```diff
@@ -29,63 +29,78 @@
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
         'attributes': 'dict(str, object)',
         'elemental_id': 'str',
         'frame': 'int',
+        'in_place': 'int',
         'localization_ids_add': 'list[int]',
         'localization_ids_remove': 'list[int]',
+        'mark': 'int',
         'null_attributes': 'list[str]',
         'parent': 'float',
+        'pedantic': 'int',
         'reset_attributes': 'list[str]',
         'user_elemental_id': 'str'
     }
 
     attribute_map = {
         'attributes': 'attributes',
         'elemental_id': 'elemental_id',
         'frame': 'frame',
+        'in_place': 'in_place',
         'localization_ids_add': 'localization_ids_add',
         'localization_ids_remove': 'localization_ids_remove',
+        'mark': 'mark',
         'null_attributes': 'null_attributes',
         'parent': 'parent',
+        'pedantic': 'pedantic',
         'reset_attributes': 'reset_attributes',
         'user_elemental_id': 'user_elemental_id'
     }
 
-    def __init__(self, attributes=None, elemental_id=None, frame=None, localization_ids_add=None, localization_ids_remove=None, null_attributes=None, parent=None, reset_attributes=None, user_elemental_id=None, local_vars_configuration=None):  # noqa: E501
+    def __init__(self, attributes=None, elemental_id=None, frame=None, in_place=0, localization_ids_add=None, localization_ids_remove=None, mark=None, null_attributes=None, parent=None, pedantic=0, reset_attributes=None, user_elemental_id=None, local_vars_configuration=None):  # noqa: E501
         """StateUpdate - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration()
         self.local_vars_configuration = local_vars_configuration
 
         self._attributes = None
         self._elemental_id = None
         self._frame = None
+        self._in_place = None
         self._localization_ids_add = None
         self._localization_ids_remove = None
+        self._mark = None
         self._null_attributes = None
         self._parent = None
+        self._pedantic = None
         self._reset_attributes = None
         self._user_elemental_id = None
         self.discriminator = None
 
         if attributes is not None:
             self.attributes = attributes
         self.elemental_id = elemental_id
         if frame is not None:
             self.frame = frame
+        if in_place is not None:
+            self.in_place = in_place
         if localization_ids_add is not None:
             self.localization_ids_add = localization_ids_add
         if localization_ids_remove is not None:
             self.localization_ids_remove = localization_ids_remove
+        if mark is not None:
+            self.mark = mark
         if null_attributes is not None:
             self.null_attributes = null_attributes
         self.parent = parent
+        if pedantic is not None:
+            self.pedantic = pedantic
         if reset_attributes is not None:
             self.reset_attributes = reset_attributes
         if user_elemental_id is not None:
             self.user_elemental_id = user_elemental_id
 
     @property
     def attributes(self):
@@ -147,14 +162,41 @@
         :param frame: The frame of this StateUpdate.
         :type: int
         """
 
         self._frame = frame
 
     @property
+    def in_place(self):
+        """
+        Set to 1 to edit this record in-place, else mark-based versioning rules apply. This changes to 1 for authorship changes automatically.
+
+        :return: The in_place of this StateUpdate. 
+        :rtype: int
+        """
+        return self._in_place
+
+    @in_place.setter
+    def in_place(self, in_place):
+        """
+        Set to 1 to edit this record in-place, else mark-based versioning rules apply. This changes to 1 for authorship changes automatically.
+
+        :param in_place: The in_place of this StateUpdate.
+        :type: int
+        """
+        if (self.local_vars_configuration.client_side_validation and
+                in_place is not None and in_place > 1):  # noqa: E501
+            raise ValueError("Invalid value for `in_place`, must be a value less than or equal to `1`")  # noqa: E501
+        if (self.local_vars_configuration.client_side_validation and
+                in_place is not None and in_place < 0):  # noqa: E501
+            raise ValueError("Invalid value for `in_place`, must be a value greater than or equal to `0`")  # noqa: E501
+
+        self._in_place = in_place
+
+    @property
     def localization_ids_add(self):
         """
         List of new localization IDs that this state applies to.
 
         :return: The localization_ids_add of this StateUpdate. 
         :rtype: list[int]
         """
@@ -189,14 +231,35 @@
         :param localization_ids_remove: The localization_ids_remove of this StateUpdate.
         :type: list[int]
         """
 
         self._localization_ids_remove = localization_ids_remove
 
     @property
+    def mark(self):
+        """
+        Revision number of this object on this version branch
+
+        :return: The mark of this StateUpdate. 
+        :rtype: int
+        """
+        return self._mark
+
+    @mark.setter
+    def mark(self, mark):
+        """
+        Revision number of this object on this version branch
+
+        :param mark: The mark of this StateUpdate.
+        :type: int
+        """
+
+        self._mark = mark
+
+    @property
     def null_attributes(self):
         """
         Null a value in the attributes body
 
         :return: The null_attributes of this StateUpdate. 
         :rtype: list[str]
         """
@@ -231,14 +294,41 @@
         :param parent: The parent of this StateUpdate.
         :type: float
         """
 
         self._parent = parent
 
     @property
+    def pedantic(self):
+        """
+        Set to 1 to enforce that this is the latest mark; else push edits to end of branch.
+
+        :return: The pedantic of this StateUpdate. 
+        :rtype: int
+        """
+        return self._pedantic
+
+    @pedantic.setter
+    def pedantic(self, pedantic):
+        """
+        Set to 1 to enforce that this is the latest mark; else push edits to end of branch.
+
+        :param pedantic: The pedantic of this StateUpdate.
+        :type: int
+        """
+        if (self.local_vars_configuration.client_side_validation and
+                pedantic is not None and pedantic > 1):  # noqa: E501
+            raise ValueError("Invalid value for `pedantic`, must be a value less than or equal to `1`")  # noqa: E501
+        if (self.local_vars_configuration.client_side_validation and
+                pedantic is not None and pedantic < 0):  # noqa: E501
+            raise ValueError("Invalid value for `pedantic`, must be a value greater than or equal to `0`")  # noqa: E501
+
+        self._pedantic = pedantic
+
+    @property
     def reset_attributes(self):
         """
         Reset an attribute to the default value specified in the Type object
 
         :return: The reset_attributes of this StateUpdate. 
         :rtype: list[str]
         """
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/temporary_file.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/temporary_file.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/temporary_file_spec.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/temporary_file_spec.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/token.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/token.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/transcode.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/transcode.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/transcode_spec.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/transcode_spec.py`

 * *Files 3% similar despite different names*

```diff
@@ -33,61 +33,67 @@
         'attributes': 'object',
         'email_spec': 'JobSpecFailureEmailSpec',
         'gid': 'str',
         'md5': 'str',
         'media_id': 'int',
         'name': 'str',
         'section': 'str',
+        'section_id': 'int',
         'size': 'int',
         'type': 'int',
         'uid': 'str',
         'url': 'str'
     }
 
     attribute_map = {
         'attributes': 'attributes',
         'email_spec': 'email_spec',
         'gid': 'gid',
         'md5': 'md5',
         'media_id': 'media_id',
         'name': 'name',
         'section': 'section',
+        'section_id': 'section_id',
         'size': 'size',
         'type': 'type',
         'uid': 'uid',
         'url': 'url'
     }
 
-    def __init__(self, attributes=None, email_spec=None, gid=None, md5=None, media_id=None, name=None, section=None, size=None, type=None, uid=None, url=None, local_vars_configuration=None):  # noqa: E501
+    def __init__(self, attributes=None, email_spec=None, gid=None, md5=None, media_id=None, name=None, section=None, section_id=None, size=None, type=None, uid=None, url=None, local_vars_configuration=None):  # noqa: E501
         """TranscodeSpec - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration()
         self.local_vars_configuration = local_vars_configuration
 
         self._attributes = None
         self._email_spec = None
         self._gid = None
         self._md5 = None
         self._media_id = None
         self._name = None
         self._section = None
+        self._section_id = None
         self._size = None
         self._type = None
         self._uid = None
         self._url = None
         self.discriminator = None
 
         self.attributes = attributes
         self.email_spec = email_spec
         self.gid = gid
         if md5 is not None:
             self.md5 = md5
         self.media_id = media_id
         self.name = name
-        self.section = section
+        if section is not None:
+            self.section = section
+        if section_id is not None:
+            self.section_id = section_id
         if size is not None:
             self.size = size
         self.type = type
         self.uid = uid
         self.url = url
 
     @property
@@ -232,20 +238,39 @@
     def section(self, section):
         """
         Media section name to upload to.
 
         :param section: The section of this TranscodeSpec.
         :type: str
         """
-        if self.local_vars_configuration.client_side_validation and section is None:  # noqa: E501
-            raise ValueError("Invalid value for `section`, must not be `None`")  # noqa: E501
 
         self._section = section
 
     @property
+    def section_id(self):
+        """
+        Media section ID to upload to. If given `section` is ignored.
+
+        :return: The section_id of this TranscodeSpec. 
+        :rtype: int
+        """
+        return self._section_id
+
+    @section_id.setter
+    def section_id(self, section_id):
+        """
+        Media section ID to upload to. If given `section` is ignored.
+
+        :param section_id: The section_id of this TranscodeSpec.
+        :type: int
+        """
+
+        self._section_id = section_id
+
+    @property
     def size(self):
         """
         Size of the file in bytes. This parameter is required if the supplied URL is external (not produced by `DownloadInfo` and cannot accept HEAD requests.
 
         :return: The size of this TranscodeSpec. 
         :rtype: int
         """
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/upload_completion_spec.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/upload_completion_spec.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/upload_info.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/upload_part.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,117 +14,91 @@
 import re  # noqa: F401
 
 import six
 
 from ..configuration import Configuration
 
 
-class UploadInfo(object):
+class UploadPart(object):
     """
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
-        'key': 'str',
-        'upload_id': 'str',
-        'urls': 'list[str]'
+        'e_tag': 'str',
+        'part_number': 'int'
     }
 
     attribute_map = {
-        'key': 'key',
-        'upload_id': 'upload_id',
-        'urls': 'urls'
+        'e_tag': 'ETag',
+        'part_number': 'PartNumber'
     }
 
-    def __init__(self, key=None, upload_id=None, urls=None, local_vars_configuration=None):  # noqa: E501
-        """UploadInfo - a model defined in OpenAPI"""
+    def __init__(self, e_tag=None, part_number=None, local_vars_configuration=None):  # noqa: E501
+        """UploadPart - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration()
         self.local_vars_configuration = local_vars_configuration
 
-        self._key = None
-        self._upload_id = None
-        self._urls = None
+        self._e_tag = None
+        self._part_number = None
         self.discriminator = None
 
-        if key is not None:
-            self.key = key
-        if upload_id is not None:
-            self.upload_id = upload_id
-        if urls is not None:
-            self.urls = urls
+        if e_tag is not None:
+            self.e_tag = e_tag
+        if part_number is not None:
+            self.part_number = part_number
 
     @property
-    def key(self):
+    def e_tag(self):
         """
-        An object key that can be supplied to the `Transcode` or `Media` or `File` endpoint after the file has been uploaded.
+        Content of ETag header returned from PUT request for an upload part. NOTE: key is case-sensitive!
 
-        :return: The key of this UploadInfo. 
+        :return: The e_tag of this UploadPart. 
         :rtype: str
         """
-        return self._key
+        return self._e_tag
 
-    @key.setter
-    def key(self, key):
+    @e_tag.setter
+    def e_tag(self, e_tag):
         """
-        An object key that can be supplied to the `Transcode` or `Media` or `File` endpoint after the file has been uploaded.
+        Content of ETag header returned from PUT request for an upload part. NOTE: key is case-sensitive!
 
-        :param key: The key of this UploadInfo.
+        :param e_tag: The e_tag of this UploadPart.
         :type: str
         """
 
-        self._key = key
+        self._e_tag = e_tag
 
     @property
-    def upload_id(self):
+    def part_number(self):
         """
-        An upload ID that can be supplied to the `UploadCompletion` endpoint after the file has been uploaded. Only contains a value if `num_parts` > 1.
+        Part number for the given ETag response header. NOTE: key is case-sensitive!
 
-        :return: The upload_id of this UploadInfo. 
-        :rtype: str
-        """
-        return self._upload_id
-
-    @upload_id.setter
-    def upload_id(self, upload_id):
-        """
-        An upload ID that can be supplied to the `UploadCompletion` endpoint after the file has been uploaded. Only contains a value if `num_parts` > 1.
-
-        :param upload_id: The upload_id of this UploadInfo.
-        :type: str
-        """
-
-        self._upload_id = upload_id
-
-    @property
-    def urls(self):
-        """
-        One or more URLs for upload via one PUT request per URL.
-
-        :return: The urls of this UploadInfo. 
-        :rtype: list[str]
+        :return: The part_number of this UploadPart. 
+        :rtype: int
         """
-        return self._urls
+        return self._part_number
 
-    @urls.setter
-    def urls(self, urls):
+    @part_number.setter
+    def part_number(self, part_number):
         """
-        One or more URLs for upload via one PUT request per URL.
+        Part number for the given ETag response header. NOTE: key is case-sensitive!
 
-        :param urls: The urls of this UploadInfo.
-        :type: list[str]
+        :param part_number: The part_number of this UploadPart.
+        :type: int
         """
 
-        self._urls = urls
+        self._part_number = part_number
 
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.openapi_types):
             value = getattr(self, attr)
@@ -152,18 +126,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, UploadInfo):
+        if not isinstance(other, UploadPart):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, UploadInfo):
+        if not isinstance(other, UploadPart):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/upload_part.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/attribute_type_delete.py`

 * *Files 21% similar despite different names*

```diff
@@ -14,91 +14,97 @@
 import re  # noqa: F401
 
 import six
 
 from ..configuration import Configuration
 
 
-class UploadPart(object):
+class AttributeTypeDelete(object):
     """
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
-        'e_tag': 'str',
-        'part_number': 'int'
+        'entity_type': 'str',
+        'name': 'str'
     }
 
     attribute_map = {
-        'e_tag': 'ETag',
-        'part_number': 'PartNumber'
+        'entity_type': 'entity_type',
+        'name': 'name'
     }
 
-    def __init__(self, e_tag=None, part_number=None, local_vars_configuration=None):  # noqa: E501
-        """UploadPart - a model defined in OpenAPI"""
+    def __init__(self, entity_type=None, name=None, local_vars_configuration=None):  # noqa: E501
+        """AttributeTypeDelete - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration()
         self.local_vars_configuration = local_vars_configuration
 
-        self._e_tag = None
-        self._part_number = None
+        self._entity_type = None
+        self._name = None
         self.discriminator = None
 
-        if e_tag is not None:
-            self.e_tag = e_tag
-        if part_number is not None:
-            self.part_number = part_number
+        if entity_type is not None:
+            self.entity_type = entity_type
+        if name is not None:
+            self.name = name
 
     @property
-    def e_tag(self):
+    def entity_type(self):
         """
-        Content of ETag header returned from PUT request for an upload part. NOTE: key is case-sensitive!
+        The entity type containing the attribute to rename.
 
-        :return: The e_tag of this UploadPart. 
+        :return: The entity_type of this AttributeTypeDelete. 
         :rtype: str
         """
-        return self._e_tag
+        return self._entity_type
 
-    @e_tag.setter
-    def e_tag(self, e_tag):
+    @entity_type.setter
+    def entity_type(self, entity_type):
         """
-        Content of ETag header returned from PUT request for an upload part. NOTE: key is case-sensitive!
+        The entity type containing the attribute to rename.
 
-        :param e_tag: The e_tag of this UploadPart.
+        :param entity_type: The entity_type of this AttributeTypeDelete.
         :type: str
         """
+        allowed_values = ["FileType", "MediaType", "LocalizationType", "StateType", "LeafType", "Section"]  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and entity_type not in allowed_values:  # noqa: E501
+            raise ValueError(
+                "Invalid value for `entity_type` ({0}), must be one of {1}"  # noqa: E501
+                .format(entity_type, allowed_values)
+            )
 
-        self._e_tag = e_tag
+        self._entity_type = entity_type
 
     @property
-    def part_number(self):
+    def name(self):
         """
-        Part number for the given ETag response header. NOTE: key is case-sensitive!
+        The attribute to delete.
 
-        :return: The part_number of this UploadPart. 
-        :rtype: int
+        :return: The name of this AttributeTypeDelete. 
+        :rtype: str
         """
-        return self._part_number
+        return self._name
 
-    @part_number.setter
-    def part_number(self, part_number):
+    @name.setter
+    def name(self, name):
         """
-        Part number for the given ETag response header. NOTE: key is case-sensitive!
+        The attribute to delete.
 
-        :param part_number: The part_number of this UploadPart.
-        :type: int
+        :param name: The name of this AttributeTypeDelete.
+        :type: str
         """
 
-        self._part_number = part_number
+        self._name = name
 
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.openapi_types):
             value = getattr(self, attr)
@@ -126,18 +132,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, UploadPart):
+        if not isinstance(other, AttributeTypeDelete):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, UploadPart):
+        if not isinstance(other, AttributeTypeDelete):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/user_spec.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/user_spec.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/version.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/version_spec.py`

 * *Files 22% similar despite different names*

```diff
@@ -14,269 +14,166 @@
 import re  # noqa: F401
 
 import six
 
 from ..configuration import Configuration
 
 
-class Version(object):
+class VersionSpec(object):
     """
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
         'bases': 'list[int]',
-        'created_by': 'str',
         'description': 'str',
         'elemental_id': 'str',
-        'id': 'int',
         'name': 'str',
-        'number': 'int',
-        'project': 'int',
         'show_empty': 'bool'
     }
 
     attribute_map = {
         'bases': 'bases',
-        'created_by': 'created_by',
         'description': 'description',
         'elemental_id': 'elemental_id',
-        'id': 'id',
         'name': 'name',
-        'number': 'number',
-        'project': 'project',
         'show_empty': 'show_empty'
     }
 
-    def __init__(self, bases=None, created_by=None, description='', elemental_id=None, id=None, name=None, number=None, project=None, show_empty=True, local_vars_configuration=None):  # noqa: E501
-        """Version - a model defined in OpenAPI"""
+    def __init__(self, bases=None, description='', elemental_id=None, name=None, show_empty=True, local_vars_configuration=None):  # noqa: E501
+        """VersionSpec - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration()
         self.local_vars_configuration = local_vars_configuration
 
         self._bases = None
-        self._created_by = None
         self._description = None
         self._elemental_id = None
-        self._id = None
         self._name = None
-        self._number = None
-        self._project = None
         self._show_empty = None
         self.discriminator = None
 
         if bases is not None:
             self.bases = bases
-        if created_by is not None:
-            self.created_by = created_by
         if description is not None:
             self.description = description
         if elemental_id is not None:
             self.elemental_id = elemental_id
-        if id is not None:
-            self.id = id
-        if name is not None:
-            self.name = name
-        if number is not None:
-            self.number = number
-        if project is not None:
-            self.project = project
+        self.name = name
         if show_empty is not None:
             self.show_empty = show_empty
 
     @property
     def bases(self):
         """
         Array of other version IDs that are dependencies of this version.
 
-        :return: The bases of this Version. 
+        :return: The bases of this VersionSpec. 
         :rtype: list[int]
         """
         return self._bases
 
     @bases.setter
     def bases(self, bases):
         """
         Array of other version IDs that are dependencies of this version.
 
-        :param bases: The bases of this Version.
+        :param bases: The bases of this VersionSpec.
         :type: list[int]
         """
 
         self._bases = bases
 
     @property
-    def created_by(self):
-        """
-        Name of user who created the last unmodified annotation in this version.
-
-        :return: The created_by of this Version. 
-        :rtype: str
-        """
-        return self._created_by
-
-    @created_by.setter
-    def created_by(self, created_by):
-        """
-        Name of user who created the last unmodified annotation in this version.
-
-        :param created_by: The created_by of this Version.
-        :type: str
-        """
-
-        self._created_by = created_by
-
-    @property
     def description(self):
         """
         Description of the version.
 
-        :return: The description of this Version. 
+        :return: The description of this VersionSpec. 
         :rtype: str
         """
         return self._description
 
     @description.setter
     def description(self, description):
         """
         Description of the version.
 
-        :param description: The description of this Version.
+        :param description: The description of this VersionSpec.
         :type: str
         """
 
         self._description = description
 
     @property
     def elemental_id(self):
         """
         Unique ID of an element
 
-        :return: The elemental_id of this Version. 
+        :return: The elemental_id of this VersionSpec. 
         :rtype: str
         """
         return self._elemental_id
 
     @elemental_id.setter
     def elemental_id(self, elemental_id):
         """
         Unique ID of an element
 
-        :param elemental_id: The elemental_id of this Version.
+        :param elemental_id: The elemental_id of this VersionSpec.
         :type: str
         """
 
         self._elemental_id = elemental_id
 
     @property
-    def id(self):
-        """
-        Unique integer identifying a membership.
-
-        :return: The id of this Version. 
-        :rtype: int
-        """
-        return self._id
-
-    @id.setter
-    def id(self, id):
-        """
-        Unique integer identifying a membership.
-
-        :param id: The id of this Version.
-        :type: int
-        """
-
-        self._id = id
-
-    @property
     def name(self):
         """
         Name of the version.
 
-        :return: The name of this Version. 
+        :return: The name of this VersionSpec. 
         :rtype: str
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """
         Name of the version.
 
-        :param name: The name of this Version.
+        :param name: The name of this VersionSpec.
         :type: str
         """
+        if self.local_vars_configuration.client_side_validation and name is None:  # noqa: E501
+            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501
 
         self._name = name
 
     @property
-    def number(self):
-        """
-        Version number.
-
-        :return: The number of this Version. 
-        :rtype: int
-        """
-        return self._number
-
-    @number.setter
-    def number(self, number):
-        """
-        Version number.
-
-        :param number: The number of this Version.
-        :type: int
-        """
-
-        self._number = number
-
-    @property
-    def project(self):
-        """
-        Unique integer identifying a project.
-
-        :return: The project of this Version. 
-        :rtype: int
-        """
-        return self._project
-
-    @project.setter
-    def project(self, project):
-        """
-        Unique integer identifying a project.
-
-        :param project: The project of this Version.
-        :type: int
-        """
-
-        self._project = project
-
-    @property
     def show_empty(self):
         """
         Whether to show this version on media for which no annotations exist.
 
-        :return: The show_empty of this Version. 
+        :return: The show_empty of this VersionSpec. 
         :rtype: bool
         """
         return self._show_empty
 
     @show_empty.setter
     def show_empty(self, show_empty):
         """
         Whether to show this version on media for which no annotations exist.
 
-        :param show_empty: The show_empty of this Version.
+        :param show_empty: The show_empty of this VersionSpec.
         :type: bool
         """
 
         self._show_empty = show_empty
 
     def to_dict(self):
         """Returns the model properties as a dict"""
@@ -308,18 +205,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, Version):
+        if not isinstance(other, VersionSpec):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, Version):
+        if not isinstance(other, VersionSpec):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/version_spec.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/hosted_template_spec.py`

 * *Files 27% similar despite different names*

```diff
@@ -14,170 +14,145 @@
 import re  # noqa: F401
 
 import six
 
 from ..configuration import Configuration
 
 
-class VersionSpec(object):
+class HostedTemplateSpec(object):
     """
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
-        'bases': 'list[int]',
-        'description': 'str',
-        'elemental_id': 'str',
+        'headers': 'list[Parameter]',
         'name': 'str',
-        'show_empty': 'bool'
+        'tparams': 'list[Parameter]',
+        'url': 'str'
     }
 
     attribute_map = {
-        'bases': 'bases',
-        'description': 'description',
-        'elemental_id': 'elemental_id',
+        'headers': 'headers',
         'name': 'name',
-        'show_empty': 'show_empty'
+        'tparams': 'tparams',
+        'url': 'url'
     }
 
-    def __init__(self, bases=None, description='', elemental_id=None, name=None, show_empty=True, local_vars_configuration=None):  # noqa: E501
-        """VersionSpec - a model defined in OpenAPI"""
+    def __init__(self, headers=[], name=None, tparams=[], url=None, local_vars_configuration=None):  # noqa: E501
+        """HostedTemplateSpec - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration()
         self.local_vars_configuration = local_vars_configuration
 
-        self._bases = None
-        self._description = None
-        self._elemental_id = None
+        self._headers = None
         self._name = None
-        self._show_empty = None
+        self._tparams = None
+        self._url = None
         self.discriminator = None
 
-        if bases is not None:
-            self.bases = bases
-        if description is not None:
-            self.description = description
-        if elemental_id is not None:
-            self.elemental_id = elemental_id
+        if headers is not None:
+            self.headers = headers
         self.name = name
-        if show_empty is not None:
-            self.show_empty = show_empty
+        if tparams is not None:
+            self.tparams = tparams
+        self.url = url
 
     @property
-    def bases(self):
+    def headers(self):
         """
-        Array of other version IDs that are dependencies of this version.
+        Headers used to retrieve hosted template, if set.
 
-        :return: The bases of this VersionSpec. 
-        :rtype: list[int]
+        :return: The headers of this HostedTemplateSpec. 
+        :rtype: list[Parameter]
         """
-        return self._bases
+        return self._headers
 
-    @bases.setter
-    def bases(self, bases):
+    @headers.setter
+    def headers(self, headers):
         """
-        Array of other version IDs that are dependencies of this version.
+        Headers used to retrieve hosted template, if set.
 
-        :param bases: The bases of this VersionSpec.
-        :type: list[int]
+        :param headers: The headers of this HostedTemplateSpec.
+        :type: list[Parameter]
         """
 
-        self._bases = bases
+        self._headers = headers
 
     @property
-    def description(self):
+    def name(self):
         """
-        Description of the version.
+        Unique name of the hosted template.
 
-        :return: The description of this VersionSpec. 
+        :return: The name of this HostedTemplateSpec. 
         :rtype: str
         """
-        return self._description
+        return self._name
 
-    @description.setter
-    def description(self, description):
+    @name.setter
+    def name(self, name):
         """
-        Description of the version.
+        Unique name of the hosted template.
 
-        :param description: The description of this VersionSpec.
+        :param name: The name of this HostedTemplateSpec.
         :type: str
         """
+        if self.local_vars_configuration.client_side_validation and name is None:  # noqa: E501
+            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501
 
-        self._description = description
+        self._name = name
 
     @property
-    def elemental_id(self):
+    def tparams(self):
         """
-        Unique ID of an element
+        Template parameters used for rendering hosted template, if set.
 
-        :return: The elemental_id of this VersionSpec. 
-        :rtype: str
+        :return: The tparams of this HostedTemplateSpec. 
+        :rtype: list[Parameter]
         """
-        return self._elemental_id
+        return self._tparams
 
-    @elemental_id.setter
-    def elemental_id(self, elemental_id):
+    @tparams.setter
+    def tparams(self, tparams):
         """
-        Unique ID of an element
+        Template parameters used for rendering hosted template, if set.
 
-        :param elemental_id: The elemental_id of this VersionSpec.
-        :type: str
+        :param tparams: The tparams of this HostedTemplateSpec.
+        :type: list[Parameter]
         """
 
-        self._elemental_id = elemental_id
+        self._tparams = tparams
 
     @property
-    def name(self):
+    def url(self):
         """
-        Name of the version.
+        URL where jinja2 template is hosted, must be retrievable with a GET using supplied headers.
 
-        :return: The name of this VersionSpec. 
+        :return: The url of this HostedTemplateSpec. 
         :rtype: str
         """
-        return self._name
+        return self._url
 
-    @name.setter
-    def name(self, name):
+    @url.setter
+    def url(self, url):
         """
-        Name of the version.
+        URL where jinja2 template is hosted, must be retrievable with a GET using supplied headers.
 
-        :param name: The name of this VersionSpec.
+        :param url: The url of this HostedTemplateSpec.
         :type: str
         """
-        if self.local_vars_configuration.client_side_validation and name is None:  # noqa: E501
-            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501
-
-        self._name = name
-
-    @property
-    def show_empty(self):
-        """
-        Whether to show this version on media for which no annotations exist.
-
-        :return: The show_empty of this VersionSpec. 
-        :rtype: bool
-        """
-        return self._show_empty
-
-    @show_empty.setter
-    def show_empty(self, show_empty):
-        """
-        Whether to show this version on media for which no annotations exist.
-
-        :param show_empty: The show_empty of this VersionSpec.
-        :type: bool
-        """
+        if self.local_vars_configuration.client_side_validation and url is None:  # noqa: E501
+            raise ValueError("Invalid value for `url`, must not be `None`")  # noqa: E501
 
-        self._show_empty = show_empty
+        self._url = url
 
     def to_dict(self):
         """Returns the model properties as a dict"""
         result = {}
 
         for attr, _ in six.iteritems(self.openapi_types):
             value = getattr(self, attr)
@@ -205,18 +180,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, VersionSpec):
+        if not isinstance(other, HostedTemplateSpec):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, VersionSpec):
+        if not isinstance(other, HostedTemplateSpec):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/video_clip.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/video_clip.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/models/video_definition.py` & `tator-1.3.0/tator/openapi/tator_openapi/models/video_definition.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/openapi/tator_openapi/rest.py` & `tator-1.3.0/tator/openapi/tator_openapi/rest.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/transcode/__main__.py` & `tator-1.3.0/tator/transcode/__main__.py`

 * *Files 13% similar despite different names*

```diff
@@ -19,14 +19,23 @@
 from .determine_transcode import determine_transcode
 from .transcode import convert_streaming
 from .transcode import convert_archival
 from .transcode import convert_audio
 from .delete_media import delete_media
 from .make_thumbnails import make_thumbnails
 
+if os.getenv("DD_LOGS_INJECTION"):
+    import ddtrace.auto
+    FORMAT = ('%(asctime)s %(levelname)s [%(name)s] [%(filename)s:%(lineno)d] '
+              '[dd.service=%(dd.service)s dd.env=%(dd.env)s dd.version=%(dd.version)s dd.trace_id=%(dd.trace_id)s dd.span_id=%(dd.span_id)s] '
+              '- %(message)s')
+else:
+    FORMAT = ('%(asctime)s %(levelname)s [%(name)s] [%(filename)s:%(lineno)d] '
+              '- %(message)s')
+logging.basicConfig(format=FORMAT)
 logger = logging.getLogger(__name__)
 logger.setLevel(logging.INFO)
 
 def parse_args():
     parser = argparse.ArgumentParser(description='Full transcode pipeline on a directory of files.')
     parser.add_argument('path', nargs='?', type=str,
                         help='Path to directory containing video files, or a video file. '
@@ -38,26 +47,28 @@
     parser.add_argument('--url', type=str, help='URL where original file is hosted.')
     parser.add_argument('--host', type=str, default='https://cloud.tator.io', help='Host URL.')
     parser.add_argument('--token', type=str, help='REST API token.')
     parser.add_argument('--project', type=int, help='Unique integer specifying project ID.')
     parser.add_argument('--type', type=int, help='Unique integer specifying a media type.')
     parser.add_argument('--name', type=str, help='Name of the media.')
     parser.add_argument('--section', type=str, help='Media section name.')
+    parser.add_argument('--section_id', type=int, help='Media section ID. If given `--section` is ignored.')
     parser.add_argument('--attributes', type=str, help="Attributes for media as a JSON string.")
     parser.add_argument('--media_id', type=int, help="Existing media ID, if applicable",
                         default=-1)
     parser.add_argument('--gid', type=str, help="Upload group ID.")
     parser.add_argument('--uid', type=str, help="Upload unique ID.")
     parser.add_argument('--group_to', type=int, default=1080,
                          help='Vertical resolutions below this will be transcoded with '
                               'multi-headed ffmpeg.')
     parser.add_argument('--email_spec', type=str, help="Optional email spec as a JSON string. The email will be sent upon completion of the transcode (see Email rest endpoint docs).")
     parser.add_argument('--cleanup', action='store_true',
                         help="Deletes working files after each file is transcoded and "
                              "uploaded.")
+    parser.add_argument('--hwaccel', action='store_true', help="Use hardware acceleration.")
     return parser.parse_args()
 
 def get_file_paths(path, base):
     paths = {
         'original': path,
         'transcoded': base + '_transcoded',
         'thumbnail': base + '_thumbnail.jpg',
@@ -102,16 +113,20 @@
     if args.uid is None:
         uid = str(uuid1())
     else:
         uid = args.uid
 
     # Create the media object.
     if args.media_id == -1:
+        kwargs = {}
+        if args.section_id:
+            kwargs['section_id'] = args.section_id
+            args.section = None
         media_id = create_media(args.host, args.token, args.project, args.type, args.section,
-                                name, md5, gid, uid, args.attributes, args.url)
+                                name, md5, gid, uid, args.attributes, args.url, **kwargs)
     else:
         media_id = args.media_id
 
     try:
         # Make thumbnails.
         make_thumbnails(args.host, args.token, media_id, paths['original'], paths['thumbnail'],
                         paths['thumbnail_gif'])
@@ -124,19 +139,19 @@
         # Transcode the video file.
         for workload in workloads:
             category = workload['category']
             del workload['category']
             del workload['id']
             if category == 'streaming':
                 convert_streaming(**workload, host=args.host, token=args.token, media=media_id,
-                                  outpath=paths['transcoded'])
+                                  outpath=paths['transcoded'], hwaccel=args.hwaccel)
             elif category == 'archival':
                 del workload['configs']
                 convert_archival(**workload, host=args.host, token=args.token, media=media_id,
-                                 outpath=paths['transcoded'])
+                                 outpath=paths['transcoded'], hwaccel=args.hwaccel)
             elif category == 'audio':
                 del workload['configs']
                 del workload['raw_width']
                 del workload['raw_height']
                 convert_audio(**workload, host=args.host, token=args.token, media=media_id,
                               outpath=paths['transcoded'])
     except Exception as exc:
```

### Comparing `tator-1.2.9/tator/transcode/black.mp4` & `tator-1.3.0/tator/transcode/black.mp4`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/transcode/create_media.py` & `tator-1.3.0/tator/transcode/create_media.py`

 * *Files 21% similar despite different names*

```diff
@@ -5,40 +5,43 @@
 from ..util.get_parser import get_parser
 
 def parse_args():
     parser = get_parser()
     parser.add_argument('--project', type=int, help="Unique integer identifying a project.")
     parser.add_argument('--media_type', type=int, help="Unique integer identifying a media type.")
     parser.add_argument('--section', type=str, help="Name of section to upload to.")
+    parser.add_argument('--section_id', type=int, help='Media section ID. If given `--section` is ignored.')
     parser.add_argument('--name', type=str, help="Name of file.")
     parser.add_argument('--md5', type=str, help="md5 sum of file.")
     parser.add_argument('--gid', type=str, help="Upload group ID.")
     parser.add_argument('--uid', type=str, help="Upload unique ID.")
     parser.add_argument('--output', type=str, help="Where to dump media ID.")
     parser.add_argument('--attributes', type=str, help="Attributes for media as a JSON string.")
     return parser.parse_args()
 
 def create_media(host, token, project, media_type, section, name, md5, gid, uid,
-                 attributes=None, url=None):
+                 attributes=None, url=None, section_id=None):
     """ Creates a media object and returns the ID.
 
     :param host: Host URL.
     :param token: API token.
     :param project: Unique integer identifying a project.
     :param media_type: Unique integer identifying a media type.
     :param section: Section name.
+    :param section_id: Unique integer identifying a section. If given, `section` is ignored.
     :param name: File name.
     :param md5: md5 sum of file.
     :param gid: Upload group ID.
     :param uid: Upload unique ID.
     """
     api = get_api(host, token)
+    section_blob = {'section_id': section_id} if section_id else {'section': section}
     spec ={
         'type': media_type,
-        'section': section,
+        **section_blob,
         'name': name,
         'md5': md5,
         'gid': gid,
         'uid': uid
     }
 
     if attributes:
@@ -48,10 +51,10 @@
 
     return api.create_media_list(project, body=[spec]).id[0] # pylint: disable=E1101
 
 
 if __name__ == '__main__':
     args = parse_args()
     media_id = create_media(args.host, args.token, args.project, args.media_type,
-                            args.section, args.name, args.md5, args.gid, args.uid, args.attributes)
+                            args.section, args.name, args.md5, args.gid, args.uid, args.attributes, section_id=args.section_id)
     with open(args.output, 'w') as f:
         f.write(str(media_id))
```

### Comparing `tator-1.2.9/tator/transcode/delete_media.py` & `tator-1.3.0/tator/transcode/delete_media.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/transcode/determine_transcode.py` & `tator-1.3.0/tator/transcode/determine_transcode.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/transcode/make_fragment_info.py` & `tator-1.3.0/tator/transcode/make_fragment_info.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/transcode/make_thumbnails.py` & `tator-1.3.0/tator/transcode/make_thumbnails.py`

 * *Files 6% similar despite different names*

```diff
@@ -70,15 +70,21 @@
         return
 
     # Get metadata for original file.
     codec, fps, num_frames, width, height = get_metadata(video_path)
 
     # Create thumbnail.
     if needs_thumb_img:
-        cmd = ["ffmpeg", "-y", "-i", video_path, "-vf", "scale=256:-1", "-vframes", "1", thumb_path]
+        cmd = ["ffmpeg", "-y", 
+               "-loglevel", "error",
+               "-progress", "-",
+               "-stats_period", "10",
+               "-i", video_path,
+               "-vf", "scale=256:-1",
+               "-vframes", "1", thumb_path]
         subprocess.run(cmd, check=True)
 
     if needs_thumb_gif:
         # Create gif thumbnail in a single pass
         # This logic makes a max(video_length,60) second summary video than speeds it up 4 times and saves as a gif
         video_duration = num_frames/fps
 
@@ -87,14 +93,17 @@
 
         # We either select every Nth second based on how much longer than 60 seconds we are
         frame_select = max(fps, (video_duration/thumb_duration)*fps)
 
         # We play each 1 second sample at 4x
         speed_up = 4*max(1,round(video_duration/thumb_duration))
         cmd = ["ffmpeg", "-y",
+                "-loglevel", "error",
+                "-progress", "-",
+                "-stats_period", "10",
                 "-i",
                 video_path,
                 "-vf",
                 f"select='not(mod(n\,{round(frame_select)}))',scale=256:-1:flags=lanczos,setpts=PTS/{speed_up},split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse",
                 thumb_gif_path,
         ]
         logger.info(f"cmd={cmd}")
```

### Comparing `tator-1.2.9/tator/transcode/prepare.py` & `tator-1.3.0/tator/transcode/prepare.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/transcode/transcode.py` & `tator-1.3.0/tator/transcode/transcode.py`

 * *Files 3% similar despite different names*

```diff
@@ -50,36 +50,37 @@
         logger.info(f"RESOURCE_INFO = {json.dumps(_get_resource_usage())}")
     if proc.returncode != 0:
         raise RuntimeError("Transcode process failed")
     end = time.time()
     logger.info(f"cmd={cmd}")
     logger.info(f"time={end-start}")
 
-def find_best_encoder(codec):
+def find_best_encoder(codec, hwaccel=False):
     """ Find the best encoder based on what is available on the system """
     global encoder_lookup
     if encoder_lookup is None:
         # Default codecs
         encoder_lookup={"hevc": "libx265",
                         "h264": "libx264",
                         "av1": "libsvtav1"}
-        cmd = [
-            "ffmpeg",
-            "-encoders" ]
-        output=subprocess.run(cmd,stdout=subprocess.PIPE,check=True).stdout.decode()
-        # Look for QSV, but use VAAPI frontend
-        # TODO: Use `vainfo` directly to query available hardware entry points
-        if output.find("libsvt_hevc") >= 0:
-            encoder_lookup["hevc"] = "libsvt_hevc"
-        if output.find("hevc_qsv") >= 0:
-            encoder_lookup["hevc"] = "hevc_vaapi"
-        if output.find("h264_qsv") >= 0:
-            encoder_lookup["h264"] = "h264_vaapi"
-        if output.find("av1_qsv") >= 0:
-            encoder_lookup["av1"] = "av1_vaapi"
+        if hwaccel:
+            cmd = [
+                "ffmpeg",
+                "-encoders" ]
+            output=subprocess.run(cmd,stdout=subprocess.PIPE,check=True).stdout.decode()
+            # Look for QSV, but use VAAPI frontend
+            # TODO: Use `vainfo` directly to query available hardware entry points
+            if output.find("libsvt_hevc") >= 0:
+                encoder_lookup["hevc"] = "libsvt_hevc"
+            if output.find("hevc_qsv") >= 0:
+                encoder_lookup["hevc"] = "hevc_vaapi"
+            if output.find("h264_qsv") >= 0:
+                encoder_lookup["h264"] = "h264_vaapi"
+            if output.find("av1_qsv") >= 0:
+                encoder_lookup["av1"] = "av1_vaapi"
         logger.info("encoder_lookup = %s", encoder_lookup)
     return encoder_lookup.get(codec, codec)
 
 def parse_args():
     parser = argparse.ArgumentParser(description='Transcodes a raw video.')
     parser.add_argument('--url', type=str, help='URL where original file is hosted.')
     parser.add_argument('--work_dir', type=str, help='Directory where info should be saved.')
@@ -88,14 +89,15 @@
     parser.add_argument('--media', type=int, help='Unique integer identifying a media.')
     parser.add_argument('--category', required=True, help='One of streaming, archival, or audio.')
     parser.add_argument('--raw_width', type=int, help='Pixel width of original video.')
     parser.add_argument('--raw_height', type=int, help='Pixel height of original video.')
     parser.add_argument('--configs', type=str, help='Comma separated list of output configs, '
                                                     'format is resolution:crf:codec.')
     parser.add_argument('--size', type=int, help='Size of the file, if not inferrable')
+    parser.add_argument('--hwaccel', action='store_true', help="Use hardware acceleration.")
     return parser.parse_args()
 
 def get_length_of_file(path):
     cmd = [
         "ffprobe",
         "-v","error",
         "-show_entries", "stream:format=duration",
@@ -137,15 +139,15 @@
     video_def = {"resolution": (stream["height"], stream["width"]),
                  "codec": stream["codec_name"],
                  "codec_description": stream["codec_long_name"],
                  "size": size,
                  "bit_rate": int(stream.get("bit_rate",-1))}
     return video_def
 
-def convert_streaming(host, token, media, path, outpath, raw_width, raw_height, configs):
+def convert_streaming(host, token, media, path, outpath, raw_width, raw_height, configs, hwaccel=False):
     logger.info("Transcoding %s to %s...", path, outpath)
     # Get workload parameters.
     os.makedirs(outpath, exist_ok=True)
 
     # Convert settings into resolution/crf/codec/presets/pixel_formats.
     resolutions = [int(config.split(':')[0]) for config in configs]
     crfs = [config.split(':')[1] for config in configs]
@@ -187,33 +189,36 @@
         transpose = "hflip,vflip"
     elif rotation == 270:
         transpose = "transpose=1"
 
     vid_dims = [raw_height, raw_width]
     cmd = [
         "ffmpeg", "-y",
+        "-loglevel", "error",
+        "-progress", "-",
+        "-stats_period", "10",
         "-noautorotate", "-i", path,
         "-noautorotate", "-i", os.path.join(os.path.dirname(os.path.abspath(__file__)), "black.mp4"),
     ]
 
-    vaapi_present = [c for c in codecs if find_best_encoder(c).find('vaapi') >= 0]
+    vaapi_present = [c for c in codecs if find_best_encoder(c, hwaccel).find('vaapi') >= 0]
     if vaapi_present:
         cmd.extend(['-init_hw_device', 'vaapi=hw',
                     '-filter_hw_device', 'hw'])
 
     logger.info("Transcoding to %s", resolutions)
     for ridx, resolution in enumerate(resolutions):
         per_res = ["-an",
             "-metadata:s", "handler_name=tator",
             "-g", "25",
             "-movflags",
             "faststart+frag_keyframe+empty_moov+default_base_moof"]
         logger.info(f"Generating resolution @ {resolution}")
         output_file = os.path.join(outpath, f"{resolution}.mp4")
-        codec = find_best_encoder(codecs[ridx])
+        codec = find_best_encoder(codecs[ridx], hwaccel)
         quality_flag = "-crf"
         pixel_format = pixel_formats[ridx]
         hw_upload = ''
         preset = presets[ridx]
         if codec.find("vaapi") >= 0:
             quality_flag = "-global_quality"
             pixel_format = SW_TO_HW_PIXEL_FORMAT_CONVERSION[pixel_format]
@@ -303,30 +308,31 @@
                      token,
                      media,
                      path,
                      outpath,
                      raw_width,
                      raw_height,
                      size=None,
-                     explicit_config=None):
+                     explicit_config=None,
+                     hwaccel=False):
     # Retrieve this media's type to inspect archive config.
     api = get_api(host, token)
     media_obj = api.get_media(media)
     media_type = api.get_media_type(media_obj.type)
     config = explicit_config or media_type.archive_config
     if config is not None:
         for idx, archive_config in enumerate(config):
             os.makedirs(outpath, exist_ok=True)
             output_file = os.path.join(outpath, f"archival_{idx}.mp4")
             if archive_config.encode.vcodec == 'copy':
                 # If no encode, just use the original file.
                 output_file = path
             else:
                 # Encode the media to archival format.
-                codec = find_best_encoder(archive_config.encode.vcodec)
+                codec = find_best_encoder(archive_config.encode.vcodec, hwaccel)
                 quality_flag = "-crf"
                 pixel_format = archive_config.encode.pixel_format
                 tune_settings = ["-preset", archive_config.encode.preset,
                                  "-tune", archive_config.encode.tune]
                 if archive_config.encode.movflags:
                     tune_settings.extend(['-movflags', archive_config.encode.movflags])
                 if codec.find("qsv") >= 0:
@@ -341,14 +347,17 @@
                 hw_preamble = []
                 vaapi_present = codec.find('vaapi') >= 0
                 if vaapi_present:
                     hw_preamble = ['-init_hw_device', 'vaapi=hw',
                                    '-filter_hw_device', 'hw']
                 cmd = [
                     "ffmpeg",
+                    "-loglevel", "error",
+                    "-progress", "-",
+                    "-stats_period", "10",
                     *hw_preamble,
                     "-y",
                     "-i", path,
                     "-vcodec", codec,
                     "-vf", "yadif",
                     quality_flag, str(archive_config.encode.crf),
                     "-pix_fmt", pixel_format,
@@ -403,14 +412,17 @@
     return audio_def
 
 def convert_audio(host, token, media, path, outpath):
     os.makedirs(outpath, exist_ok=True)
     logger.info("Extracting audio")
     output_file = os.path.join(outpath, f"audio.m4a")
     audio_extraction=["ffmpeg", "-y",
+                      "-loglevel", "error",
+                      "-progress", "-",
+                      "-stats_period", "10",
                       "-i", path,
                       "-vn", # Strip video
                       "-c:a", "aac",
                       "-ac", "2",
                       output_file]
     subprocess.run(audio_extraction, check=True)
     logger.info("Finished extracting audio!")
```

### Comparing `tator-1.2.9/tator/util/__init__.py` & `tator-1.3.0/tator/util/__init__.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/util/_download_file.py` & `tator-1.3.0/tator/util/_download_file.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/util/_upload_file.py` & `tator-1.3.0/tator/util/_upload_file.py`

 * *Files 4% similar despite different names*

```diff
@@ -37,39 +37,40 @@
                            f"{attempt + 1}/{MAX_RETRIES}")
             if attempt == MAX_RETRIES - 1:
                 raise RuntimeError(f"Upload of {path} failed!")
             else:
                 time.sleep(10 * attempt)
                 logger.warning(f"Backing off for {10 * attempt} seconds...")
 
-def _upload_file(api, project, path, media_id=None, filename=None, chunk_size=1024*1024*10, file_size=None, file_id=None, timeout=30, max_workers=10):
+def _upload_file(api, project, path, media_id=None, filename=None, chunk_size=1024*1024*10, file_size=None, file_id=None, timeout=30, max_workers=10, gcp_compat=True):
     """ Uploads a file.
 
     :param api: `tator.TatorApi` object.
     :param project: Unique integer identifying a project.
     :param path: Path to file on disk.
     :param media_id: [Optional] Media ID if this is an upload for existing media.
     :param filename: [Optional] Filename (only used if media ID is given).
     :param file_id: [Optional] File ID if this is an upload for existing File.
     :param chunk_size: [Optional] Upload chunk size in bytes.
     :param timeout: [Optional] Request timeout for uploads in seconds. Default is 30.
     :param max_workers: [Optional] Max workers for concurrent requests.
+    :param gcp_compat: [Optional] If True, chunk size will be rounded up to the nearest multiple of 256KB for Google Cloud Storage compatibility.
     """
 
     # Get number of chunks.
     if file_size is None or file_size <= 0:
         file_size = os.stat(path).st_size
 
     if math.ceil(file_size / chunk_size) > 10000:
         chunk_size = math.ceil(file_size / 9000)
         logger.warning(
             f"Number of chunks exceeds maximum of 10,000. Increasing chunk size to {chunk_size}."
         )
 
-    if chunk_size % GCP_CHUNK_MOD:
+    if gcp_compat and chunk_size % GCP_CHUNK_MOD:
         logger.warning(
             f"Chunk size must be a multiple of 256KB for Google Cloud Storage compatibility"
         )
         chunk_size = math.ceil(chunk_size / GCP_CHUNK_MOD) * GCP_CHUNK_MOD
 
     if path.startswith('https://') or path.startswith('http://') and filename:
         filename = filename.split('?')[0]
```

### Comparing `tator-1.2.9/tator/util/chunked_create.py` & `tator-1.3.0/tator/util/chunked_create.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/util/chunked_file_list.py` & `tator-1.3.0/tator/util/chunked_file_list.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/util/clone_leaf_list.py` & `tator-1.3.0/tator/util/clone_leaf_list.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/util/clone_leaf_type.py` & `tator-1.3.0/tator/util/clone_leaf_type.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/util/clone_localization_list.py` & `tator-1.3.0/tator/util/clone_localization_list.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/util/clone_localization_type.py` & `tator-1.3.0/tator/util/clone_localization_type.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/util/clone_media_list.py` & `tator-1.3.0/tator/util/clone_media_list.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/util/clone_media_type.py` & `tator-1.3.0/tator/util/clone_media_type.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/util/clone_membership.py` & `tator-1.3.0/tator/util/clone_membership.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/util/clone_section.py` & `tator-1.3.0/tator/util/clone_section.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/util/clone_state_list.py` & `tator-1.3.0/tator/util/clone_state_list.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/util/clone_state_type.py` & `tator-1.3.0/tator/util/clone_state_type.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/util/clone_version.py` & `tator-1.3.0/tator/util/clone_version.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/util/concat.py` & `tator-1.3.0/tator/util/concat.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/util/download_attachment.py` & `tator-1.3.0/tator/util/download_attachment.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/util/download_media.py` & `tator-1.3.0/tator/util/download_media.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/util/download_temporary_file.py` & `tator-1.3.0/tator/util/download_temporary_file.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/util/find_single_change.py` & `tator-1.3.0/tator/util/find_single_change.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/util/full_state_graphic.py` & `tator-1.3.0/tator/util/full_state_graphic.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/util/get_api.py` & `tator-1.3.0/tator/util/get_api.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/util/get_images.py` & `tator-1.3.0/tator/util/get_images.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/util/get_paginator.py` & `tator-1.3.0/tator/util/get_paginator.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/util/get_parser.py` & `tator-1.3.0/tator/util/get_parser.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/util/import_media.py` & `tator-1.3.0/tator/util/import_media.py`

 * *Files 5% similar despite different names*

```diff
@@ -41,15 +41,15 @@
             logger.info(f"Failed to download {url} on attempt {attempt}...")
             if attempt == MAX_RETRIES - 1:
                 raise RuntimeError(f"Reached maximum retries on media download!")
     return md5
 
 def import_media(api, type_id, url, md5=None, section=None, fname=None,
                  upload_gid=None, upload_uid=None,chunk_size=2*1024*1024,
-                 attributes=None, media_id=None, size=None, _request_timeout=10):
+                 attributes=None, media_id=None, size=None, _request_timeout=10, section_id=None):
     """ Imports a hosted media file.
 
     Example:
 
     .. code-block:: python
 
         api = tator.get_api(host, token)
@@ -57,14 +57,15 @@
         print(response.message)
 
     :param api: :class:`tator.TatorApi` object.
     :param type_id: Unique integer identifying a media type.
     :param url: URL of the hosted media file.
     :param md5: [Optional] md5 sum of the media.
     :param section: [Optional] Media section to upload to.
+    :param section_id: [Optional] Unique integer identifying a section. If given `section` is ignored.
     :param fname: [Optional] Filename to use for upload.
     :param upload_gid: [Optional] Group ID of the upload.
     :param upload_uid: [Optional] Unique ID of the upload.
     :param chunk_size: [Optional] Chunk size in bytes. Default is 2MB.
     :param attributes: [Optional] Attributes to apply to media object.
     :param media_id: [Optional] Unique ID of existing media object.
     :param size: [Optional] Size of the file in bytes. Required if the
@@ -80,26 +81,27 @@
         md5 = _hosted_md5(url)
     if upload_uid is None:
         upload_uid = str(uuid1())
     if upload_gid is None:
         upload_gid = str(uuid1())
     if fname is None:
         fname = os.path.basename(urlsplit(url).path)
-    if section is None:
-        section="Imported Files"
+    if section is None and section_id is None:
+        section="New Files"
 
     media_type = api.get_media_type(type_id, _request_timeout=_request_timeout)
     project_id = media_type.project
+    section_blob = {"section": section} if section is not None else {"section_id": section_id}
     spec = {
         'type': type_id,
         'uid': upload_uid,
         'gid': upload_gid,
         'url': url,
         'name': fname,
-        'section': section,
+        **section_blob,
         'md5': md5,
         'attributes': attributes,
         'media_id': media_id,
     }
     if size is not None:
         spec['size'] = size
     # Create video or image.
```

### Comparing `tator-1.2.9/tator/util/live_stream.py` & `tator-1.3.0/tator/util/live_stream.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/util/md5sum.py` & `tator-1.3.0/tator/util/md5sum.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/util/media_manipulation.py` & `tator-1.3.0/tator/util/media_manipulation.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/util/media_util.py` & `tator-1.3.0/tator/util/media_util.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/util/multi_stream.py` & `tator-1.3.0/tator/util/multi_stream.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/util/register_algorithm.py` & `tator-1.3.0/tator/util/register_algorithm.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/util/register_applet.py` & `tator-1.3.0/tator/util/register_applet.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/util/tator-symbol.gif` & `tator-1.3.0/tator/util/tator-symbol.gif`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/util/tator-symbol.png` & `tator-1.3.0/tator/util/tator-symbol.png`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/util/to_dataframe.py` & `tator-1.3.0/tator/util/to_dataframe.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/util/update_applet.py` & `tator-1.3.0/tator/util/update_applet.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/util/upload_attachment.py` & `tator-1.3.0/tator/util/upload_attachment.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/util/upload_generic_file.py` & `tator-1.3.0/tator/util/upload_generic_file.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator/util/upload_media.py` & `tator-1.3.0/tator/util/upload_media.py`

 * *Files 6% similar despite different names*

```diff
@@ -7,15 +7,15 @@
 
 from ._upload_file import _upload_file
 from .md5sum import md5sum
 
 def upload_media(api, type_id, path, md5=None, section=None, fname=None,
                  upload_gid=None, upload_uid=None, chunk_size=10*1024*1024,
                  attributes=None, email_spec=None, media_id=None, timeout=30,
-                 max_workers=10):
+                 max_workers=10, section_id=None):
     """ Uploads a single media file.
 
     Example:
 
     .. code-block:: python
 
         api = tator.get_api(host, token)
@@ -25,14 +25,15 @@
 
     :param api: :class:`tator.TatorApi` object.
     :param type_id: Unique integer identifying a media type.
     :param path: Path to the media file.
     :param md5: [Optional] md5 sum of the media.
     :param section: [Optional] Section name. If a section with this name does
         not exist it will be created.
+    :param section_id: [Optional] Unique integer identifying a section. If given `section` is ignored.
     :param fname: [Optional] Filename to use for upload.
     :param upload_gid: [Optional] Group ID of the upload.
     :param upload_uid: [Optional] Unique ID of the upload.
     :param chunk_size: [Optional] Chunk size in bytes. Default is 2MB.
     :param attributes: [Optional] Attributes to apply to media object.
     :param email_spec: [Optional] Spec for email to be sent upon transcode completion.
     :param media_id: [Optional] Unique ID of existing media object.
@@ -47,15 +48,15 @@
         md5 = md5sum(path)
     if upload_uid is None:
         upload_uid = str(uuid1())
     if upload_gid is None:
         upload_gid = str(uuid1())
     if fname is None:
         fname=os.path.basename(path)
-    if section is None:
+    if section is None and section_id is None:
         section="New Files"
 
     ext = os.path.splitext(fname)[1].lower()
     if ext in [".ts", ".mts", ".m2ts"]:
         mime = "video/MP2T"
     elif ext in [".avif"]:
         mime = "image/avif"
@@ -67,22 +68,23 @@
     project_id = response.project
 
     for progress, upload_info in _upload_file(api, project_id, path, chunk_size=chunk_size, timeout=timeout):
         yield (progress, None)
 
     url = api.get_download_info(project_id, download_info_spec={'keys': [upload_info.key]},
                                 expiration=86400)[0].url
+    section_blob = {"section": section} if section is not None else {"section_id": section_id}
 
     spec = {
         'type': type_id,
         'uid': upload_uid,
         'gid': upload_gid,
         'url': url,
         'name': fname,
-        'section': section,
+        **section_blob,
         'md5': md5,
         'attributes': attributes,
         'media_id': media_id,
         'size': os.stat(path).st_size,
     }
     # Initiate transcode or save image.
     if mime.find('video') >= 0:
```

### Comparing `tator-1.2.9/tator/util/upload_temporary_file.py` & `tator-1.3.0/tator/util/upload_temporary_file.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/tator.egg-info/SOURCES.txt` & `tator-1.3.0/tator.egg-info/SOURCES.txt`

 * *Files 2% similar despite different names*

```diff
@@ -1,7 +1,8 @@
+LICENSE.md
 MANIFEST.in
 README.md
 pyproject.toml
 setup.py
 tator/__init__.py
 tator/version.py
 tator.egg-info/PKG-INFO
@@ -81,15 +82,20 @@
 tator/openapi/tator_openapi/models/file_type_update.py
 tator/openapi/tator_openapi/models/file_update.py
 tator/openapi/tator_openapi/models/fill.py
 tator/openapi/tator_openapi/models/float_array_query.py
 tator/openapi/tator_openapi/models/generic_file.py
 tator/openapi/tator_openapi/models/generic_file_spec.py
 tator/openapi/tator_openapi/models/get_cloned_media_response.py
+tator/openapi/tator_openapi/models/hosted_template.py
+tator/openapi/tator_openapi/models/hosted_template_spec.py
 tator/openapi/tator_openapi/models/image_definition.py
+tator/openapi/tator_openapi/models/inline_response200.py
+tator/openapi/tator_openapi/models/inline_response2001.py
+tator/openapi/tator_openapi/models/inline_response2002.py
 tator/openapi/tator_openapi/models/invitation.py
 tator/openapi/tator_openapi/models/invitation_spec.py
 tator/openapi/tator_openapi/models/invitation_update.py
 tator/openapi/tator_openapi/models/job.py
 tator/openapi/tator_openapi/models/job_cluster.py
 tator/openapi/tator_openapi/models/job_cluster_spec.py
 tator/openapi/tator_openapi/models/job_node.py
@@ -134,21 +140,24 @@
 tator/openapi/tator_openapi/models/message_response.py
 tator/openapi/tator_openapi/models/multi_definition.py
 tator/openapi/tator_openapi/models/not_found_response.py
 tator/openapi/tator_openapi/models/notify_spec.py
 tator/openapi/tator_openapi/models/organization.py
 tator/openapi/tator_openapi/models/organization_spec.py
 tator/openapi/tator_openapi/models/organization_update.py
+tator/openapi/tator_openapi/models/parameter.py
 tator/openapi/tator_openapi/models/password_reset_spec.py
 tator/openapi/tator_openapi/models/project.py
 tator/openapi/tator_openapi/models/project_spec.py
 tator/openapi/tator_openapi/models/project_update.py
 tator/openapi/tator_openapi/models/resolution_config.py
 tator/openapi/tator_openapi/models/s3_storage_config.py
 tator/openapi/tator_openapi/models/section.py
+tator/openapi/tator_openapi/models/section_bulk_update.py
+tator/openapi/tator_openapi/models/section_bulk_update_path_substitution.py
 tator/openapi/tator_openapi/models/section_spec.py
 tator/openapi/tator_openapi/models/section_update.py
 tator/openapi/tator_openapi/models/state.py
 tator/openapi/tator_openapi/models/state_bulk_delete.py
 tator/openapi/tator_openapi/models/state_bulk_update.py
 tator/openapi/tator_openapi/models/state_delete.py
 tator/openapi/tator_openapi/models/state_id_query.py
@@ -208,21 +217,23 @@
 tator/util/find_single_change.py
 tator/util/full_state_graphic.py
 tator/util/get_api.py
 tator/util/get_images.py
 tator/util/get_paginator.py
 tator/util/get_parser.py
 tator/util/import_media.py
+tator/util/import_resumable.py
 tator/util/live_stream.py
 tator/util/md5sum.py
 tator/util/media_manipulation.py
 tator/util/media_util.py
 tator/util/multi_stream.py
 tator/util/register_algorithm.py
 tator/util/register_applet.py
+tator/util/resumable_upload.py
 tator/util/tator-symbol.gif
 tator/util/tator-symbol.png
 tator/util/to_dataframe.py
 tator/util/update_applet.py
 tator/util/upload_attachment.py
 tator/util/upload_generic_file.py
 tator/util/upload_media.py
@@ -250,14 +261,15 @@
 test/test_collection.py
 test/test_download_media.py
 test/test_extract.py
 test/test_file.py
 test/test_file_type.py
 test/test_get_clip.py
 test/test_getframe.py
+test/test_hosted_template.py
 test/test_import_media.py
 test/test_job_cancel.py
 test/test_job_cluster.py
 test/test_leaf.py
 test/test_leaf_type.py
 test/test_local_transcode.py
 test/test_localization.py
```

### Comparing `tator-1.2.9/test/test_a_float_array.py` & `tator-1.3.0/test/test_a_float_array.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/test/test_algorithm.py` & `tator-1.3.0/test/test_algorithm.py`

 * *Files 1% similar despite different names*

```diff
@@ -169,19 +169,21 @@
         project: Unique identifier of test project
     """
 
     _missing_upload_file(host=host, token=token, project=project)
 
     response_1 = _upload_test_algorithm_manifest(
         host=host, token=token, project=project, manifest_name='test_nodupe.yaml')
-    assert os.path.basename(response_1.url) == 'test_nodupe.yaml'
-
+    assert os.path.basename(response_1.url) != "test_nodupe.yaml"
+    url_1 = os.path.basename(response_1.url)
     response_2 = _upload_test_algorithm_manifest(
         host=host, token=token, project=project, manifest_name='test_nodupe.yaml')
-    assert os.path.basename(response_2.url) == 'test_nodupe_0.yaml'
+    assert os.path.basename(response_2.url) != "test_nodupe.yaml"
+    url_2 = os.path.basename(response_2.url)
+    assert url_1 != url_2
 
 def test_register_algorithm(host: str, token: str, project: int, algo_project: int) -> None:
     """ Unit test for the RegisterAlgorithm endpoint
 
     Unit testing of the algorithm registration endpoint involves the following:
     - Create a request body that's fine, but has bad syntax for the .yaml file
     - Create a request body for a .yaml file that doesn't exist
```

### Comparing `tator-1.2.9/test/test_algorithm_launch.py` & `tator-1.3.0/test/test_algorithm_launch.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/test/test_applet.py` & `tator-1.3.0/test/test_applet.py`

 * *Files 2% similar despite different names*

```diff
@@ -95,19 +95,21 @@
     :param project: Unique identifier of test project
     """
 
     _missing_upload_file(host=host, token=token, project=project)
 
     response_1 = _upload_test_html_file(
         host=host, token=token, project=project, html_file='test_nodupe.html')
-    assert os.path.basename(response_1.url) == 'test_nodupe.html'
-
+    assert os.path.basename(response_1.url) != "test_nodupe.html"
+    url_1 = os.path.basename(response_1.url)
     response_2 = _upload_test_html_file(
         host=host, token=token, project=project, html_file='test_nodupe.html')
-    assert os.path.basename(response_2.url) == 'test_nodupe_0.html'
+    assert os.path.basename(response_2.url) != "test_nodupe.html"
+    url_2 = os.path.basename(response_2.url)
+    assert url_1 != url_2
 
 def test_dashboard_endpoint(host: str, token: str, project: int) -> None:
     """ Unit tests for the dashboard endpoint
 
     :param host: Project URL
     :param token: User token used for connecting to the host
     :param project: Unique identifier of test project
@@ -181,8 +183,8 @@
     assert dashboard.description == update["description"]
     assert dashboard.categories == update["categories"]
     assert dashboard.html_file != original.html_file
 
     # Test deleting a dashboard
     tator_api.delete_applet(id=dashboard.id)
     dashboards = tator_api.get_applet_list(project=project)
-    assert len(dashboards) == 2
+    assert len(dashboards) == 2
```

### Comparing `tator-1.2.9/test/test_archive_date.py` & `tator-1.3.0/test/test_archive_date.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/test/test_attachment.py` & `tator-1.3.0/test/test_attachment.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/test/test_attribute_type_addition.py` & `tator-1.3.0/test/test_attribute_type_addition.py`

 * *Files 1% similar despite different names*

```diff
@@ -16,26 +16,26 @@
         "test_bool": random.choice([False, True]),
         "test_int": random.randint(-1000, 1000),
         "test_float": random.uniform(-1000.0, 1000.0),
         "test_enum": random.choice(["a", "b", "c"]),
         "test_string": str(uuid4()),
         "test_datetime": datetime.now().isoformat(),
         "test_geopos": [random.uniform(-180.0, 180.0), random.uniform(-90.0, 90.0)],
-        'test_float_array': [random.uniform(-1.0, 1.0) for _ in range(3)],
+        "test_float_array": [random.uniform(-1.0, 1.0) for _ in range(3)],
     }
     out = {
         "x": x,
         "y": y,
         "width": w,
         "height": h,
         "project": project,
         "type": box_type,
         "media_id": video_obj.id,
         "frame": random.randint(0, video_obj.num_frames - 1),
-        "attributes": attributes
+        "attributes": attributes,
     }
 
     return {**out}
 
 
 def add_attribute_helper(tator_api, type_getter, type_id, dtype):
     new_attr_name = f"New {dtype} {uuid4()}"
@@ -71,15 +71,15 @@
 
     # Adding an attribute with an invalid `dtype` should raise an exception
     with pytest.raises(tator.openapi.tator_openapi.exceptions.ApiException) as excinfo:
         tator_api.create_attribute_type(id=type_id, attribute_type_spec=addition)
 
     # Check the exeption message for expected content
     assert (
-        "ValidationError: \\\"'unknown' is not one of ['bool', 'int', 'float', 'enum', 'string', 'datetime', 'geopos', 'float_array']\\\""
+        "ValidationError: \\\"'unknown' is not one of ['bool', 'int', 'float', 'enum', 'string', 'datetime', 'geopos', 'float_array', 'blob']\\\""
         in str(excinfo.value)
     )
 
 
 def test_box_type_add_invalid_attribute(host, token, project, attribute_box_type):
     tator_api = tator.get_api(host, token)
     add_invalid_attribute_helper(tator_api, tator_api.get_localization_type, attribute_box_type)
@@ -130,15 +130,15 @@
     }
 
     # Adding an enum attribute without a `choices` field should raise an exception
     with pytest.raises(tator.openapi.tator_openapi.exceptions.ApiException) as excinfo:
         tator_api.create_attribute_type(id=attribute_video_type, attribute_type_spec=addition)
 
     # Check the exeption message for expected content
-    assert "ValueError: enum attribute type definition missing 'choices' field" in str(
+    assert "enum attribute type definition missing 'choices' field" in str(
         excinfo.value
     )
 
 
 def test_add_same_attribute_twice(host, token, project, line_type):
     tator_api = tator.get_api(host, token)
     new_attr_name = f"New attribute {uuid4()}"
```

### Comparing `tator-1.2.9/test/test_attribute_type_deletion.py` & `tator-1.3.0/test/test_attribute_type_deletion.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/test/test_attribute_type_mutation.py` & `tator-1.3.0/test/test_attribute_type_mutation.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/test/test_attributes.py` & `tator-1.3.0/test/test_attributes.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/test/test_change_log.py` & `tator-1.3.0/test/test_change_log.py`

 * *Files 2% similar despite different names*

```diff
@@ -21,15 +21,15 @@
         "test_float_array": [random.uniform(-1.0, 1.0) for _ in range(3)],
     }
     out = {
         "project": project,
         "type": state_type,
         "media_ids": [video_obj.id],
         "frame": random.randint(0, video_obj.num_frames - 1),
-        "attributes": attributes
+        "attributes": attributes,
     }
 
     return {**out}
 
 
 def random_localization(project, box_type, video_obj, post=False):
     x = random.uniform(0.0, 1.0)
@@ -51,15 +51,15 @@
         "y": y,
         "width": w,
         "height": h,
         "project": project,
         "type": box_type,
         "media_id": video_obj.id,
         "frame": random.randint(0, video_obj.num_frames - 1),
-        "attributes": attributes
+        "attributes": attributes,
     }
 
     return {**out}
 
 
 def random_leaf(project, leaf_type, parent_obj=None, post=False):
     attributes = {
@@ -69,20 +69,15 @@
         "test_enum": random.choice(["a", "b", "c"]),
         "test_string": str(uuid.uuid1()),
         "test_datetime": datetime.now().isoformat(),
         "test_geopos": [random.uniform(-180.0, 180.0), random.uniform(-90.0, 90.0)],
         "test_float_array": [random.uniform(-1.0, 1.0) for _ in range(3)],
     }
     name = "".join(random.choice(string.ascii_letters) for _ in range(10))
-    out = {
-        "project": project,
-        "type": leaf_type,
-        "name": name,
-        "attributes": attributes
-    }
+    out = {"project": project, "type": leaf_type, "name": name, "attributes": attributes}
     if parent_obj:
         out["parent"] = parent_obj.id
 
     return {**out}
 
 
 def compare_change_logs(new, old):
@@ -135,18 +130,20 @@
         # Assert all new values match initial creation values
         for change in changes.description_of_change.new:
             if change.name == "_id":
                 assert change.value == entity_id
             elif change.name in ["_x", "_y", "_width", "_height", "_frame"]:
                 assert change.value == box[change.name.replace("_", "")]
             elif change.name.startswith("test_"):
-                assert change.value == box['attributes'][change.name]
+                assert change.value == box["attributes"][change.name]
         create_changes.append(changes)
 
     patch_entities = [random_entity() for _ in range(num_entities)]
+    for p in patch_entities:
+        p["in_place"] = 1
     for entity_id, patch_entity in zip(entity_ids, patch_entities):
         update_one(entity_id, patch_entity)
 
     # Update tests
     patch_changes = []
     for entity_id, box, old_change_log in zip(entity_ids, patch_entities, create_changes):
         changes = tator_api.get_change_log_list(
@@ -171,15 +168,15 @@
             elif change.name in ["_x", "_y", "_width", "_height", "_frame"]:
                 assert change.value == box[change.name.replace("_", "")]
             elif change.name.startswith("test_"):
                 assert change.value == box["attributes"][change.name]
         patch_changes.append(new_change_log)
 
     bulk_patch_entity = random_entity()
-    bulk_patch_entity = {"attributes": bulk_patch_entity["attributes"]}
+    bulk_patch_entity = {"attributes": bulk_patch_entity["attributes"], "in_place": 1}
     update_list(bulk_patch_entity)
 
     # Bulk update tests
     bulk_patch_changes = []
     for entity_id, create_change_log, patch_change_log in zip(
         entity_ids, create_changes, patch_changes
     ):
@@ -205,41 +202,14 @@
                 assert change.value == bulk_patch_entity["attributes"][change.name]
         bulk_patch_changes.append(new_change_log)
 
     # Clean up
     delete_one(entity_ids[0])
     delete_list()
 
-    # Deletion tests
-    for entity_id, create_change_log, patch_change_log, bulk_change_log in zip(
-        entity_ids, create_changes, patch_changes, bulk_patch_changes
-    ):
-        changes = tator_api.get_change_log_list(
-            project=project, entity_id=entity_id, entity_type=entity_type
-        )
-
-        # Assert three changes returned
-        assert len(changes) == 4
-        for new_change_log in changes:
-            if new_change_log.id not in [
-                patch_change_log.id,
-                create_change_log.id,
-                bulk_change_log.id,
-            ]:
-                break
-        else:
-            assert False, "No deletion change log detected"
-
-        # Assert all old values are from update
-        compare_change_logs(new_change_log, bulk_change_log)
-
-        # Assert all new values are None for deletion
-        for change in new_change_log.description_of_change.new:
-            assert change.value == True
-
 
 def test_attribute_box_type_change_log(host, token, project, attribute_video, attribute_box_type):
     tator_api = tator.get_api(host, token)
     video_obj = tator_api.get_media(attribute_video)
     random_entity = partial(random_localization, project, attribute_box_type, video_obj)
     create_list = tator_api.create_localization_list
     update_one = tator_api.update_localization
@@ -459,15 +429,15 @@
         # Assert all new values match initial creation values
         for change in changes.description_of_change.new:
             if change.name == "_id":
                 assert change.value == leaf_id
             elif change.name in ["_project", "_name", "_type"]:
                 assert change.value == leaf_spec[change.name.replace("_", "")]
             elif change.name.startswith("test_"):
-                assert change.value == leaf_spec['attributes'][change.name]
+                assert change.value == leaf_spec["attributes"][change.name]
         create_changes.append(changes)
 
     patch_leaves = [random_leaf(project, leaf_type) for _ in range(num_leaves)]
     for leaf_id, patch_leaf in zip(leaf_ids, patch_leaves):
         tator_api.update_leaf(leaf_id, leaf_update=patch_leaf)
 
     # Update tests
@@ -575,15 +545,14 @@
         "gid": str(uuid.uuid1()),
         "name": fname,
         "md5": str(uuid.uuid1())[:32],
         "section": "Test media change log",
         "attributes": {"test_int": test_int},
     }
 
-
     # Create the media.
     media_id = tator_api.create_media_list(project=project, body=media_spec).id
 
     # Look for change that shouldn't be there
     found_change = tator.util.find_single_change(
         tator_api, project, media_id, "test_int", new_value=test_int - 1
     )
```

### Comparing `tator-1.2.9/test/test_chunked_create.py` & `tator-1.3.0/test/test_chunked_create.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/test/test_clone_leaf_type.py` & `tator-1.3.0/test/test_clone_leaf_type.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/test/test_clone_localization_type.py` & `tator-1.3.0/test/test_clone_localization_type.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/test/test_clone_media.py` & `tator-1.3.0/test/test_clone_media.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/test/test_clone_media_type.py` & `tator-1.3.0/test/test_clone_media_type.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/test/test_clone_membership.py` & `tator-1.3.0/test/test_clone_membership.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/test/test_clone_section.py` & `tator-1.3.0/test/test_clone_section.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/test/test_clone_state_type.py` & `tator-1.3.0/test/test_clone_state_type.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/test/test_clone_version.py` & `tator-1.3.0/test/test_clone_version.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/test/test_collection.py` & `tator-1.3.0/test/test_collection.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/test/test_download_media.py` & `tator-1.3.0/test/test_download_media.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/test/test_extract.py` & `tator-1.3.0/test/test_extract.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/test/test_file.py` & `tator-1.3.0/test/test_file.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/test/test_file_type.py` & `tator-1.3.0/test/test_file_type.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/test/test_get_clip.py` & `tator-1.3.0/test/test_get_clip.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/test/test_getframe.py` & `tator-1.3.0/test/test_getframe.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/test/test_import_media.py` & `tator-1.3.0/test/test_import_media.py`

 * *Files 14% similar despite different names*

```diff
@@ -38,7 +38,31 @@
     media_fields = ["archival", "_audio", "_streaming", "_thumbnail", "_thumbnail_gif"]
 
     for field in media_fields:
         assert (
             len(getattr(initial_obj.media_files, field)) ==
             len(getattr(final_obj.media_files, field))
         )
+
+def test_import_video_to_section_id(host, token, project, video_type):
+    api = tator.get_api(host, token)
+    url = 'http://www.ballastmedia.com/wp-content/uploads/AudioVideoSyncTest_BallastMedia.mp4'
+    section_id = api.create_section(project, {"name":"Video import to section ID"}).id
+    response = tator.util.import_media(api, video_type, url, _request_timeout=30, section_id=section_id)
+    print(response.message)
+    wait_for_transcode(api, response.id)
+
+    # Attempt to import the same video to the same media id, no additional transcodes should occur
+    media_id = response.object['spec']['media_id']
+    initial_obj = api.get_media(media_id)
+    response = tator.util.import_media(api, video_type, url, media_id=media_id, _request_timeout=30)
+    print(response.message)
+    wait_for_transcode(api, response.id)
+    final_obj = api.get_media(media_id)
+
+    media_fields = ["archival", "_audio", "_streaming", "_thumbnail", "_thumbnail_gif"]
+
+    for field in media_fields:
+        assert (
+            len(getattr(initial_obj.media_files, field)) ==
+            len(getattr(final_obj.media_files, field))
+        )
```

### Comparing `tator-1.2.9/test/test_job_cancel.py` & `tator-1.3.0/test/test_job_cancel.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/test/test_job_cluster.py` & `tator-1.3.0/test/test_job_cluster.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/test/test_leaf.py` & `tator-1.3.0/test/test_leaf.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/test/test_leaf_type.py` & `tator-1.3.0/test/test_leaf_type.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/test/test_local_transcode.py` & `tator-1.3.0/test/test_local_transcode.py`

 * *Files 6% similar despite different names*

```diff
@@ -64,17 +64,17 @@
     media_obj = api.get_media_list(project, name=unique_name, presigned=3600)[0]
 
     stream_info = _get_stream_info(media_obj.media_files.archival[0].path)
     assert stream_info['pix_fmt'] == 'yuv444p'
     stream_info = _get_stream_info(media_obj.media_files.streaming[0].path)
     assert stream_info['pix_fmt'] == 'yuv444p'
 
-def test_bad_file(host, token, project, video_type, image_file):
+def test_bad_file(host, token, project, video_type, corrupted_video_file):
     cmd = [
-        'python3', '-m', 'tator.transcode', image_file,
+        'python3', '-m', 'tator.transcode', corrupted_video_file,
         '--host', host,
         '--token', token,
         '--project', str(project),
         '--type', str(video_type),
         '--section', 'Bad transcodes',
     ]
     _assert_subprocess(cmd, False)
```

### Comparing `tator-1.2.9/test/test_localization.py` & `tator-1.3.0/test/test_localization.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,57 +1,62 @@
 from pprint import pformat
 import datetime
 import random
 from time import sleep
 import uuid
 from collections import Counter
+import pytest
 
 import tator
 from ._common import assert_close_enough
 
+
 def random_localization(project, box_type, video_obj, post=False):
     x = random.uniform(0.0, 1.0)
     y = random.uniform(0.0, 1.0)
     w = random.uniform(0.0, 1.0 - x)
     h = random.uniform(0.0, 1.0 - y)
     attributes = {
-        'test_bool': random.choice([False, True]),
-        'test_int': random.randint(-1000, 1000),
-        'test_float': random.uniform(-1000.0, 1000.0),
-        'test_enum': random.choice(['a', 'b', 'c']),
-        'test_string': str(uuid.uuid1()),
-        'test_datetime': datetime.datetime.now().isoformat(),
-        'test_geopos': [random.uniform(-180.0, 180.0), random.uniform(-90.0, 90.0)],
-        'test_float_array': [random.uniform(-1.0, 1.0) for _ in range(3)],
+        "test_bool": random.choice([False, True]),
+        "test_int": random.randint(-1000, 1000),
+        "test_float": random.uniform(-1000.0, 1000.0),
+        "test_enum": random.choice(["a", "b", "c"]),
+        "test_string": str(uuid.uuid1()),
+        "test_datetime": datetime.datetime.now().isoformat(),
+        "test_geopos": [random.uniform(-180.0, 180.0), random.uniform(-90.0, 90.0)],
+        "test_float_array": [random.uniform(-1.0, 1.0) for _ in range(3)],
     }
     out = {
-        'x': x,
-        'y': y,
-        'width': w,
-        'height': h,
-        'project': project,
-        'type': box_type,
-        'media_id': video_obj.id,
-        'frame': random.randint(0, video_obj.num_frames - 1),
-        'attributes': attributes
+        "x": x,
+        "y": y,
+        "width": w,
+        "height": h,
+        "project": project,
+        "type": box_type,
+        "media_id": video_obj.id,
+        "frame": random.randint(0, video_obj.num_frames - 1),
+        "attributes": attributes,
     }
 
     return {**out}
 
+
 def comparison_query(tator_api, project, box_ids, exclude):
-    """ Runs a random query and compares results with ES enabled and disabled.
-    """
+    """Runs a random query and compares results with ES enabled and disabled."""
     bool_value = random.choice([True, False])
     int_lower = random.randint(-1000, 0)
     int_upper = random.randint(0, 1000)
     float_lower = random.uniform(-1000.0, 0.0)
     float_upper = random.uniform(0.0, 1000.0)
-    enum_value = random.choice(['a', 'b', 'c'])
+    enum_value = random.choice(["a", "b", "c"])
     localization_id_query = {"ids": box_ids}
-    attribute_filter = [f"test_bool::{'true' if bool_value else 'false'}", f"test_enum::{enum_value}"]
+    attribute_filter = [
+        f"test_bool::{'true' if bool_value else 'false'}",
+        f"test_enum::{enum_value}",
+    ]
     attribute_lte_filter = [f"test_int::{int_upper}"]
     attribute_gte_filter = [f"test_int::{int_lower}"]
     attribute_lt_filter = [f"test_float::{float_upper}"]
     attribute_gt_filter = [f"test_float::{float_lower}"]
     print("Starting PSQL query...")
     t0 = datetime.datetime.now()
     from_psql = tator_api.get_localization_list_by_id(
@@ -69,159 +74,201 @@
     from_es = tator_api.get_localization_list_by_id(
         project,
         localization_id_query=localization_id_query,
         attribute=attribute_filter,
         attribute_lte=attribute_lte_filter,
         attribute_gte=attribute_gte_filter,
         attribute_lt=attribute_lt_filter,
-        attribute_gt=attribute_gt_filter
+        attribute_gt=attribute_gt_filter,
     )
     es_time = datetime.datetime.now() - t0
 
     print("Checking PSQL and ES ids...")
     psql_ids = [ele.id for ele in from_psql]
     es_ids = [ele.id for ele in from_es]
-    assert(Counter(psql_ids) == Counter(es_ids))
+    assert Counter(psql_ids) == Counter(es_ids)
 
     print("Checking PSQL and ES values...")
     assert len(from_psql) == len(from_es)
     for psql, es in zip(from_psql, from_es):
         assert_close_enough(psql, es, exclude)
-        assert(psql.attributes['test_bool'] == bool_value)
-        assert(psql.attributes['test_int'] <= int_upper)
-        assert(psql.attributes['test_int'] >= int_lower)
-        assert(psql.attributes['test_float'] < float_upper)
-        assert(psql.attributes['test_float'] > float_lower)
-        assert(psql.attributes['test_enum'] == enum_value)
+        assert psql.attributes["test_bool"] == bool_value
+        assert psql.attributes["test_int"] <= int_upper
+        assert psql.attributes["test_int"] >= int_lower
+        assert psql.attributes["test_float"] < float_upper
+        assert psql.attributes["test_float"] > float_lower
+        assert psql.attributes["test_enum"] == enum_value
     return psql_time, es_time
 
+
 def test_localization_crud(host, token, project, video_type, video_temp, box_type):
     tator_api = tator.get_api(host, token)
     video_obj = tator_api.get_media(video_temp)
 
     # These fields will not be checked for object equivalence after patch.
-    exclude = ['project', 'type', 'media_id', 'id', 'type', 'user', 'ids']
-    mapping = {'new_version': 'version'}
+    exclude = ["project", "type", "media_id", "id", "type", "user", "ids", "in_place"]
+    mapping = {"new_version": "version"}
 
     # Test bulk create.
     num_localizations = random.randint(2000, 10000)
     existing = len(tator_api.get_localization_list(project, type=box_type, media_id=[video_temp]))
     boxes = [
         random_localization(project, box_type, video_obj, post=True)
         for _ in range(num_localizations)
     ]
     box_ids = []
     for response in tator.util.chunked_create(
-            tator_api.create_localization_list, project, body=boxes
+        tator_api.create_localization_list, project, body=boxes
     ):
         box_ids += response.id
     assert len(box_ids) == len(boxes)
     print(f"Created {len(box_ids)} boxes!")
 
     # Verify list is the right length
-    response = tator_api.get_localization_list(project,type=box_type, media_id=[video_temp])
+    response = tator_api.get_localization_list(project, type=box_type, media_id=[video_temp])
     assert len(response) == num_localizations + existing
 
     # Test media retrieval by localization ID.
-    response = tator_api.get_media_list_by_id(project, {'localization_ids': box_ids})
+    response = tator_api.get_media_list_by_id(project, {"localization_ids": box_ids})
     assert len(response) == 1
     assert response[0].id == video_temp
 
     # Test box retrieval by media ID.
-    response = tator_api.get_localization_list_by_id(project, {'media_ids': [video_temp]})
-    assert(len(response) == len(box_ids))
+    response = tator_api.get_localization_list_by_id(project, {"media_ids": [video_temp]})
+    assert len(response) == len(box_ids)
 
     # Test single create.
     box = random_localization(project, box_type, video_obj, post=True)
     response = tator_api.create_localization_list(project, body=box)
     assert isinstance(response, tator.models.CreateListResponse)
     box_id = response.id[0]
+    response = tator_api.get_localization(box_id)
+    version_id = response.version
+    elemental_id = response.elemental_id
 
-    # Patch single box.
+    # Patch single box (in-place)
     patch = random_localization(project, box_type, video_obj)
-    response = tator_api.update_localization(box_id, localization_update=patch)
-    assert isinstance(response, tator.models.MessageResponse)
+    update_msg = {**patch, "in_place": 1}
+    response = tator_api.update_localization(box_id, localization_update=update_msg)
+    assert "message" in response.to_dict()
     print(response.message)
 
     # Get single box.
     updated_box = tator_api.get_localization(box_id)
     assert_close_enough(patch, updated_box, exclude)
 
     # Get box by ID.
-    box_by_id = tator_api.get_localization_list_by_id(project, {'ids': [box_id]})
-    assert(len(box_by_id) == 1)
+    box_by_id = tator_api.get_localization_list_by_id(project, {"ids": [box_id]})
+    assert len(box_by_id) == 1
     box_by_id = box_by_id[0]
     assert_close_enough(updated_box, box_by_id, exclude)
 
+    # Patch single box via eid
+    patch = random_localization(project, box_type, video_obj)
+    response = tator_api.update_localization_by_elemental_id(
+        version_id, elemental_id, localization_update=patch
+    )
+    assert "message" in response.to_dict()
+    print(response.message)
+
+    # Get single box.
+    updated_box = tator_api.get_localization_by_elemental_id(version_id, elemental_id)
+    assert_close_enough(patch, updated_box, exclude)
+
     # Delete single box.
-    response = tator_api.delete_localization(box_id)
-    assert isinstance(response, tator.models.MessageResponse)
+    response = tator_api.delete_localization_by_elemental_id(version_id, elemental_id)
+    assert "message" in response.to_dict()
     print(response.message)
 
-    params = {'media_id': [video_temp], 'type': box_type}
-    assert(tator_api.get_localization_count(project, **params) == len(boxes) + existing)
+    params = {"media_id": [video_temp], "type": box_type}
+    assert tator_api.get_localization_count(project, **params) == len(boxes) + existing
 
     # Bulk update box attributes.
     response = tator_api.create_version(
         project,
         version_spec={
             "name": "Test Version",
             "description": "A version for testing",
         },
     )
     new_version = response.id
     bulk_patch = random_localization(project, box_type, video_obj)
-    bulk_patch = {"attributes": bulk_patch["attributes"], "new_version": new_version}
-    response = tator_api.update_localization_list(project, **params,
-                                                  localization_bulk_update=bulk_patch)
+    bulk_patch = {"attributes": bulk_patch["attributes"], "new_version": new_version, "in_place": 1}
+    count = tator_api.get_localization_count(project, **params)
+    with pytest.raises(tator.openapi.tator_openapi.exceptions.ApiException):
+        response = tator_api.update_localization_list(
+            project, **params, localization_bulk_update=bulk_patch, count=count + 1)
+    response = tator_api.update_localization_list(
+        project, **params, localization_bulk_update=bulk_patch, count=count
+    )
     assert isinstance(response, tator.models.MessageResponse)
     print(response.message)
 
     # Bulk update specified boxes by ID.
+    boxes = tator_api.get_localization_list(project, type=box_type, media_id=[video_obj.id])
     id_bulk_patch = random_localization(project, box_type, video_obj)
+    box_ids = [x.id for x in boxes]
     update_ids = random.choices(box_ids, k=100)
     id_bulk_patch = {
         "attributes": id_bulk_patch["attributes"],
         "ids": update_ids,
         "new_version": new_version,
+        "in_place": 1,
     }
-    response = tator_api.update_localization_list(project, **params,
-                                                  localization_bulk_update=id_bulk_patch)
+    response = tator_api.update_localization_list(
+        project, **params, localization_bulk_update=id_bulk_patch
+    )
     assert isinstance(response, tator.models.MessageResponse)
     print(response.message)
 
     # Verify all boxes have been updated.
-    boxes = tator_api.get_localization_list(project, **params)
+    boxes = tator_api.get_localization_list(project, **params, version=[new_version])
     dataframe = tator.util.to_dataframe(boxes)
-    assert(len(boxes)==len(dataframe))
+    assert len(boxes) == len(dataframe)
     for box in boxes:
         if box.id in update_ids:
             assert_close_enough(id_bulk_patch, box, exclude, mapping)
         else:
             assert_close_enough(bulk_patch, box, exclude, mapping)
 
     # Clone boxes to same media.
     version_mapping = {version.id: version.id for version in tator_api.get_version_list(project)}
-    generator = tator.util.clone_localization_list(tator_api, {**params, 'project': project},
-                                                   project, version_mapping, {video_temp:video_temp},
-                                                   {box_type: box_type}, tator_api)
+    generator = tator.util.clone_localization_list(
+        tator_api,
+        {**params, "project": project},
+        project,
+        version_mapping,
+        {video_temp: video_temp},
+        {box_type: box_type},
+        tator_api,
+    )
     for num_created, num_total, response, id_map in generator:
         print(f"Created {num_created} of {num_total} localizations...")
     print(f"Finished creating {num_created} localizations!")
-    assert(tator_api.get_localization_count(project, **params) == 2 * (len(boxes)+existing))
+    assert tator_api.get_localization_count(project, **params) == 2 * (len(boxes) + existing)
 
     # Delete all boxes.
-    response = tator_api.delete_localization_list(project, **params)
+    count = tator_api.get_localization_count(project, **params)
+    with pytest.raises(tator.openapi.tator_openapi.exceptions.ApiException):
+        response = tator_api.delete_localization_list(project, **params, count=count + 1)
+    response = tator_api.delete_localization_list(project, **params, count=count)
     assert isinstance(response, tator.models.MessageResponse)
 
     # Verify all boxes are gone.
     boxes = tator_api.get_localization_list(project, **params)
     assert boxes == []
 
-    boxes = tator_api.get_localization_list(project, **params, show_deleted=1)
+    boxes = tator_api.get_localization_list(project, **params, show_deleted=1, show_all_marks=1)
     assert boxes != []
 
-    response = tator_api.delete_localization_list(project, **params, show_deleted=1, merge=0, localization_bulk_delete={'prune':1})
+    response = tator_api.delete_localization_list(
+        project,
+        **params,
+        show_deleted=1,
+        merge=0,
+        show_all_marks=1,
+        localization_bulk_delete={"prune": 1},
+    )
     assert isinstance(response, tator.models.MessageResponse)
 
     # Clean up test version
     tator_api.delete_version(new_version)
```

### Comparing `tator-1.2.9/test/test_localization_graphic.py` & `tator-1.3.0/test/test_localization_graphic.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/test/test_localization_type.py` & `tator-1.3.0/test/test_localization_type.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/test/test_media.py` & `tator-1.3.0/test/test_media.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,14 +1,15 @@
 from datetime import datetime
 import os
 from random import randint
 import tempfile
 from time import sleep
 from urllib.parse import parse_qs, urlparse
 from uuid import uuid1
+import pytest
 
 import tator
 
 def test_get_file(host, token, project, video):
     tator_api = tator.get_api(host, token)
     video_obj = tator_api.get_media(video)
 
@@ -115,15 +116,17 @@
     response = tator_api.update_media(
         video, {"attributes": {"tator_user_sections": ""}}
     )
     media = tator_api.get_media(video)
     assert media.attributes["tator_user_sections"] == ""
 
     # Update media `tator_user_sections` attribute with a bulk update
-    response = tator_api.update_media_list(project, media_id=[video], media_bulk_update=update_spec)
+    with pytest.raises(tator.openapi.tator_openapi.exceptions.ApiException):
+        response = tator_api.update_media_list(project, media_id=[video], media_bulk_update=update_spec, count=2)
+    response = tator_api.update_media_list(project, media_id=[video], media_bulk_update=update_spec, count=1)
     media = tator_api.get_media(video)
     assert media.attributes["tator_user_sections"] == section_spec["tator_user_sections"]
 
     # Unset media `tator_user_sections` attribute with a bulk update
     response = tator_api.update_media_list(
         project,
         media_id=[video],
@@ -257,7 +260,26 @@
     # cached urls and not the ones from the new duration
     video_obj = tator_api.get_media(video_id, presigned=original_presigned_duration, no_cache=False)
     no_cache_false_presigned_url = parse_media_files(video_obj)
 
     for path, query_params in no_cache_false_presigned_url.items():
         assert path in init_presigned_url
         assert int(query_params[expires_key][0]) == original_presigned_duration
+
+def test_upload_to_section_id(host, token, project, image_type, image_file):
+    tator_api = tator.get_api(host, token)
+    section_spec = {
+        "name": "Section ID test",
+        "tator_user_sections": str(uuid1()),
+    }
+    section_id = tator_api.create_section(project, section_spec).id
+    attributes = {"test_string": str(uuid1())}
+    for progress, response in tator.util.upload_media(
+            tator_api, image_type, image_file, section_id=section_id, attributes=attributes
+    ):
+        print(f"Upload image to section by ID progress: {progress}%")
+    print(response.message)
+    media_list = tator_api.get_media_list(
+        project,
+        section=section_id,
+    )
+    assert(len(media_list) == 1)
```

### Comparing `tator-1.2.9/test/test_media_type.py` & `tator-1.3.0/test/test_media_type.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/test/test_multi.py` & `tator-1.3.0/test/test_multi.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/test/test_pagination.py` & `tator-1.3.0/test/test_pagination.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/test/test_poly.py` & `tator-1.3.0/test/test_poly.py`

 * *Files 16% similar despite different names*

```diff
@@ -4,63 +4,69 @@
 from time import sleep
 import uuid
 from collections import Counter
 
 import tator
 from ._common import assert_close_enough
 
+
 def random_localization(project, poly_type, video_obj, post=False):
     attributes = {
-        'test_bool': random.choice([False, True]),
-        'test_int': random.randint(-1000, 1000),
-        'test_float': random.uniform(-1000.0, 1000.0),
-        'test_enum': random.choice(['a', 'b', 'c']),
-        'test_string': str(uuid.uuid1()),
-        'test_datetime': datetime.datetime.now().isoformat(),
-        'test_geopos': [random.uniform(-180.0, 180.0), random.uniform(-90.0, 90.0)],
-        'test_float_array': [random.uniform(-1.0, 1.0) for _ in range(3)],
+        "test_bool": random.choice([False, True]),
+        "test_int": random.randint(-1000, 1000),
+        "test_float": random.uniform(-1000.0, 1000.0),
+        "test_enum": random.choice(["a", "b", "c"]),
+        "test_string": str(uuid.uuid1()),
+        "test_datetime": datetime.datetime.now().isoformat(),
+        "test_geopos": [random.uniform(-180.0, 180.0), random.uniform(-90.0, 90.0)],
+        "test_float_array": [random.uniform(-1.0, 1.0) for _ in range(3)],
     }
     out = {
-        'points': [[random.uniform(0.0, 1.0), random.uniform(0.0, 1.0)]
-                   for _ in range(random.randint(1, 10))],
-        'project': project,
-        'type': poly_type,
-        'media_id': video_obj.id,
-        'frame': random.randint(0, video_obj.num_frames - 1),
-        'attributes': attributes
+        "points": [
+            [random.uniform(0.0, 1.0), random.uniform(0.0, 1.0)]
+            for _ in range(random.randint(1, 10))
+        ],
+        "project": project,
+        "type": poly_type,
+        "media_id": video_obj.id,
+        "frame": random.randint(0, video_obj.num_frames - 1),
+        "attributes": attributes,
     }
 
     return {**out}
 
+
 def test_poly(host, token, project, video_type, video, poly_type):
     tator_api = tator.get_api(host, token)
     video_obj = tator_api.get_media(video)
 
     # These fields will not be checked for object equivalence after patch.
-    exclude = ['project', 'type', 'media_id', 'id', 'type', 'user', 'ids']
+    exclude = ["project", "type", "media_id", "id", "type", "user", "ids", "in_place"]
 
     # Test single create.
     poly = random_localization(project, poly_type, video_obj, post=True)
     response = tator_api.create_localization_list(project, poly)
     assert isinstance(response, tator.models.CreateListResponse)
     poly_id = response.id[0]
+    response = tator_api.get_localization(poly_id)
 
     # Patch single poly.
     patch = random_localization(project, poly_type, video_obj)
-    response = tator_api.update_localization(poly_id, localization_update=patch)
-    assert isinstance(response, tator.models.MessageResponse)
+    patch_obj = {**patch, "in_place": 1}
+    response = tator_api.update_localization(poly_id, localization_update=patch_obj)
+    assert "message" in response.to_dict()
     print(response.message)
 
     # Get single poly.
     updated_poly = tator_api.get_localization(poly_id)
     assert_close_enough(patch, updated_poly, exclude)
 
     # Get poly by ID.
-    poly_by_id = tator_api.get_localization_list_by_id(project, {'ids': [poly_id]})
-    assert(len(poly_by_id) == 1)
+    poly_by_id = tator_api.get_localization_list_by_id(project, {"ids": [poly_id]})
+    assert len(poly_by_id) == 1
     poly_by_id = poly_by_id[0]
     assert_close_enough(updated_poly, poly_by_id, exclude)
 
     # Delete single poly.
     response = tator_api.delete_localization(poly_id)
-    assert isinstance(response, tator.models.MessageResponse)
+    assert "message" in response.to_dict()
     print(response.message)
```

### Comparing `tator-1.2.9/test/test_search.py` & `tator-1.3.0/test/test_search.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/test/test_state.py` & `tator-1.3.0/test/test_state.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,89 +1,90 @@
 from pprint import pformat
 import datetime
 import random
 from time import sleep
 import uuid
 from collections import Counter
+import pytest
 
 import tator
 from ._common import assert_close_enough
 
 
 def wait_for_parity(tator_api, project, patch, expected_ids):
     attribute_filter = [f"test_string::{patch['attributes']['test_string']}"]
     state_id_query = {"ids": expected_ids}
-    total_timeout = 60.0 # seconds
-    wait_time = 2.0 # seconds
+    total_timeout = 60.0  # seconds
+    wait_time = 2.0  # seconds
 
     print(f"Using attribute filter:\n{pformat(attribute_filter)}")
     from_psql = tator_api.get_state_list_by_id(
         project,
         state_id_query=state_id_query,
         attribute=attribute_filter,
     )
     count = tator_api.get_state_count_by_id(
         project,
         state_id_query=state_id_query,
         attribute=attribute_filter,
     )
-    assert(len(from_psql) == count)
+    assert len(from_psql) == count
     for idx in range(int(total_timeout / wait_time) + 1):
         from_es = tator_api.get_state_list_by_id(
-            project,
-            state_id_query=state_id_query,
-            attribute=attribute_filter
+            project, state_id_query=state_id_query, attribute=attribute_filter
         )
         count = tator_api.get_state_count_by_id(
-            project,
-            state_id_query=state_id_query,
-            attribute=attribute_filter
+            project, state_id_query=state_id_query, attribute=attribute_filter
         )
-        assert(len(from_es) == count)
+        assert len(from_es) == count
 
         if len(from_es) == len(from_psql):
             print(f"Found expected number of results after {idx * wait_time} seconds")
             return True
 
         sleep(wait_time)
 
     print(f"Did not find expected number of results after {idx * wait_time} seconds")
     return False
 
+
 def random_state(project, state_type, video_obj, post=False):
     attributes = {
-        'test_bool': random.choice([False, True]),
-        'test_int': random.randint(-1000, 1000),
-        'test_float': random.uniform(-1000.0, 1000.0),
-        'test_enum': random.choice(['a', 'b', 'c']),
-        'test_string': str(uuid.uuid1()),
-        'test_datetime': datetime.datetime.now().isoformat(),
-        'test_geopos': [random.uniform(-180.0, 180.0), random.uniform(-90.0, 90.0)],
-        'test_float_array': [random.uniform(-1.0, 1.0) for _ in range(3)],
+        "test_bool": random.choice([False, True]),
+        "test_int": random.randint(-1000, 1000),
+        "test_float": random.uniform(-1000.0, 1000.0),
+        "test_enum": random.choice(["a", "b", "c"]),
+        "test_string": str(uuid.uuid1()),
+        "test_datetime": datetime.datetime.now().isoformat(),
+        "test_geopos": [random.uniform(-180.0, 180.0), random.uniform(-90.0, 90.0)],
+        "test_float_array": [random.uniform(-1.0, 1.0) for _ in range(3)],
     }
     out = {
-        'project': project,
-        'type': state_type,
-        'media_ids': [video_obj.id],
-        'frame': random.randint(0, video_obj.num_frames - 1),
-        'attributes':  attributes
+        "project": project,
+        "type": state_type,
+        "media_ids": [video_obj.id],
+        "frame": random.randint(0, video_obj.num_frames - 1),
+        "attributes": attributes,
     }
     return {**out}
 
+
 def comparison_query(tator_api, project, state_ids, exclude):
-    """ Runs a random query and compares results with ES enabled and disabled.
-    """
+    """Runs a random query and compares results with ES enabled and disabled."""
     bool_value = random.choice([True, False])
     int_lower = random.randint(-1000, 0)
     int_upper = random.randint(0, 1000)
     float_lower = random.uniform(-1000.0, 0.0)
     float_upper = random.uniform(0.0, 1000.0)
-    enum_value = random.choice(['a', 'b', 'c'])
+    enum_value = random.choice(["a", "b", "c"])
     state_id_query = {"ids": state_ids}
-    attribute_filter = [f"test_bool::{'true' if bool_value else 'false'}", f"test_enum::{enum_value}"]
+    attribute_filter = [
+        f"test_bool::{'true' if bool_value else 'false'}",
+        f"test_enum::{enum_value}",
+    ]
     attribute_lte_filter = [f"test_int::{int_upper}"]
     attribute_gte_filter = [f"test_int::{int_lower}"]
     attribute_lt_filter = [f"test_float::{float_upper}"]
     attribute_gt_filter = [f"test_float::{float_lower}"]
     print("Starting PSQL query...")
     t0 = datetime.datetime.now()
     from_psql = tator_api.get_state_list_by_id(
@@ -109,130 +110,160 @@
         force_es=1,
     )
     es_time = datetime.datetime.now() - t0
 
     print("Checking PSQL and ES ids...")
     psql_ids = [ele.id for ele in from_psql]
     es_ids = [ele.id for ele in from_es]
-    assert(Counter(psql_ids) == Counter(es_ids))
+    assert Counter(psql_ids) == Counter(es_ids)
 
     print("Checking PSQL and ES values...")
     assert len(from_psql) == len(from_es)
     for psql, es in zip(from_psql, from_es):
         assert_close_enough(psql, es, exclude)
-        assert(psql.attributes['test_bool'] == bool_value)
-        assert(psql.attributes['test_int'] <= int_upper)
-        assert(psql.attributes['test_int'] >= int_lower)
-        assert(psql.attributes['test_float'] < float_upper)
-        assert(psql.attributes['test_float'] > float_lower)
-        assert(psql.attributes['test_enum'] == enum_value)
+        assert psql.attributes["test_bool"] == bool_value
+        assert psql.attributes["test_int"] <= int_upper
+        assert psql.attributes["test_int"] >= int_lower
+        assert psql.attributes["test_float"] < float_upper
+        assert psql.attributes["test_float"] > float_lower
+        assert psql.attributes["test_enum"] == enum_value
     return psql_time, es_time
 
+
 def test_state_crud(host, token, project, video_type, empty_video, state_type):
     video = empty_video
     tator_api = tator.get_api(host, token)
     video_obj = tator_api.get_media(video)
 
     # These fields will not be checked for object equivalence after patch.
-    exclude = ['project', 'type', 'media_ids', 'id', 'type', 'user', 'frame', 'ids']
+    exclude = ["project", "type", "media_ids", "id", "type", "user", "frame", "ids", "in_place"]
 
     # Test bulk create.
     num_states = random.randint(2000, 10000)
-    states = [
-        random_state(project, state_type, video_obj, post=True)
-        for _ in range(num_states)
-    ]
+    states = [random_state(project, state_type, video_obj, post=True) for _ in range(num_states)]
     state_ids = []
     for response in tator.util.chunked_create(tator_api.create_state_list, project, body=states):
         state_ids += response.id
     assert len(state_ids) == len(states)
     print(f"Created {len(state_ids)} states!")
 
     # Verify list contains the number of entities created
     response = tator_api.get_state_list(project, type=state_type)
     assert len(response) == num_states
 
     # Test media retrieval by state ID.
-    response = tator_api.get_media_list_by_id(project, {'state_ids': state_ids})
+    response = tator_api.get_media_list_by_id(project, {"state_ids": state_ids})
     assert len(response) == 1
     assert response[0].id == video
 
     # Test state retrival by media ID.
-    response = tator_api.get_state_list_by_id(project, {'media_ids': [video]})
-    assert(len(response) == len(state_ids))
+    response = tator_api.get_state_list_by_id(project, {"media_ids": [video]})
+    assert len(response) == len(state_ids)
 
     # Test single create.
     state = random_state(project, state_type, video_obj, post=True)
     response = tator_api.create_state_list(project, body=state)
     assert isinstance(response, tator.models.CreateListResponse)
     print(response.message)
     state_id = response.id[0]
+    response = tator_api.get_state(state_id)
+    elemental_id = response.elemental_id
+    version = response.version
+
+    # Patch single state (in-place)
+    patch = random_state(project, state_type, video_obj)
+    patch_in_place = {**patch, "in_place": 1}
+    response = tator_api.update_state(state_id, state_update=patch_in_place)
+    assert "message" in response.to_dict()
+    print(response.message)
+
+    # Get single state.
+    updated_state = tator_api.get_state_by_elemental_id(version, elemental_id)
+    assert isinstance(updated_state, tator.models.State)
+    assert_close_enough(patch, updated_state, exclude)
+
+    # Get state by ID.
+    state_by_id = tator_api.get_state_list_by_id(project, {"ids": [state_id]})
+    assert len(state_by_id) == 1
+    state_by_id = state_by_id[0]
+    assert_close_enough(updated_state, state_by_id, exclude)
 
     # Patch single state.
     patch = random_state(project, state_type, video_obj)
     response = tator_api.update_state(state_id, state_update=patch)
-    assert isinstance(response, tator.models.MessageResponse)
+    assert "message" in response.to_dict()
     print(response.message)
 
     # Get single state.
-    updated_state = tator_api.get_state(state_id)
+    updated_state = tator_api.get_state_by_elemental_id(version, elemental_id)
     assert isinstance(updated_state, tator.models.State)
     assert_close_enough(patch, updated_state, exclude)
 
     # Get state by ID.
-    state_by_id = tator_api.get_state_list_by_id(project, {'ids': [state_id]})
-    assert(len(state_by_id) == 1)
+    state_by_id = tator_api.get_state_list_by_id(project, {"ids": [updated_state.id]})
+    assert len(state_by_id) == 1
     state_by_id = state_by_id[0]
     assert_close_enough(updated_state, state_by_id, exclude)
 
     # Delete single state.
-    response = tator_api.delete_state(state_id)
-    assert isinstance(response, tator.models.MessageResponse)
+    response = tator_api.delete_state_by_elemental_id(version, elemental_id)
+    assert "message" in response.to_dict()
     print(response.message)
 
-    params = {'media_id': [video], 'type': state_type}
-    assert(tator_api.get_state_count(project, **params) == len(states))
+    params = {"media_id": [video], "type": state_type}
+    assert tator_api.get_state_count(project, **params) == len(states)
 
     # Bulk update state attributes.
     bulk_patch = random_state(project, state_type, video_obj)
-    bulk_patch = {'attributes': bulk_patch['attributes']}
-    response = tator_api.update_state_list(project, **params,
-                                           state_bulk_update=bulk_patch)
+    bulk_patch = {"attributes": bulk_patch["attributes"], "in_place": 1}
+    count = tator_api.get_state_count(project, **params)
+    with pytest.raises(tator.openapi.tator_openapi.exceptions.ApiException):
+        response = tator_api.update_state_list(project, **params, state_bulk_update=bulk_patch, count=count+1)
+    response = tator_api.update_state_list(project, **params, state_bulk_update=bulk_patch, count=count)
     assert isinstance(response, tator.models.MessageResponse)
     print(response.message)
 
     # Bulk update specified states by ID.
     id_bulk_patch = random_state(project, state_type, video_obj)
     update_ids = random.choices(state_ids, k=100)
-    id_bulk_patch = {'attributes': id_bulk_patch['attributes'], 'ids': update_ids}
-    response = tator_api.update_state_list(project, **params,
-                                           state_bulk_update=id_bulk_patch)
+    id_bulk_patch = {"attributes": id_bulk_patch["attributes"], "ids": update_ids, "in_place": 1}
+    response = tator_api.update_state_list(project, **params, state_bulk_update=id_bulk_patch)
     assert isinstance(response, tator.models.MessageResponse)
     print(response.message)
 
     # Verify all states have been updated.
     states = tator_api.get_state_list(project, **params)
     dataframe = tator.util.to_dataframe(states)
-    assert(len(states)==len(dataframe))
+    assert len(states) == len(dataframe)
     for state in states:
         if state.id in update_ids:
             assert_close_enough(id_bulk_patch, state, exclude)
         else:
             assert_close_enough(bulk_patch, state, exclude)
 
     # Clone states to same media.
     version_mapping = {version.id: version.id for version in tator_api.get_version_list(project)}
-    generator = tator.util.clone_state_list(tator_api, {**params, 'project': project},
-                                            project, version_mapping, {video:video}, {},
-                                            {state_type:state_type}, tator_api)
+    generator = tator.util.clone_state_list(
+        tator_api,
+        {**params, "project": project},
+        project,
+        version_mapping,
+        {video: video},
+        {},
+        {state_type: state_type},
+        tator_api,
+    )
     for num_created, num_total, response, id_map in generator:
         print(f"Created {num_created} of {num_total} states...")
     print(f"Finished creating {num_created} states!")
-    assert(tator_api.get_state_count(project, **params) == 2 * len(states))
+    assert tator_api.get_state_count(project, **params) == 2 * len(states)
 
     # Delete all states.
-    response = tator_api.delete_state_list(project, **params)
+    count = tator_api.get_state_count(project, **params)
+    with pytest.raises(tator.openapi.tator_openapi.exceptions.ApiException):
+        response = tator_api.delete_state_list(project, **params, count=count+1)
+    response = tator_api.delete_state_list(project, **params, count=count)
     assert isinstance(response, tator.models.MessageResponse)
 
     # Verify all states are gone.
     states = tator_api.get_state_list(project, **params)
     assert states == []
```

### Comparing `tator-1.2.9/test/test_state_graphic.py` & `tator-1.3.0/test/test_state_graphic.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/test/test_state_type.py` & `tator-1.3.0/test/test_state_type.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/test/test_stategraphic.py` & `tator-1.3.0/test/test_stategraphic.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/test/test_temporary_file.py` & `tator-1.3.0/test/test_temporary_file.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/test/test_transcode.py` & `tator-1.3.0/test/test_transcode.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/test/test_util_media_manipulation.py` & `tator-1.3.0/test/test_util_media_manipulation.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/test/test_util_media_util.py` & `tator-1.3.0/test/test_util_media_util.py`

 * *Files identical despite different names*

### Comparing `tator-1.2.9/test/test_version.py` & `tator-1.3.0/test/test_version.py`

 * *Files identical despite different names*

