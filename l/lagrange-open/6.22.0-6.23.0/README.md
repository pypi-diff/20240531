# Comparing `tmp/lagrange_open-6.22.0-cp39-cp39-win_amd64.whl.zip` & `tmp/lagrange_open-6.23.0-cp310-cp310-macosx_11_0_arm64.whl.zip`

## zipinfo {}

```diff
@@ -1,23 +1,30 @@
-Zip file size: 3200251 bytes, number of entries: 21
--rw-rw-rw-  2.0 fat      730 b- defN 24-May-01 15:05 lagrange/__init__.py
--rw-rw-rw-  2.0 fat     1857 b- defN 24-May-01 15:05 lagrange/_logging.py
--rw-rw-rw-  2.0 fat      104 b- defN 24-May-01 15:05 lagrange/lagrange/__init__.pyi
--rw-rw-rw-  2.0 fat    70317 b- defN 24-May-01 15:05 lagrange/lagrange/core.pyi
--rw-rw-rw-  2.0 fat      994 b- defN 24-May-01 15:05 lagrange/lagrange/image.pyi
--rw-rw-rw-  2.0 fat     9564 b- defN 24-May-01 15:05 lagrange/lagrange/io.pyi
--rw-rw-rw-  2.0 fat    46048 b- defN 24-May-01 15:05 lagrange/lagrange/scene.pyi
--rw-rw-rw-  2.0 fat     3627 b- defN 24-May-01 15:05 lagrange/lagrange/subdivision.pyi
--rw-rw-rw-  2.0 fat  8088576 b- defN 24-May-01 15:05 lagrange/lagrange.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat        0 b- defN 24-May-01 15:05 lagrange/py.typed
--rw-rw-rw-  2.0 fat   321024 b- defN 24-May-01 14:58 lagrange/tbb12.dll
--rw-rw-rw-  2.0 fat    44060 b- defN 24-May-01 14:58 lagrange/tbb12.lib
--rw-rw-rw-  2.0 fat     2674 b- defN 24-May-01 15:05 lagrange_open-6.22.0.data/scripts/extract_texture.py
--rw-rw-rw-  2.0 fat     2290 b- defN 24-May-01 15:05 lagrange_open-6.22.0.data/scripts/meshconvert.py
--rw-rw-rw-  2.0 fat     5810 b- defN 24-May-01 15:05 lagrange_open-6.22.0.data/scripts/meshstat.py
--rw-rw-r--  2.0 fat     1961 b- defN 24-May-01 15:05 lagrange_open-6.22.0.dist-info/METADATA
--rw-rw-r--  2.0 fat      103 b- defN 24-May-01 15:05 lagrange_open-6.22.0.dist-info/WHEEL
--rw-rw-r--  2.0 fat        0 b- defN 24-May-01 15:05 lagrange_open-6.22.0.dist-info/entry_points.txt
--rw-rw-r--  2.0 fat    11536 b- defN 24-May-01 15:05 lagrange_open-6.22.0.dist-info/licenses/LICENSE
--rw-rw-r--  2.0 fat    11739 b- defN 24-May-01 15:05 lagrange_open-6.22.0.dist-info/licenses/NOTICE.txt
--rw-rw-r--  2.0 fat     1840 b- defN 24-May-01 15:05 lagrange_open-6.22.0.dist-info/RECORD
-21 files, 8624854 bytes uncompressed, 3197239 bytes compressed:  62.9%
+Zip file size: 4862716 bytes, number of entries: 28
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-30 23:26 lagrange_open-6.23.0.dist-info/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-30 23:26 lagrange/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-30 23:26 lagrange_open-6.23.0.data/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-30 23:26 lagrange_open-6.23.0.dist-info/licenses/
+-rw-rw-r--  2.0 unx     1951 b- defN 24-May-30 23:26 lagrange_open-6.23.0.dist-info/RECORD
+-rw-rw-r--  2.0 unx      113 b- defN 24-May-30 23:26 lagrange_open-6.23.0.dist-info/WHEEL
+-rw-rw-r--  2.0 unx        0 b- defN 24-May-30 23:26 lagrange_open-6.23.0.dist-info/entry_points.txt
+-rw-rw-r--  2.0 unx     2376 b- defN 24-May-30 23:26 lagrange_open-6.23.0.dist-info/METADATA
+-rw-rw-r--  2.0 unx    11335 b- defN 24-May-30 23:26 lagrange_open-6.23.0.dist-info/licenses/LICENSE
+-rw-rw-r--  2.0 unx    11488 b- defN 24-May-30 23:26 lagrange_open-6.23.0.dist-info/licenses/NOTICE.txt
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-30 23:26 lagrange/lagrange/
+-rw-r--r--  2.0 unx     1794 b- defN 24-May-30 23:26 lagrange/_logging.py
+-rw-r--r--  2.0 unx       20 b- defN 24-May-30 23:21 lagrange/_version.py
+-rwxr-xr-x  2.0 unx   305776 b- defN 24-May-30 23:26 lagrange/libtbb.12.dylib
+-rwxr-xr-x  2.0 unx 17335200 b- defN 24-May-30 23:26 lagrange/lagrange.cpython-310-darwin.so
+-rw-r--r--  2.0 unx      764 b- defN 24-May-30 23:26 lagrange/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-30 23:26 lagrange/py.typed
+-rwxr-xr-x  2.0 unx   305776 b- defN 24-May-30 23:26 lagrange/libtbb.12.11.dylib
+-rwxr-xr-x  2.0 unx   305776 b- defN 24-May-30 23:26 lagrange/libtbb.dylib
+-rw-r--r--  2.0 unx     2955 b- defN 24-May-30 23:26 lagrange/lagrange/subdivision.pyi
+-rw-r--r--  2.0 unx    44876 b- defN 24-May-30 23:26 lagrange/lagrange/scene.pyi
+-rw-r--r--  2.0 unx      674 b- defN 24-May-30 23:26 lagrange/lagrange/image.pyi
+-rw-r--r--  2.0 unx    59170 b- defN 24-May-30 23:26 lagrange/lagrange/core.pyi
+-rw-r--r--  2.0 unx     8222 b- defN 24-May-30 23:26 lagrange/lagrange/io.pyi
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-30 23:26 lagrange_open-6.23.0.data/scripts/
+-rwxr-xr-x  2.0 unx     5540 b- defN 24-May-30 23:26 lagrange_open-6.23.0.data/scripts/meshstat.py
+-rwxr-xr-x  2.0 unx     2586 b- defN 24-May-30 23:26 lagrange_open-6.23.0.data/scripts/extract_texture.py
+-rwxr-xr-x  2.0 unx     2200 b- defN 24-May-30 23:26 lagrange_open-6.23.0.data/scripts/meshconvert.py
+28 files, 18408592 bytes uncompressed, 4858798 bytes compressed:  73.6%
```

## zipnote {}

```diff
@@ -1,64 +1,85 @@
-Filename: lagrange/__init__.py
+Filename: lagrange_open-6.23.0.dist-info/
 Comment: 
 
-Filename: lagrange/_logging.py
+Filename: lagrange/
 Comment: 
 
-Filename: lagrange/lagrange/__init__.pyi
+Filename: lagrange_open-6.23.0.data/
 Comment: 
 
-Filename: lagrange/lagrange/core.pyi
+Filename: lagrange_open-6.23.0.dist-info/licenses/
 Comment: 
 
-Filename: lagrange/lagrange/image.pyi
+Filename: lagrange_open-6.23.0.dist-info/RECORD
 Comment: 
 
-Filename: lagrange/lagrange/io.pyi
+Filename: lagrange_open-6.23.0.dist-info/WHEEL
 Comment: 
 
-Filename: lagrange/lagrange/scene.pyi
+Filename: lagrange_open-6.23.0.dist-info/entry_points.txt
 Comment: 
 
-Filename: lagrange/lagrange/subdivision.pyi
+Filename: lagrange_open-6.23.0.dist-info/METADATA
+Comment: 
+
+Filename: lagrange_open-6.23.0.dist-info/licenses/LICENSE
+Comment: 
+
+Filename: lagrange_open-6.23.0.dist-info/licenses/NOTICE.txt
+Comment: 
+
+Filename: lagrange/lagrange/
+Comment: 
+
+Filename: lagrange/_logging.py
+Comment: 
+
+Filename: lagrange/_version.py
+Comment: 
+
+Filename: lagrange/libtbb.12.dylib
+Comment: 
+
+Filename: lagrange/lagrange.cpython-310-darwin.so
 Comment: 
 
-Filename: lagrange/lagrange.cp39-win_amd64.pyd
+Filename: lagrange/__init__.py
 Comment: 
 
 Filename: lagrange/py.typed
 Comment: 
 
-Filename: lagrange/tbb12.dll
+Filename: lagrange/libtbb.12.11.dylib
 Comment: 
 
-Filename: lagrange/tbb12.lib
+Filename: lagrange/libtbb.dylib
 Comment: 
 
-Filename: lagrange_open-6.22.0.data/scripts/extract_texture.py
+Filename: lagrange/lagrange/subdivision.pyi
 Comment: 
 
-Filename: lagrange_open-6.22.0.data/scripts/meshconvert.py
+Filename: lagrange/lagrange/scene.pyi
 Comment: 
 
-Filename: lagrange_open-6.22.0.data/scripts/meshstat.py
+Filename: lagrange/lagrange/image.pyi
 Comment: 
 
-Filename: lagrange_open-6.22.0.dist-info/METADATA
+Filename: lagrange/lagrange/core.pyi
 Comment: 
 
-Filename: lagrange_open-6.22.0.dist-info/WHEEL
+Filename: lagrange/lagrange/io.pyi
 Comment: 
 
-Filename: lagrange_open-6.22.0.dist-info/entry_points.txt
+Filename: lagrange_open-6.23.0.data/scripts/
 Comment: 
 
-Filename: lagrange_open-6.22.0.dist-info/licenses/LICENSE
+Filename: lagrange_open-6.23.0.data/scripts/meshstat.py
 Comment: 
 
-Filename: lagrange_open-6.22.0.dist-info/licenses/NOTICE.txt
+Filename: lagrange_open-6.23.0.data/scripts/extract_texture.py
 Comment: 
 
-Filename: lagrange_open-6.22.0.dist-info/RECORD
+Filename: lagrange_open-6.23.0.data/scripts/meshconvert.py
 Comment: 
 
 Zip file comment:
```

## filetype from file(1)

```diff
@@ -1 +1 @@
-Zip archive data, at least v2.0 to extract, compression method=deflate
+Zip archive data, at least v2.0 to extract, compression method=store
```

## lagrange/__init__.py

```diff
@@ -1,16 +1,17 @@
-#
-# Copyright 2022 Adobe. All rights reserved.
-# This file is licensed to you under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License. You may obtain a copy
-# of the License at http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software distributed under
-# the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
-# OF ANY KIND, either express or implied. See the License for the specific language
-# governing permissions and limitations under the License.
-#
-from .lagrange import *
-from .lagrange.core import *
-from ._logging import logger
-
-del _logging, lagrange
+#
+# Copyright 2022 Adobe. All rights reserved.
+# This file is licensed to you under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License. You may obtain a copy
+# of the License at http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software distributed under
+# the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
+# OF ANY KIND, either express or implied. See the License for the specific language
+# governing permissions and limitations under the License.
+#
+from .lagrange import *
+from .lagrange.core import *
+from ._logging import logger
+from ._version import __version__
+
+del _logging, lagrange  # type: ignore
```

## lagrange/_logging.py

```diff
@@ -1,47 +1,45 @@
-#
-# Copyright 2023 Adobe. All rights reserved.
-# This file is licensed to you under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License. You may obtain a copy
-# of the License at http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software distributed under
-# the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
-# OF ANY KIND, either express or implied. See the License for the specific language
-# governing permissions and limitations under the License.
-#
-import logging
-import colorama
-
-colorama.just_fix_windows_console()
-
-logger = logging.getLogger("lagrange")
-handler = logging.StreamHandler()
-formatter = logging.Formatter("[%(asctime)s] [%(name)s] [%(levelname)s] %(message)s")
-
-
-class ColorFormatter(logging.Formatter):
-    grey = colorama.Fore.LIGHTBLACK_EX
-    yellow = colorama.Fore.YELLOW
-    red = colorama.Fore.RED
-    bold_red = colorama.Style.BRIGHT + colorama.Fore.RED
-    reset = colorama.Style.RESET_ALL
-    format_template = (
-        "[%(asctime)s] [%(name)s] {color}[%(levelname)s]{reset} %(message)s"
-    )
-
-    FORMATS = {
-        logging.DEBUG: format_template.format(color=grey, reset=reset),
-        logging.INFO: format_template.format(color=grey, reset=reset),
-        logging.WARNING: format_template.format(color=yellow, reset=reset),
-        logging.ERROR: format_template.format(color=red, reset=reset),
-        logging.CRITICAL: format_template.format(color=bold_red, reset=reset),
-    }
-
-    def format(self, record):
-        log_fmt = self.FORMATS.get(record.levelno)
-        formatter = logging.Formatter(log_fmt)
-        return formatter.format(record)
-
-
-handler.setFormatter(ColorFormatter())
-logger.addHandler(handler)
+#
+# Copyright 2023 Adobe. All rights reserved.
+# This file is licensed to you under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License. You may obtain a copy
+# of the License at http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software distributed under
+# the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
+# OF ANY KIND, either express or implied. See the License for the specific language
+# governing permissions and limitations under the License.
+#
+import logging
+import colorama
+
+colorama.just_fix_windows_console()
+
+logger = logging.getLogger("lagrange")
+handler = logging.StreamHandler()
+formatter = logging.Formatter("[%(asctime)s] [%(name)s] [%(levelname)s] %(message)s")
+
+
+class ColorFormatter(logging.Formatter):
+    grey = colorama.Fore.LIGHTBLACK_EX
+    yellow = colorama.Fore.YELLOW
+    red = colorama.Fore.RED
+    bold_red = colorama.Style.BRIGHT + colorama.Fore.RED
+    reset = colorama.Style.RESET_ALL
+    format_template = "[%(asctime)s] [%(name)s] {color}[%(levelname)s]{reset} %(message)s"
+
+    FORMATS = {
+        logging.DEBUG: format_template.format(color=grey, reset=reset),
+        logging.INFO: format_template.format(color=grey, reset=reset),
+        logging.WARNING: format_template.format(color=yellow, reset=reset),
+        logging.ERROR: format_template.format(color=red, reset=reset),
+        logging.CRITICAL: format_template.format(color=bold_red, reset=reset),
+    }
+
+    def format(self, record):
+        log_fmt = self.FORMATS.get(record.levelno)
+        formatter = logging.Formatter(log_fmt)
+        return formatter.format(record)
+
+
+handler.setFormatter(ColorFormatter())
+logger.addHandler(handler)
```

## lagrange/lagrange/core.pyi

```diff
@@ -1,2135 +1,1747 @@
-from typing import Any, Optional, overload, Typing, Sequence
-from enum import Enum
-import lagrange.core
-
-class Attribute:
-    """
-    Mesh attribute
-    """
-
-    def __init__(*args, **kwargs):
-        """
-        Initialize self.  See help(type(self)) for accurate signature.
-        """
-        ...
-    
-    def clear(self) -> None:
-        """
-        Clear the attribute so it has no elements.
-        """
-        ...
-    
-    @property
-    def copy_policy(self) -> lagrange.core.AttributeCopyPolicy:
-        """
-        Copy policy of the attribute.
-        """
-        ...
-    @copy_policy.setter
-    def copy_policy(self, arg: lagrange.core.AttributeCopyPolicy, /) -> None:
-        """
-        Copy policy of the attribute.
-        """
-        ...
-    
-    def create_internal_copy(self) -> None:
-        """
-        Create an internal copy of the attribute.
-        """
-        ...
-    
-    @property
-    def data(self) -> object:
-        """
-        Raw data buffer of the attribute.
-        """
-        ...
-    @data.setter
-    def data(self, arg: object, /) -> None:
-        """
-        Raw data buffer of the attribute.
-        """
-        ...
-    
-    @property
-    def default_value(self) -> object:
-        """
-        Default value of the attribute.
-        """
-        ...
-    @default_value.setter
-    def default_value(self, arg: float, /) -> None:
-        """
-        Default value of the attribute.
-        """
-        ...
-    
-    @property
-    def dtype(self) -> Optional[type]:
-        """
-        Value type of the attribute.
-        """
-        ...
-    
-    @property
-    def element_type(self) -> lagrange.core.AttributeElement:
-        """
-        Element type of the attribute.
-        """
-        ...
-    
-    def empty(self) -> bool:
-        """
-        Return true if the attribute is empty.
-        """
-        ...
-    
-    @property
-    def external(self) -> bool:
-        """
-        Return true if the attribute wraps external buffer.
-        """
-        ...
-    
-    @property
-    def growth_policy(self) -> lagrange.core.AttributeGrowthPolicy:
-        """
-        Growth policy of the attribute.
-        """
-        ...
-    @growth_policy.setter
-    def growth_policy(self, arg: lagrange.core.AttributeGrowthPolicy, /) -> None:
-        """
-        Growth policy of the attribute.
-        """
-        ...
-    
-    def insert_elements(self, tensor: object) -> None:
-        """
-        Insert new elements to the attribute.
-        
-        :param tensor: A tensor with shape (num_elements, num_channels) or (num_elements,).
-        """
-        ...
-    
-    @overload
-    def insert_elements(self, num_elements: int) -> None:
-        """
-        Insert new elements with default value to the attribute.
-        
-        :param num_elements: Number of elements to insert.
-        """
-        ...
-    
-    @property
-    def num_channels(self) -> int:
-        """
-        Number of channels in the attribute.
-        """
-        ...
-    
-    @property
-    def num_elements(self) -> int:
-        """
-        Number of elements in the attribute.
-        """
-        ...
-    
-    @property
-    def readonly(self) -> bool:
-        """
-        Return true if the attribute is read-only.
-        """
-        ...
-    
-    def reserve_entries(self, num_entries: int) -> None:
-        """
-        Reserve enough memory for `num_entries` entries.
-        
-        :param num_entries: Number of entries to reserve. It does not need to be a multiple of `num_channels`.
-        """
-        ...
-    
-    @property
-    def shrink_policy(self) -> lagrange.core.AttributeShrinkPolicy:
-        """
-        Shrink policy of the attribute.
-        """
-        ...
-    @shrink_policy.setter
-    def shrink_policy(self, arg: lagrange.core.AttributeShrinkPolicy, /) -> None:
-        """
-        Shrink policy of the attribute.
-        """
-        ...
-    
-    @property
-    def usage(self) -> lagrange.core.AttributeUsage:
-        """
-        Usage of the attribute.
-        """
-        ...
-    
-    @property
-    def write_policy(self) -> lagrange.core.AttributeWritePolicy:
-        """
-        Write policy of the attribute.
-        """
-        ...
-    @write_policy.setter
-    def write_policy(self, arg: lagrange.core.AttributeWritePolicy, /) -> None:
-        """
-        Write policy of the attribute.
-        """
-        ...
-    
-class AttributeCopyPolicy(Enum):
-    """
-    <attribute '__doc__' of 'AttributeCopyPolicy' objects>
-    """
-
-    CopyIfExternal: Any
-    
-    ErrorIfExternal: Any
-    
-    KeepExternalPtr: Any
-    
-class AttributeCreatePolicy(Enum):
-    """
-    <attribute '__doc__' of 'AttributeCreatePolicy' objects>
-    """
-
-    ErrorIfReserved: Any
-    
-    Force: Any
-    
-class AttributeDeletePolicy(Enum):
-    """
-    <attribute '__doc__' of 'AttributeDeletePolicy' objects>
-    """
-
-    ErrorIfReserved: Any
-    
-    Force: Any
-    
-class AttributeElement(Enum):
-    """
-    <attribute '__doc__' of 'AttributeElement' objects>
-    """
-
-    Corner: Any
-    
-    Edge: Any
-    
-    Facet: Any
-    
-    Indexed: Any
-    
-    Value: Any
-    
-    Vertex: Any
-    
-class AttributeExportPolicy(Enum):
-    """
-    <attribute '__doc__' of 'AttributeExportPolicy' objects>
-    """
-
-    CopyIfExternal: Any
-    
-    CopyIfUnmanaged: Any
-    
-    ErrorIfExternal: Any
-    
-    KeepExternalPtr: Any
-    
-class AttributeGrowthPolicy(Enum):
-    """
-    <attribute '__doc__' of 'AttributeGrowthPolicy' objects>
-    """
-
-    AllowWithinCapacity: Any
-    
-    ErrorIfExtenal: Any
-    
-    SilentCopy: Any
-    
-    WarnAndCopy: Any
-    
-class AttributeShrinkPolicy(Enum):
-    """
-    <attribute '__doc__' of 'AttributeShrinkPolicy' objects>
-    """
-
-    ErrorIfExternal: Any
-    
-    IgnoreIfExternal: Any
-    
-    SilentCopy: Any
-    
-    WarnAndCopy: Any
-    
-class AttributeUsage(Enum):
-    """
-    <attribute '__doc__' of 'AttributeUsage' objects>
-    """
-
-    Bitangent: Any
-    
-    Color: Any
-    
-    CornerIndex: Any
-    
-    EdgeIndex: Any
-    
-    FacetIndex: Any
-    
-    Normal: Any
-    
-    Position: Any
-    
-    Scalar: Any
-    
-    Tangent: Any
-    
-    UV: Any
-    
-    Vector: Any
-    
-    VertexIndex: Any
-    
-class AttributeWritePolicy(Enum):
-    """
-    <attribute '__doc__' of 'AttributeWritePolicy' objects>
-    """
-
-    ErrorIfReadOnly: Any
-    
-    SilentCopy: Any
-    
-    WarnAndCopy: Any
-    
-class CentroidWeightingType(Enum):
-    """
-    <attribute '__doc__' of 'CentroidWeightingType' objects>
-    """
-
-    Area: Any
-    
-    Uniform: Any
-    
-class ConnectivityType(Enum):
-    """
-    <attribute '__doc__' of 'ConnectivityType' objects>
-    """
-
-    Edge: Any
-    
-    Vertex: Any
-    
-class DistortionMetric(Enum):
-    """
-    <attribute '__doc__' of 'DistortionMetric' objects>
-    """
-
-    AreaRatio: Any
-    
-    Dirichlet: Any
-    
-    InverseDirichlet: Any
-    
-    MIPS: Any
-    
-    SymmetricDirichlet: Any
-    
-class FacetAreaOptions:
-    """
-    Options for computing facet area.
-    """
-
-    def __init__(self) -> None:
-        ...
-    
-    @property
-    def output_attribute_name(self) -> str:
-        """
-        The name of the output attribute.
-        """
-        ...
-    @output_attribute_name.setter
-    def output_attribute_name(self, arg: str, /) -> None:
-        """
-        The name of the output attribute.
-        """
-        ...
-    
-class FacetCentroidOptions:
-    """
-    Facet centroid options.
-    """
-
-    def __init__(self) -> None:
-        ...
-    
-    @property
-    def output_attribute_name(self) -> str:
-        """
-        The name of the output attribute.
-        """
-        ...
-    @output_attribute_name.setter
-    def output_attribute_name(self, arg: str, /) -> None:
-        """
-        The name of the output attribute.
-        """
-        ...
-    
-class FacetNormalOptions:
-    """
-    Facet normal computation options.
-    """
-
-    def __init__(self) -> None:
-        ...
-    
-    @property
-    def output_attribute_name(self) -> str:
-        """
-        Output attribute name. Default: '@facet_normal'
-        """
-        ...
-    @output_attribute_name.setter
-    def output_attribute_name(self, arg: str, /) -> None:
-        """
-        Output attribute name. Default: '@facet_normal'
-        """
-        ...
-    
-class IndexedAttribute:
-    """
-    None
-    """
-
-    def __init__(*args, **kwargs):
-        """
-        Initialize self.  See help(type(self)) for accurate signature.
-        """
-        ...
-    
-    @property
-    def element_type(self) -> lagrange.core.AttributeElement:
-        ...
-    
-    @property
-    def indices(self) -> lagrange.core.Attribute:
-        ...
-    
-    @property
-    def num_channels(self) -> int:
-        ...
-    
-    @property
-    def usage(self) -> lagrange.core.AttributeUsage:
-        ...
-    
-    @property
-    def values(self) -> lagrange.core.Attribute:
-        ...
-    
-class MappingPolicy(Enum):
-    """
-    <attribute '__doc__' of 'MappingPolicy' objects>
-    """
-
-    Average: Any
-    
-    Error: Any
-    
-    KeepFirst: Any
-    
-class MeshAreaOptions:
-    """
-    Options for computing mesh area.
-    """
-
-    def __init__(self) -> None:
-        ...
-    
-    @property
-    def input_attribute_name(self) -> str:
-        """
-        The name of the pre-computed facet area attribute, default is '@facet_area'.
-        """
-        ...
-    @input_attribute_name.setter
-    def input_attribute_name(self, arg: str, /) -> None:
-        """
-        The name of the pre-computed facet area attribute, default is '@facet_area'.
-        """
-        ...
-    
-    @property
-    def use_signed_area(self) -> bool:
-        """
-        Whether to use signed area.
-        """
-        ...
-    @use_signed_area.setter
-    def use_signed_area(self, arg: bool, /) -> None:
-        """
-        Whether to use signed area.
-        """
-        ...
-    
-class MeshCentroidOptions:
-    """
-    Mesh centroid options.
-    """
-
-    def __init__(self) -> None:
-        ...
-    
-    @property
-    def facet_area_attribute_name(self) -> str:
-        """
-        The name of the pre-computed facet area attribute if available.
-        """
-        ...
-    @facet_area_attribute_name.setter
-    def facet_area_attribute_name(self, arg: str, /) -> None:
-        """
-        The name of the pre-computed facet area attribute if available.
-        """
-        ...
-    
-    @property
-    def facet_centroid_attribute_name(self) -> str:
-        """
-        The name of the pre-computed facet centroid attribute if available.
-        """
-        ...
-    @facet_centroid_attribute_name.setter
-    def facet_centroid_attribute_name(self, arg: str, /) -> None:
-        """
-        The name of the pre-computed facet centroid attribute if available.
-        """
-        ...
-    
-    @property
-    def weighting_type(self) -> lagrange.core.CentroidWeightingType:
-        """
-        The weighting type.
-        """
-        ...
-    @weighting_type.setter
-    def weighting_type(self, arg: lagrange.core.CentroidWeightingType, /) -> None:
-        """
-        The weighting type.
-        """
-        ...
-    
-class NormalOptions:
-    """
-    Normal computation options.
-    """
-
-    def __init__(self) -> None:
-        ...
-    
-    @property
-    def facet_normal_attribute_name(self) -> str:
-        """
-        Facet normal attribute name to use. Default is '@facet_normal'.
-        """
-        ...
-    @facet_normal_attribute_name.setter
-    def facet_normal_attribute_name(self, arg: str, /) -> None:
-        """
-        Facet normal attribute name to use. Default is '@facet_normal'.
-        """
-        ...
-    
-    @property
-    def keep_facet_normals(self) -> bool:
-        """
-        Whether to keep the computed facet normal attribute. Default is false.
-        """
-        ...
-    @keep_facet_normals.setter
-    def keep_facet_normals(self, arg: bool, /) -> None:
-        """
-        Whether to keep the computed facet normal attribute. Default is false.
-        """
-        ...
-    
-    @property
-    def output_attribute_name(self) -> str:
-        """
-        Output attribute name. Default: '@normal'
-        """
-        ...
-    @output_attribute_name.setter
-    def output_attribute_name(self, arg: str, /) -> None:
-        """
-        Output attribute name. Default: '@normal'
-        """
-        ...
-    
-    @property
-    def recompute_facet_normals(self) -> bool:
-        """
-        Whether to recompute facet normals. Default is false.
-        """
-        ...
-    @recompute_facet_normals.setter
-    def recompute_facet_normals(self, arg: bool, /) -> None:
-        """
-        Whether to recompute facet normals. Default is false.
-        """
-        ...
-    
-    @property
-    def weight_type(self) -> lagrange.core.NormalWeightingType:
-        """
-        Weighting type for normal computation. Default is Angle.
-        """
-        ...
-    @weight_type.setter
-    def weight_type(self, arg: lagrange.core.NormalWeightingType, /) -> None:
-        """
-        Weighting type for normal computation. Default is Angle.
-        """
-        ...
-    
-class NormalWeightingType(Enum):
-    """
-    <attribute '__doc__' of 'NormalWeightingType' objects>
-    """
-
-    Angle: Any
-    
-    CornerTriangleArea: Any
-    
-    Uniform: Any
-    
-class RemapVerticesOptions:
-    """
-    Options for remapping vertices.
-    """
-
-    def __init__(self) -> None:
-        ...
-    
-    @property
-    def collision_policy_float(self) -> lagrange.core.MappingPolicy:
-        """
-        The collision policy for float attributes.
-        """
-        ...
-    @collision_policy_float.setter
-    def collision_policy_float(self, arg: lagrange.core.MappingPolicy, /) -> None:
-        """
-        The collision policy for float attributes.
-        """
-        ...
-    
-    @property
-    def collision_policy_integral(self) -> lagrange.core.MappingPolicy:
-        """
-        The collision policy for integral attributes.
-        """
-        ...
-    @collision_policy_integral.setter
-    def collision_policy_integral(self, arg: lagrange.core.MappingPolicy, /) -> None:
-        """
-        The collision policy for integral attributes.
-        """
-        ...
-    
-class SurfaceMesh:
-    """
-    None
-    """
-
-    def __init__(self, dimension: int = 3) -> None:
-        ...
-    
-    def add_hybrid(self, arg0: numpy.typing.NDArray, arg1: numpy.typing.NDArray, /) -> None:
-        ...
-    
-    def add_polygon(self, arg: numpy.typing.NDArray, /) -> None:
-        ...
-    
-    def add_polygons(self, arg: numpy.typing.NDArray, /) -> None:
-        ...
-    
-    def add_quad(self, arg0: int, arg1: int, arg2: int, arg3: int, /) -> None:
-        ...
-    
-    def add_quads(self, arg: numpy.typing.NDArray, /) -> None:
-        ...
-    
-    def add_triangle(self, arg0: int, arg1: int, arg2: int, /) -> None:
-        ...
-    
-    def add_triangles(self, arg: numpy.typing.NDArray, /) -> None:
-        ...
-    
-    def add_vertex(self, vertex: numpy.typing.NDArray) -> None:
-        """
-        add_vertex(self, arg: list, /) -> None
-        
-        Add a vertex to the mesh.
-        
-        :param vertex: vertex coordinates
-        :type vertex: numpy.ndarray or list
-        """
-        ...
-    
-    def add_vertices(self, arg: numpy.typing.NDArray, /) -> None:
-        ...
-    
-    @property
-    def attr_id_corner_to_edge(self) -> int:
-        ...
-    
-    @property
-    def attr_id_corner_to_facet(self) -> int:
-        ...
-    
-    @property
-    def attr_id_corner_to_vertex(self) -> int:
-        ...
-    
-    @property
-    def attr_id_edge_to_first_corner(self) -> int:
-        ...
-    
-    @property
-    def attr_id_facet_to_first_corner(self) -> int:
-        ...
-    
-    @property
-    def attr_id_next_corner_around_edge(self) -> int:
-        ...
-    
-    @property
-    def attr_id_next_corner_around_vertex(self) -> int:
-        ...
-    
-    @property
-    def attr_id_vertex_to_first_corner(self) -> int:
-        ...
-    
-    @property
-    def attr_id_vertex_to_position(self) -> int:
-        ...
-    
-    attr_name_corner_to_edge: str
-    
-    attr_name_corner_to_facet: str
-    
-    attr_name_corner_to_vertex: str
-    
-    attr_name_edge_to_first_corner: str
-    
-    attr_name_facet_to_first_corner: str
-    
-    def attr_name_is_reserved(arg: str, /) -> bool:
-        ...
-    
-    attr_name_next_corner_around_edge: str
-    
-    attr_name_next_corner_around_vertex: str
-    
-    attr_name_vertex_to_first_corner: str
-    
-    attr_name_vertex_to_position: str
-    
-    def attribute(self, name: str, sharing: bool = True) -> lagrange.core.Attribute:
-        """
-        Get an attribute by name.
-        
-        :param name: Name of the attribute.
-        :type name: str
-        :param sharing: Whether to allow sharing the attribute with other meshes.
-        :type sharing: bool
-        
-        :return: The attribute.
-        """
-        ...
-    
-    @overload
-    def attribute(self, id: int, sharing: bool = True) -> lagrange.core.Attribute:
-        """
-        Get an attribute by id.
-        
-        :param id: Id of the attribute.
-        :type id: AttributeId
-        :param sharing: Whether to allow sharing the attribute with other meshes.
-        :type sharing: bool
-        
-        :returns: The attribute.
-        """
-        ...
-    
-    def clear_edges(self) -> None:
-        ...
-    
-    def clear_facets(self) -> None:
-        ...
-    
-    def clear_vertices(self) -> None:
-        ...
-    
-    def clone(self) -> object:
-        """
-        Create a deep copy of this mesh.
-        """
-        ...
-    
-    def compress_if_regular(self) -> None:
-        ...
-    
-    def count_num_corners_around_edge(self, arg: int, /) -> int:
-        ...
-    
-    def count_num_corners_around_vertex(self, arg: int, /) -> int:
-        ...
-    
-    def create_attribute(self, name: str, element: Optional[lagrange.core.AttributeElement] = None, usage: Optional[lagrange.core.AttributeUsage] = None, initial_values: Optional[Union[numpy.typing.NDArray, list]] = None, initial_indices: Optional[Union[numpy.typing.NDArray, numpy.typing.NDArray, list]] = None, num_channels: Optional[int] = None, dtype: Optional[type] = None) -> int:
-        """
-        Create an attribute.
-        
-        :param name: Name of the attribute.
-        :type name: str
-        :param element: Element type of the attribute. If None, derive from the shape of initial values.
-        :type element: AttributeElement, optional
-        :param usage: Usage type of the attribute. If None, derive from the shape of initial values or the number of channels.
-        :type usage: AttributeUsage, optional
-        :param initial_values: Initial values of the attribute.
-        :type initial_values: numpy.ndarray, optional
-        :param initial_indices: Initial indices of the attribute (Indexed attribute only).
-        :type initial_indices: numpy.ndarray, optional
-        :param num_channels: Number of channels of the attribute.
-        :type num_channels: int, optional
-        :param dtype: Data type of the attribute.
-        :type dtype: valid numpy.dtype, optional
-        
-        .. note::
-        If `element` is None, it will be derived based on the cardinality of the mesh elements.
-        If there is an ambiguity, an exception will be raised.
-        In addition, explicit `element` specification is required for value attributes.
-        
-        .. note::
-        If `usage` is None, it will be derived based on the shape of `initial_values` or `num_channels` if specified.
-        
-        :returns: The id of the created attribute.
-        """
-        ...
-    
-    def create_attribute_from(self, name: str, source_mesh: lagrange.core.SurfaceMesh, source_name: str = '') -> int:
-        """
-        Shallow copy an attribute from another mesh.
-        
-        :param name: Name of the attribute.
-        :type name: str
-        :param source_mesh: Source mesh.
-        :type source_mesh: SurfaceMesh
-        :param source_name: Name of the attribute in the source mesh. If empty, use the same name as `name`.
-        :type source_name: str, optional
-        
-        :returns: The id of the created attribute.
-        """
-        ...
-    
-    def delete_attribute(self, name: str) -> None:
-        """
-        delete_attribute(self, name: str) -> None
-        """
-        ...
-    
-    @overload
-    def delete_attribute(self, name: str, policy: lagrange.core.AttributeDeletePolicy) -> None:
-        """
-        delete_attribute(self, name: str, policy: lagrange.core.AttributeDeletePolicy) -> None
-        """
-        ...
-    
-    @property
-    def dimension(self) -> int:
-        ...
-    
-    def duplicate_attribute(self, arg0: str, arg1: str, /) -> int:
-        ...
-    
-    @property
-    def facets(self) -> numpy.typing.NDArray:
-        """
-        Facets of the mesh.
-        """
-        ...
-    @facets.setter
-    def facets(self, arg: numpy.typing.NDArray, /) -> None:
-        """
-        Facets of the mesh.
-        """
-        ...
-    
-    def find_edge_from_vertices(self, arg0: int, arg1: int, /) -> int:
-        ...
-    
-    def get_attribute_id(self, arg: str, /) -> int:
-        ...
-    
-    def get_attribute_name(self, arg: int, /) -> str:
-        ...
-    
-    def get_corner_edge(self, arg: int, /) -> int:
-        ...
-    
-    def get_corner_facet(self, arg: int, /) -> int:
-        ...
-    
-    def get_corner_vertex(self, arg: int, /) -> int:
-        ...
-    
-    def get_edge(self, arg0: int, arg1: int, /) -> int:
-        ...
-    
-    def get_edge_vertices(self, arg: int, /) -> list[int]:
-        ...
-    
-    def get_facet_corner_begin(self, arg: int, /) -> int:
-        ...
-    
-    def get_facet_corner_end(self, arg: int, /) -> int:
-        ...
-    
-    def get_facet_size(self, arg: int, /) -> int:
-        ...
-    
-    def get_facet_vertex(self, arg0: int, arg1: int, /) -> int:
-        ...
-    
-    def get_facet_vertices(self, arg: int, /) -> numpy.typing.NDArray:
-        ...
-    
-    def get_first_corner_around_edge(self, arg: int, /) -> int:
-        ...
-    
-    def get_first_corner_around_vertex(self, arg: int, /) -> int:
-        ...
-    
-    def get_matching_attribute_ids(self, element: Optional[lagrange.core.AttributeElement] = None, usage: Optional[lagrange.core.AttributeUsage] = None, num_channels: int = 0) -> list[int]:
-        """
-        Get all matching attribute ids with the desired element type, usage and number of channels.
-        
-        :param element:       The target element type. None matches all element types.
-        :param usage:         The target usage type.  None matches all usage types.
-        :param num_channels:  The target number of channels. 0 matches arbitrary number of channels.
-        
-        :returns: A list of attribute ids matching the target element, usage and number of channels.
-        """
-        ...
-    
-    def get_next_corner_around_edge(self, arg: int, /) -> int:
-        ...
-    
-    def get_next_corner_around_vertex(self, arg: int, /) -> int:
-        ...
-    
-    def get_one_corner_around_edge(self, arg: int, /) -> int:
-        ...
-    
-    def get_one_corner_around_vertex(self, arg: int, /) -> int:
-        ...
-    
-    def get_one_facet_around_edge(self, arg: int, /) -> int:
-        ...
-    
-    def get_position(self, arg: int, /) -> numpy.typing.NDArray:
-        ...
-    
-    def has_attribute(self, arg: str, /) -> bool:
-        ...
-    
-    @property
-    def has_edges(self) -> bool:
-        ...
-    
-    def indexed_attribute(self, name: str, sharing: bool = True) -> lagrange.core.IndexedAttribute:
-        """
-        Get an indexed attribute by name.
-        
-        :param name: Name of the attribute.
-        :type name: str
-        :param sharing: Whether to allow sharing the attribute with other meshes.
-        :type sharing: bool
-        
-        :returns: The indexed attribute.
-        """
-        ...
-    
-    @overload
-    def indexed_attribute(self, id: int, sharing: bool = True) -> lagrange.core.IndexedAttribute:
-        """
-        Get an indexed attribute by id.
-        
-        :param id: Id of the attribute.
-        :type id: AttributeId
-        :param sharing: Whether to allow sharing the attribute with other meshes.
-        :type sharing: bool
-        
-        :returns: The indexed attribute.
-        """
-        ...
-    
-    def initialize_edges(self, edges: Optional[numpy.typing.NDArray] = None) -> None:
-        """
-        Initialize the edges.
-        
-        The `edges` tensor provides a predefined ordering of the edges.
-        If not provided, the edges are initialized in an arbitrary order.
-        
-        :param edges: M x 2 tensor of predefined edge vertex indices, where M is the number of edges.
-        :type edges: numpy.ndarray, optional
-        """
-        ...
-    
-    def is_attribute_indexed(self, arg: str, /) -> bool:
-        """
-        is_attribute_indexed(self, arg: str, /) -> bool
-        """
-        ...
-    
-    @overload
-    def is_attribute_indexed(self, arg: int, /) -> bool:
-        """
-        is_attribute_indexed(self, arg: int, /) -> bool
-        """
-        ...
-    
-    def is_boundary_edge(self, arg: int, /) -> bool:
-        ...
-    
-    @property
-    def is_hybrid(self) -> bool:
-        ...
-    
-    @property
-    def is_quad_mesh(self) -> bool:
-        ...
-    
-    @property
-    def is_regular(self) -> bool:
-        ...
-    
-    @property
-    def is_triangle_mesh(self) -> bool:
-        ...
-    
-    @property
-    def num_corners(self) -> int:
-        ...
-    
-    @property
-    def num_edges(self) -> int:
-        ...
-    
-    @property
-    def num_facets(self) -> int:
-        ...
-    
-    @property
-    def num_vertices(self) -> int:
-        ...
-    
-    def ref_facet_vertices(self, arg: int, /) -> numpy.typing.NDArray:
-        ...
-    
-    def ref_position(self, arg: int, /) -> numpy.typing.NDArray:
-        ...
-    
-    def remove_facets(self, arg: numpy.typing.NDArray, /) -> None:
-        """
-        remove_facets(self, facets: list) -> None
-        
-        Remove selected facets from the mesh.
-        
-        :param facets: list of facet indices to remove
-        """
-        ...
-    
-    def remove_vertices(self, arg: numpy.typing.NDArray, /) -> None:
-        """
-        remove_vertices(self, vertices: list) -> None
-        
-        Remove selected vertices from the mesh.
-        
-        :param vertices: list of vertex indices to remove
-        """
-        ...
-    
-    def rename_attribute(self, arg0: str, arg1: str, /) -> None:
-        ...
-    
-    def shrink_to_fit(self) -> None:
-        ...
-    
-    @property
-    def vertex_per_facet(self) -> int:
-        ...
-    
-    @property
-    def vertices(self) -> numpy.typing.NDArray:
-        """
-        Vertices of the mesh.
-        """
-        ...
-    @vertices.setter
-    def vertices(self, arg: numpy.typing.NDArray, /) -> None:
-        """
-        Vertices of the mesh.
-        """
-        ...
-    
-    def wrap_as_attribute(self, name: str, element: lagrange.core.AttributeElement, usage: lagrange.core.AttributeUsage, values: numpy.typing.NDArray) -> int:
-        """
-        Wrap an existing numpy array as an attribute.
-        
-        :param name: Name of the attribute.
-        :type name: str
-        :param element: Element type of the attribute.
-        :type element: AttributeElement
-        :param usage: Usage type of the attribute.
-        :type usage: AttributeUsage
-        :param values: Values of the attribute.
-        :type values: numpy.ndarray
-        
-        :returns: The id of the created attribute.
-        """
-        ...
-    
-    def wrap_as_facets(self, offsets: numpy.typing.NDArray, num_facets: int, facets: numpy.typing.NDArray, num_corners: int) -> int:
-        """
-        Wrap a tensor as a list of hybrid facets.
-        
-        :param offsets: The offset indices into the facets array.
-        :type offsets: numpy.ndarray
-        :param num_facets: Number of facets.
-        :type num_facets: int
-        :param facets: The indices of the vertices of the facets.
-        :type facets: numpy.ndarray
-        :param num_corners: Number of corners.
-        :type num_corners: int
-        
-        :return: The id of the wrapped facet attribute.
-        """
-        ...
-    
-    @overload
-    def wrap_as_facets(self, tensor: numpy.typing.NDArray, num_facets: int, vertex_per_facet: int) -> int:
-        """
-        Wrap a tensor as a list of regular facets.
-        
-        :param tensor: The tensor to wrap.
-        :type tensor: numpy.ndarray
-        :param num_facets: Number of facets.
-        :type num_facets: int
-        :param vertex_per_facet: Number of vertices per facet.
-        :type vertex_per_facet: int
-        
-        :return: The id of the wrapped facet attribute.
-        """
-        ...
-    
-    def wrap_as_indexed_attribute(self, name: str, usage: lagrange.core.AttributeUsage, values: numpy.typing.NDArray, indices: numpy.typing.NDArray) -> int:
-        """
-        Wrap an existing numpy array as an indexed attribute.
-        
-        :param name: Name of the attribute.
-        :type name: str
-        :param usage: Usage type of the attribute.
-        :type usage: AttributeUsage
-        :param values: Values of the attribute.
-        :type values: numpy.ndarray
-        :param indices: Indices of the attribute.
-        :type indices: numpy.ndarray
-        
-        :returns: The id of the created attribute.
-        """
-        ...
-    
-    def wrap_as_vertices(self, tensor: numpy.typing.NDArray, num_vertices: int) -> int:
-        """
-        Wrap a tensor as vertices.
-        
-        :param tensor: The tensor to wrap.
-        :type tensor: numpy.ndarray
-        :param num_vertices: Number of vertices.
-        :type num_vertices: int
-        
-        :return: The id of the wrapped vertices attribute.
-        """
-        ...
-    
-class TangentBitangentOptions:
-    """
-    Tangent bitangent options
-    """
-
-    def __init__(self) -> None:
-        ...
-    
-    @property
-    def bitangent_attribute_name(self) -> str:
-        """
-        The name of the output bitangent attribute, default is '@bitangent'
-        """
-        ...
-    @bitangent_attribute_name.setter
-    def bitangent_attribute_name(self, arg: str, /) -> None:
-        """
-        The name of the output bitangent attribute, default is '@bitangent'
-        """
-        ...
-    
-    @property
-    def normal_attribute_name(self) -> str:
-        """
-        The name of the normal attribute
-        """
-        ...
-    @normal_attribute_name.setter
-    def normal_attribute_name(self, arg: str, /) -> None:
-        """
-        The name of the normal attribute
-        """
-        ...
-    
-    @property
-    def output_element_type(self) -> lagrange.core.AttributeElement:
-        """
-        The output element type
-        """
-        ...
-    @output_element_type.setter
-    def output_element_type(self, arg: lagrange.core.AttributeElement, /) -> None:
-        """
-        The output element type
-        """
-        ...
-    
-    @property
-    def pad_with_sign(self) -> bool:
-        """
-        Whether to pad the output tangent/bitangent with sign
-        """
-        ...
-    @pad_with_sign.setter
-    def pad_with_sign(self, arg: bool, /) -> None:
-        """
-        Whether to pad the output tangent/bitangent with sign
-        """
-        ...
-    
-    @property
-    def tangent_attribute_name(self) -> str:
-        """
-        The name of the output tangent attribute, default is '@tangent'
-        """
-        ...
-    @tangent_attribute_name.setter
-    def tangent_attribute_name(self, arg: str, /) -> None:
-        """
-        The name of the output tangent attribute, default is '@tangent'
-        """
-        ...
-    
-    @property
-    def uv_attribute_name(self) -> str:
-        """
-        The name of the uv attribute
-        """
-        ...
-    @uv_attribute_name.setter
-    def uv_attribute_name(self, arg: str, /) -> None:
-        """
-        The name of the uv attribute
-        """
-        ...
-    
-class TangentBitangentResult:
-    """
-    Tangent bitangent result
-    """
-
-    def __init__(self) -> None:
-        ...
-    
-    @property
-    def bitangent_id(self) -> int:
-        """
-        The output bitangent attribute id
-        """
-        ...
-    @bitangent_id.setter
-    def bitangent_id(self, arg: int, /) -> None:
-        """
-        The output bitangent attribute id
-        """
-        ...
-    
-    @property
-    def tangent_id(self) -> int:
-        """
-        The output tangent attribute id
-        """
-        ...
-    @tangent_id.setter
-    def tangent_id(self, arg: int, /) -> None:
-        """
-        The output tangent attribute id
-        """
-        ...
-    
-class VertexNormalOptions:
-    """
-    Options for computing vertex normals
-    """
-
-    def __init__(self) -> None:
-        ...
-    
-    @property
-    def keep_weighted_corner_normals(self) -> bool:
-        """
-        Whether to keep the weighted corner normal attribute. Default is false.
-        """
-        ...
-    @keep_weighted_corner_normals.setter
-    def keep_weighted_corner_normals(self, arg: bool, /) -> None:
-        """
-        Whether to keep the weighted corner normal attribute. Default is false.
-        """
-        ...
-    
-    @property
-    def output_attribute_name(self) -> str:
-        """
-        Output attribute name. Default is '@vertex_normal'.
-        """
-        ...
-    @output_attribute_name.setter
-    def output_attribute_name(self, arg: str, /) -> None:
-        """
-        Output attribute name. Default is '@vertex_normal'.
-        """
-        ...
-    
-    @property
-    def recompute_weighted_corner_normals(self) -> bool:
-        """
-        Whether to recompute weighted corner normals. Default is false
-        """
-        ...
-    @recompute_weighted_corner_normals.setter
-    def recompute_weighted_corner_normals(self, arg: bool, /) -> None:
-        """
-        Whether to recompute weighted corner normals. Default is false
-        """
-        ...
-    
-    @property
-    def weight_type(self) -> lagrange.core.NormalWeightingType:
-        """
-        Weighting type for normal computation. Default is Angle.
-        """
-        ...
-    @weight_type.setter
-    def weight_type(self, arg: lagrange.core.NormalWeightingType, /) -> None:
-        """
-        Weighting type for normal computation. Default is Angle.
-        """
-        ...
-    
-    @property
-    def weighted_corner_normal_attribute_name(self) -> str:
-        """
-        Precomputed weighted corner normals attribute name.Default is '@weighted_corner_normal'. If attribute exists, the weighted corner normals will be used instead of recomputing them.
-        """
-        ...
-    @weighted_corner_normal_attribute_name.setter
-    def weighted_corner_normal_attribute_name(self, arg: str, /) -> None:
-        """
-        Precomputed weighted corner normals attribute name.Default is '@weighted_corner_normal'. If attribute exists, the weighted corner normals will be used instead of recomputing them.
-        """
-        ...
-    
-class VertexValenceOptions:
-    """
-    Vertex valence options
-    """
-
-    def __init__(self) -> None:
-        ...
-    
-    @property
-    def output_attribute_name(self) -> str:
-        """
-        The name of the output attribute
-        """
-        ...
-    @output_attribute_name.setter
-    def output_attribute_name(self, arg: str, /) -> None:
-        """
-        The name of the output attribute
-        """
-        ...
-    
-def cast_attribute(mesh: lagrange.core.SurfaceMesh, input_attribute: Union[int, str], dtype: type, output_attribute_name: Optional[str] = None) -> int:
-    """
-    Cast an attribute to a new dtype.
-    
-    :param mesh:            The input mesh.
-    :param input_attribute: The input attribute id or name.
-    :param dtype:           The new dtype.
-    :param output_attribute_name: The output attribute name. If none, cast will replace the input attribute.
-    
-    :returns: The id of the new attribute.
-    """
-    ...
-
-def combine_meshes(meshes: list[lagrange.core.SurfaceMesh], preserve_attributes: bool = True) -> lagrange.core.SurfaceMesh:
-    """
-    Combine a list of meshes into a single mesh.
-    
-    :param meshes: input meshes
-    :type meshes: list[SurfaceMesh]
-    :param preserve_attributes: whether to preserve attributes
-    :type preserve_attributes: bool
-    
-    :returns: the combined mesh
-    """
-    ...
-
-def compute_components(mesh: lagrange.core.SurfaceMesh, output_attribute_name: Optional[str] = None, connectivity_type: Optional[lagrange.core.ConnectivityType] = None, blocker_elements: Optional[list] = None) -> int:
-    """
-    Compute connected components.
-    
-    This method will create a per-facet component id attribute named by the `output_attribute_name`
-    argument. Each component id is in [0, num_components-1] range.
-    
-    :param mesh: The input mesh.
-    :param output_attribute_name: The name of the output attribute.
-    :param connectivity_type: The connectivity type.  Either "Vertex" or "Edge".
-    :param blocker_elements: The list of blocker element indices. If `connectivity_type` is `Edge`, facets adjacent to a blocker edge are not considered as connected through this edge. If `connectivity_type` is `Vertex`, facets sharing a blocker vertex are not considered as connected through this vertex.
-    
-    :returns: The total number of components.
-    """
-    ...
-
-def compute_dihedral_angles(mesh: lagrange.core.SurfaceMesh, output_attribute_name: Optional[str] = None, facet_normal_attribute_name: Optional[str] = None, recompute_facet_normals: Optional[bool] = None, keep_facet_normals: Optional[bool] = None) -> int:
-    """
-    Compute dihedral angles for each edge.
-    
-    The dihedral angle of an edge is defined as the angle between the __normals__ of two facets adjacent
-    to the edge. The dihedral angle is always in the range [0, pi] for manifold edges. For boundary
-    edges, the dihedral angle defaults to 0.  For non-manifold edges, the dihedral angle is not
-    well-defined and will be set to the special value 2 * M_PI.
-    
-    :param mesh:                        The source mesh.
-    :param output_attribute_name:       The optional edge attribute name to store the dihedral angles.
-    :param facet_normal_attribute_name: The optional attribute name to store the facet normals.
-    :param recompute_facet_normals:     Whether to recompute facet normals.
-    :param keep_facet_normals:          Whether to keep newly computed facet normals. It has no effect on pre-existing facet normals.
-    
-    :return: The edge attribute id of dihedral angles.
-    """
-    ...
-
-def compute_dijkstra_distance(mesh: lagrange.core.SurfaceMesh, seed_facet: int, barycentric_coords: list, radius: Optional[float] = None, output_attribute_name: str = '@dijkstra_distance', output_involved_vertices: bool = False) -> Optional[list[int]]:
-    """
-    Compute Dijkstra distance from a seed facet.
-    
-    :param mesh:                  The source mesh.
-    :param seed_facet:            The seed facet index.
-    :param barycentric_coords:    The barycentric coordinates of the seed facet.
-    :param radius:                The maximum radius of the dijkstra distance.
-    :param output_attribute_name: The output attribute name to store the dijkstra distance.
-    :param output_involved_vertices: Whether to output the list of involved vertices.
-    """
-    ...
-
-def compute_edge_lengths(mesh: lagrange.core.SurfaceMesh, output_attribute_name: Optional[str] = None) -> int:
-    """
-    Compute edge lengths.
-    
-    :param mesh:                  The source mesh.
-    :param output_attribute_name: The optional edge attribute name to store the edge lengths.
-    
-    :return: The edge attribute id of edge lengths.
-    """
-    ...
-
-def compute_euler(mesh: lagrange.core.SurfaceMesh) -> int:
-    """
-    Compute the Euler characteristic.
-    
-    :param mesh: The source mesh.
-    
-    :return: The Euler characteristic.
-    """
-    ...
-
-def compute_facet_area(*args, **kwargs):
-    """
-    compute_facet_area(mesh: lagrange.core.SurfaceMesh, options: lagrange.core.FacetAreaOptions = <lagrange.core.FacetAreaOptions object at 0x000001A7A5812300>) -> int
-    compute_facet_area(mesh: lagrange.core.SurfaceMesh, output_attribute_name: Optional[str] = None) -> int
-    
-    Overloaded function.
-    
-    1. ``compute_facet_area(mesh: lagrange.core.SurfaceMesh, options: lagrange.core.FacetAreaOptions = <lagrange.core.FacetAreaOptions object at 0x000001A7A5812300>) -> int``
-    
-    Compute facet area.
-    
-    :param mesh: The input mesh.
-    :param options: The options for computing facet area.
-    
-    :returns: The id of the new attribute.
-    
-    2. ``compute_facet_area(mesh: lagrange.core.SurfaceMesh, output_attribute_name: Optional[str] = None) -> int``
-    
-    Compute facet area (Pythonic API).
-    
-    :param mesh: The input mesh.
-    :param output_attribute_name: The name of the output attribute.
-    
-    :returns: The id of the new attribute.
-    """
-    ...
-
-def compute_facet_centroid(*args, **kwargs):
-    """
-    compute_facet_centroid(mesh: lagrange.core.SurfaceMesh, options: lagrange.core.FacetCentroidOptions = <lagrange.core.FacetCentroidOptions object at 0x000001A7A5812270>) -> int
-    compute_facet_centroid(mesh: lagrange.core.SurfaceMesh, output_attribute_name: Optional[str] = None) -> int
-    
-    Overloaded function.
-    
-    1. ``compute_facet_centroid(mesh: lagrange.core.SurfaceMesh, options: lagrange.core.FacetCentroidOptions = <lagrange.core.FacetCentroidOptions object at 0x000001A7A5812270>) -> int``
-    
-    Compute facet centroid.
-    
-    :param mesh: The input mesh.
-    :param options: The options for computing facet centroid.
-    
-    :returns: The id of the new attribute.
-    
-    2. ``compute_facet_centroid(mesh: lagrange.core.SurfaceMesh, output_attribute_name: Optional[str] = None) -> int``
-    
-    Compute facet centroid (Pythonic API).
-    
-    :param mesh: The input mesh.
-    :param output_attribute_name: The name of the output attribute.
-    
-    :returns: The id of the new attribute.
-    """
-    ...
-
-def compute_facet_normal(*args, **kwargs):
-    """
-    compute_facet_normal(mesh: lagrange.core.SurfaceMesh, options: lagrange.core.FacetNormalOptions = <lagrange.core.FacetNormalOptions object at 0x000001A7A5812600>) -> int
-    compute_facet_normal(mesh: lagrange.core.SurfaceMesh, output_attribute_name: Optional[str] = None) -> int
-    
-    Overloaded function.
-    
-    1. ``compute_facet_normal(mesh: lagrange.core.SurfaceMesh, options: lagrange.core.FacetNormalOptions = <lagrange.core.FacetNormalOptions object at 0x000001A7A5812600>) -> int``
-    
-    Compute facet normal.
-    
-    :param mesh: Input mesh.
-    :param options: Options for computing facet normals.
-    
-    :returns: Facet normal attribute id.
-    
-    2. ``compute_facet_normal(mesh: lagrange.core.SurfaceMesh, output_attribute_name: Optional[str] = None) -> int``
-    
-    Compute facet normal (Pythonic API).
-    
-    :param mesh: Input mesh.
-    :param output_attribute_name: Output attribute name.
-    
-    :returns: Facet normal attribute id.
-    """
-    ...
-
-def compute_greedy_coloring(mesh: lagrange.core.SurfaceMesh, element_type: lagrange.core.AttributeElement = lagrange.core.AttributeElement.Facet, num_color_used: int = 8, output_attribute_name: Optional[str] = None) -> int:
-    """
-    Compute greedy coloring of mesh elements.
-    
-    :param mesh: Input mesh.
-    :param element_type: Element type to be colored. Can be either Vertex or Facet.
-    :param num_color_used: Minimum number of colors to use. The algorithm will cycle through them but may use more.
-    :param output_attribute_name: Output attribute name.
-    
-    :returns: Color attribute id.
-    """
-    ...
-
-def compute_mesh_area(*args, **kwargs):
-    """
-    compute_mesh_area(mesh: lagrange.core.SurfaceMesh, options: lagrange.core.MeshAreaOptions = <lagrange.core.MeshAreaOptions object at 0x000001A7A58122D0>) -> float
-    compute_mesh_area(mesh: lagrange.core.SurfaceMesh, input_attribute_name: Optional[str] = None, use_signed_area: Optional[bool] = None) -> float
-    
-    Overloaded function.
-    
-    1. ``compute_mesh_area(mesh: lagrange.core.SurfaceMesh, options: lagrange.core.MeshAreaOptions = <lagrange.core.MeshAreaOptions object at 0x000001A7A58122D0>) -> float``
-    
-    Compute mesh area.
-    
-    :param mesh: The input mesh.
-    :param options: The options for computing mesh area.
-    
-    :returns: The mesh area.
-    
-    2. ``compute_mesh_area(mesh: lagrange.core.SurfaceMesh, input_attribute_name: Optional[str] = None, use_signed_area: Optional[bool] = None) -> float``
-    
-    Compute mesh area (Pythonic API).
-    
-    :param mesh: The input mesh.
-    :param input_attribute_name: The name of the pre-computed facet area attribute.
-    :param use_signed_area: Whether to use signed area.
-    
-    :returns: The mesh area.
-    """
-    ...
-
-def compute_mesh_centroid(*args, **kwargs):
-    """
-    compute_mesh_centroid(mesh: lagrange.core.SurfaceMesh, options: lagrange.core.MeshCentroidOptions = <lagrange.core.MeshCentroidOptions object at 0x000001A7A58592F0>) -> list[float]
-    compute_mesh_centroid(mesh: lagrange.core.SurfaceMesh, weighting_type: Optional[lagrange.core.CentroidWeightingType] = None, facet_centroid_attribute_name: Optional[str] = None, facet_area_attribute_name: Optional[str] = None) -> list[float]
-    
-    Overloaded function.
-    
-    1. ``compute_mesh_centroid(mesh: lagrange.core.SurfaceMesh, options: lagrange.core.MeshCentroidOptions = <lagrange.core.MeshCentroidOptions object at 0x000001A7A58592F0>) -> list[float]``
-    
-    Compute mesh centroid.
-    
-    :param mesh: The input mesh.
-    :param options: The options for computing mesh centroid.
-    
-    :returns: The mesh centroid.
-    
-    2. ``compute_mesh_centroid(mesh: lagrange.core.SurfaceMesh, weighting_type: Optional[lagrange.core.CentroidWeightingType] = None, facet_centroid_attribute_name: Optional[str] = None, facet_area_attribute_name: Optional[str] = None) -> list[float]``
-    
-    Compute mesh centroid (Pythonic API).
-    
-    :param mesh: The input mesh.
-    :param weighting_type: The weighting type. Default is `Area`.
-    :param facet_centroid_attribute_name: The name of the pre-computed facet centroid attribute if available. Default is '@facet_centroid'.
-    :param facet_area_attribute_name: The name of the pre-computed facet area attribute if available. Default is '@facet_area'.
-    
-    :returns: The mesh centroid.
-    """
-    ...
-
-def compute_normal(mesh: lagrange.core.SurfaceMesh, feature_angle_threshold: float = 0.7853981633974483, cone_vertices: Optional[object] = None, output_attribute_name: Optional[str] = None, weight_type: Optional[lagrange.core.NormalWeightingType] = None, facet_normal_attribute_name: Optional[str] = None, recompute_facet_normals: Optional[bool] = None, keep_facet_normals: Optional[bool] = None) -> int:
-    """
-    Compute indexed normal attribute (Pythonic API).
-    
-    :param mesh: input mesh
-    :type mesh: SurfaceMesh
-    :param feature_angle_threshold: feature angle threshold
-    :type feature_angle_threshold: float, optional
-    :param cone_vertices: cone vertices
-    :type cone_vertices: list[int] or numpy.ndarray, optional
-    :param output_attribute_name: output normal attribute name
-    :type output_attribute_name: str, optional
-    :param weight_type: normal weighting type
-    :type weight_type: NormalWeightingType, optional
-    :param facet_normal_attribute_name: facet normal attribute name
-    :type facet_normal_attribute_name: str, optional
-    :param recompute_facet_normals: whether to recompute facet normals
-    :type recompute_facet_normals: bool, optional
-    :param keep_facet_normals: whether to keep the computed facet normal attribute
-    :type keep_facet_normals: bool, optional
-    
-    :returns: the id of the indexed normal attribute.
-    """
-    ...
-
-@overload
-def compute_normal(mesh: lagrange.core.SurfaceMesh, feature_angle_threshold: float = 0.7853981633974483, cone_vertices: Optional[object] = None, options: Optional[lagrange.core.NormalOptions] = None) -> int:
-    """
-    Compute indexed normal attribute.
-    
-    Edge with dihedral angles larger than `feature_angle_threshold` are considered as sharp edges.
-    Vertices listed in `cone_vertices` are considered as cone vertices, which is always sharp.
-    
-    :param mesh: input mesh
-    :type mesh: SurfaceMesh
-    :param feature_angle_threshold: feature angle threshold
-    :type feature_angle_threshold: float, optional
-    :param cone_vertices: cone vertices
-    :type cone_vertices: list[int] or numpy.ndarray, optional
-    :param options: normal options
-    :type optional: NormalOptions, optional
-    
-    :returns: the id of the indexed normal attribute.
-    """
-    ...
-
-def compute_seam_edges(mesh: lagrange.core.SurfaceMesh, indexed_attribute_id: int, output_attribute_name: Optional[str] = None) -> int:
-    """
-    Computer seam edges for a given indexed attribute.
-    
-    :param mesh: Input mesh.
-    :param indexed_attribute_id: Input indexed attribute id.
-    :param output_attribute_name: Output attribute name.
-    
-    :returns: Attribute id for the output per-edge seam attribute (1 is a seam, 0 is not).
-    """
-    ...
-
-def compute_tangent_bitangent(*args, **kwargs):
-    """
-    compute_tangent_bitangent(mesh: lagrange.core.SurfaceMesh, options: lagrange.core.TangentBitangentOptions = <lagrange.core.TangentBitangentOptions object at 0x000001A7A5842810>) -> lagrange.core.TangentBitangentResult
-    compute_tangent_bitangent(mesh: lagrange.core.SurfaceMesh, tangent_attribute_name: Optional[str] = None, bitangent_attribute_name: Optional[str] = None, uv_attribute_name: Optional[str] = None, normal_attribute_name: Optional[str] = None, output_attribute_type: Optional[lagrange.core.AttributeElement] = None, pad_with_sign: Optional[bool] = None) -> tuple[int, int]
-    
-    Overloaded function.
-    
-    1. ``compute_tangent_bitangent(mesh: lagrange.core.SurfaceMesh, options: lagrange.core.TangentBitangentOptions = <lagrange.core.TangentBitangentOptions object at 0x000001A7A5842810>) -> lagrange.core.TangentBitangentResult``
-    
-    Compute tangent and bitangent vector attributes.
-    
-    :param mesh: The input mesh.
-    :param options: The tangent bitangent options.
-    
-    :returns: The tangent and bitangent attribute ids
-    
-    2. ``compute_tangent_bitangent(mesh: lagrange.core.SurfaceMesh, tangent_attribute_name: Optional[str] = None, bitangent_attribute_name: Optional[str] = None, uv_attribute_name: Optional[str] = None, normal_attribute_name: Optional[str] = None, output_attribute_type: Optional[lagrange.core.AttributeElement] = None, pad_with_sign: Optional[bool] = None) -> tuple[int, int]``
-    
-    Compute tangent and bitangent vector attributes (Pythonic API).
-    
-    :param mesh: The input mesh.
-    :param tangent_attribute_name: The name of the output tangent attribute.
-    :param bitangent_attribute_name: The name of the output bitangent attribute.
-    :param uv_attribute_name: The name of the uv attribute.
-    :param normal_attribute_name: The name of the normal attribute.
-    :param output_attribute_type: The output element type.
-    :param pad_with_sign: Whether to pad the output tangent/bitangent with sign.
-    
-    :returns: The tangent and bitangent attribute ids
-    """
-    ...
-
-def compute_uv_distortion(mesh: lagrange.core.SurfaceMesh, uv_attribute_name: str = '@uv', output_attribute_name: str = '@uv_measure', metric: lagrange.core.DistortionMetric = lagrange.core.DistortionMetric.MIPS) -> int:
-    """
-    Compute UV distortion.
-    
-    :param mesh:                  The source mesh.
-    :param uv_attribute_name:     The input UV attribute name. Default is "@uv".
-    :param output_attribute_name: The output attribute name to store the distortion. Default is "@uv_measure".
-    :param metric:                The distortion metric. Default is MIPS.
-    
-    :return: The facet attribute id for distortion.
-    """
-    ...
-
-def compute_vertex_normal(*args, **kwargs):
-    """
-    compute_vertex_normal(mesh: lagrange.core.SurfaceMesh, options: lagrange.core.VertexNormalOptions = <lagrange.core.VertexNormalOptions object at 0x000001A7A5849CB0>) -> int
-    compute_vertex_normal(mesh: lagrange.core.SurfaceMesh, output_attribute_name: Optional[str] = None, weight_type: Optional[lagrange.core.NormalWeightingType] = None, weighted_corner_normal_attribute_name: Optional[str] = None, recompute_weighted_corner_normals: Optional[bool] = None, keep_weighted_corner_normals: Optional[bool] = None) -> int
-    
-    Overloaded function.
-    
-    1. ``compute_vertex_normal(mesh: lagrange.core.SurfaceMesh, options: lagrange.core.VertexNormalOptions = <lagrange.core.VertexNormalOptions object at 0x000001A7A5849CB0>) -> int``
-    
-    Computer vertex normal.
-    
-    :param mesh: Input mesh.
-    :param options: Options for computing vertex normals.
-    
-    :returns: Vertex normal attribute id.
-    
-    2. ``compute_vertex_normal(mesh: lagrange.core.SurfaceMesh, output_attribute_name: Optional[str] = None, weight_type: Optional[lagrange.core.NormalWeightingType] = None, weighted_corner_normal_attribute_name: Optional[str] = None, recompute_weighted_corner_normals: Optional[bool] = None, keep_weighted_corner_normals: Optional[bool] = None) -> int``
-    
-    Computer vertex normal (Pythonic API).
-    
-    :param mesh: Input mesh.
-    :param output_attribute_name: Output attribute name.
-    :param weight_type: Weighting type for normal computation.
-    :param weighted_corner_normal_attribute_name: Precomputed weighted corner normals attribute name.
-    :param recompute_weighted_corner_normals: Whether to recompute weighted corner normals.
-    :param keep_weighted_corner_normals: Whether to keep the weighted corner normal attribute.
-    
-    :returns: Vertex normal attribute id.
-    """
-    ...
-
-def compute_vertex_valence(*args, **kwargs):
-    """
-    compute_vertex_valence(mesh: lagrange.core.SurfaceMesh, options: lagrange.core.VertexValenceOptions = <lagrange.core.VertexValenceOptions object at 0x000001A7A58124B0>) -> int
-    compute_vertex_valence(mesh: lagrange.core.SurfaceMesh, output_attribute_name: Optional[str] = None) -> int
-    
-    Overloaded function.
-    
-    1. ``compute_vertex_valence(mesh: lagrange.core.SurfaceMesh, options: lagrange.core.VertexValenceOptions = <lagrange.core.VertexValenceOptions object at 0x000001A7A58124B0>) -> int``
-    
-    Compute vertex valence
-    
-    :param mesh: The input mesh.
-    :param options: The vertex valence options.
-    
-    :returns: The vertex valence attribute id.
-    
-    2. ``compute_vertex_valence(mesh: lagrange.core.SurfaceMesh, output_attribute_name: Optional[str] = None) -> int``
-    
-    Compute vertex valence);
-    
-    :param mesh: The input mesh.
-    :param output_attribute_name: The name of the output attribute.
-    
-    :returns: The vertex valence attribute id
-    """
-    ...
-
-def detect_degenerate_facets(mesh: lagrange.core.SurfaceMesh) -> list[int]:
-    """
-    Detect degenerate facets in a mesh.
-    
-    .. note:
-    Only __exaxtly__ degenerate facets are detected.
-    
-    :param mesh: The input mesh.
-    
-    :returns: A list of indices of degenerate facets.
-    """
-    ...
-
-def extract_submesh(mesh: lagrange.core.SurfaceMesh, selected_facets: numpy.typing.NDArray, source_vertex_attr_name: str = '', source_facet_attr_name: str = '', map_attributes: bool = False) -> lagrange.core.SurfaceMesh:
-    """
-    Extract a submesh based on the selected facets.
-    
-    :param mesh:                    The source mesh.
-    :param selected_facets:         A listed of facet ids to extract.
-    :param source_vertex_attr_name: The optional attribute name to track source vertices.
-    :param source_facet_attr_name:  The optional attribute name to track source facets.
-    :param map_attributes:          Map attributes from the source to target meshes.
-    
-    :returns: A mesh that contains only the selected facets.
-    """
-    ...
-
-def filter_attributes(mesh: lagrange.core.SurfaceMesh, included_attributes: Optional[list[Union[int, str]]] = None, excluded_attributes: Optional[list[Union[int, str]]] = None, included_usages: Optional[set[lagrange.core.AttributeUsage]] = None, included_element_types: Optional[set[lagrange.core.AttributeElement]] = None) -> lagrange.core.SurfaceMesh:
-    """
-    Filters the attributes of mesh according to user specifications.
-    
-    :param mesh: Input mesh.
-    :param included_attributes: List of attribute names or ids to include. By default, all attributes are included.
-    :param excluded_attributes: List of attribute names or ids to exclude. By default, no attribute is excluded.
-    :param included_usages: List of attribute usages to include. By default, all usages are included.
-    :param included_element_types: List of attribute element types to include. By default, all element types are included.
-    """
-    ...
-
-invalid_index: int
-
-invalid_scalar: float
-
-def is_edge_manifold(mesh: lagrange.core.SurfaceMesh) -> bool:
-    """
-    Check if the mesh is edge manifold.
-    
-    :param mesh: The source mesh.
-    
-    :return: Whether the mesh is edge manifold.
-    """
-    ...
-
-def is_manifold(mesh: lagrange.core.SurfaceMesh) -> bool:
-    """
-    Check if the mesh is manifold.
-    
-    A mesh considered as manifold if it is both vertex and edge manifold.
-    
-    :param mesh: The source mesh.
-    
-    :return: Whether the mesh is manifold.
-    """
-    ...
-
-def is_vertex_manifold(mesh: lagrange.core.SurfaceMesh) -> bool:
-    """
-    Check if the mesh is vertex manifold.
-    
-    :param mesh: The source mesh.
-    
-    :return: Whether the mesh is vertex manifold.
-    """
-    ...
-
-def map_attribute(mesh: lagrange.core.SurfaceMesh, old_attribute_name: str, new_attribute_name: str, new_element: lagrange.core.AttributeElement) -> int:
-    """
-    Map an attribute to a new element type.
-    
-    :param mesh: The input mesh.
-    :param old_attribute_name: The name of the input attribute.
-    :param new_attribute_name: The name of the new attribute.
-    :param new_element: The new element type.
-    
-    :returns: The id of the new attribute.
-    """
-    ...
-
-@overload
-def map_attribute(mesh: lagrange.core.SurfaceMesh, old_attribute_id: int, new_attribute_name: str, new_element: lagrange.core.AttributeElement) -> int:
-    """
-    Map an attribute to a new element type.
-    
-    :param mesh: The input mesh.
-    :param old_attribute_id: The id of the input attribute.
-    :param new_attribute_name: The name of the new attribute.
-    :param new_element: The new element type.
-    
-    :returns: The id of the new attribute.
-    """
-    ...
-
-def map_attribute_in_place(mesh: lagrange.core.SurfaceMesh, name: str, new_element: lagrange.core.AttributeElement) -> int:
-    """
-    Map an attribute to a new element type in place.
-    
-    :param mesh: The input mesh.
-    :param name: The name of the input attribute.
-    :param new_element: The new element type.
-    
-    :returns: The id of the new attribute.
-    """
-    ...
-
-@overload
-def map_attribute_in_place(mesh: lagrange.core.SurfaceMesh, id: int, new_element: lagrange.core.AttributeElement) -> int:
-    """
-    Map an attribute to a new element type in place.
-    
-    :param mesh: The input mesh.
-    :param id: The id of the input attribute.
-    :param new_element: The new element type.
-    
-    :returns: The id of the new attribute.
-    """
-    ...
-
-def normalize_mesh(mesh: lagrange.core.SurfaceMesh) -> None:
-    """
-    Normalize a mesh to fit into a unit box centered at the origin.
-    
-    :param mesh: input mesh
-    """
-    ...
-
-def normalize_meshes(meshes: list[lagrange.core.SurfaceMesh]) -> None:
-    """
-    Normalize a list of meshes to fit into a unit box centered at the origin.
-    
-    :param meshes: input meshes
-    """
-    ...
-
-def permute_facets(mesh: lagrange.core.SurfaceMesh, new_to_old: numpy.typing.NDArray) -> None:
-    """
-    Reorder facets of a mesh in place based on a permutation.
-    
-    :param mesh: input mesh
-    :param new_to_old: permutation vector for facets
-    """
-    ...
-
-def permute_vertices(mesh: lagrange.core.SurfaceMesh, new_to_old: numpy.typing.NDArray) -> None:
-    """
-    Reorder vertices of a mesh in place based on a permutation.
-    
-    :param mesh: input mesh
-    :param new_to_old: permutation vector for vertices
-    """
-    ...
-
-def remap_vertices(*args, **kwargs):
-    """
-    remap_vertices(mesh: lagrange.core.SurfaceMesh, old_to_new: numpy.ndarray[dtype=uint32, order='C', device='cpu'], options: lagrange.core.RemapVerticesOptions = <lagrange.core.RemapVerticesOptions object at 0x000001A7A584C2F0>) -> None
-    remap_vertices(mesh: lagrange.core.SurfaceMesh, old_to_new: numpy.ndarray[dtype=uint32, order='C', device='cpu'], collision_policy_float: Optional[lagrange.core.MappingPolicy] = None, collision_policy_integral: Optional[lagrange.core.MappingPolicy] = None) -> None
-    
-    Overloaded function.
-    
-    1. ``remap_vertices(mesh: lagrange.core.SurfaceMesh, old_to_new: numpy.ndarray[dtype=uint32, order='C', device='cpu'], options: lagrange.core.RemapVerticesOptions = <lagrange.core.RemapVerticesOptions object at 0x000001A7A584C2F0>) -> None``
-    
-    Remap vertices of a mesh in place based on a permutation.
-    
-    :param mesh: input mesh
-    :param old_to_new: permutation vector for vertices
-    :param options: options for remapping vertices
-    
-    2. ``remap_vertices(mesh: lagrange.core.SurfaceMesh, old_to_new: numpy.ndarray[dtype=uint32, order='C', device='cpu'], collision_policy_float: Optional[lagrange.core.MappingPolicy] = None, collision_policy_integral: Optional[lagrange.core.MappingPolicy] = None) -> None``
-    
-    Remap vertices of a mesh in place based on a permutation (Pythonic API).
-    
-    :param mesh: input mesh
-    :param old_to_new: permutation vector for vertices
-    :param collision_policy_float: The collision policy for float attributes.
-    :param collision_policy_integral: The collision policy for integral attributes.
-    """
-    ...
-
-def remove_duplicate_facets(mesh: lagrange.core.SurfaceMesh, consider_orientation: bool = False) -> None:
-    """
-    Remove duplicate facets from a mesh.
-    
-    Facets of different orientations (e.g. (0, 1, 2) and (2, 1, 0)) are considered as duplicates.
-    If both orientations have equal number of duplicate facets, all of them are removed.
-    If one orientation has more duplicate facets, all but one facet with the majority orientation are removed.
-    
-    :param mesh: The input mesh. The mesh is modified in place.
-    :param consider_orientation: Whether to consider orientation when detecting duplicate facets.
-    """
-    ...
-
-def remove_duplicate_vertices(mesh: lagrange.core.SurfaceMesh, extra_attributes: Optional[list[int]] = None) -> None:
-    """
-    Remove duplicate vertices from a mesh.
-    
-    :param mesh:             The input mesh.
-    :param extra_attributes: Two vertices are considered duplicates if they have the same position and the same values for all attributes in `extra_attributes`.
-    """
-    ...
-
-def remove_isolated_vertices(mesh: lagrange.core.SurfaceMesh) -> None:
-    """
-    Remove isolated vertices from a mesh.
-    
-    .. note:
-    A vertex is considered isolated if it is not referenced by any facet.
-    
-    :param mesh: The input mesh for inplace modification.
-    """
-    ...
-
-def remove_null_area_facets(mesh: lagrange.core.SurfaceMesh, null_area_threshold: float = 0, remove_isolated_vertices: bool = False) -> None:
-    """
-    Remove facets with unsigned facets area <= `null_area_threhsold`.
-    
-    :param mesh:                     The input mesh.
-    :param null_area_threshold:      The area threshold below which a facet is considered as null facet.
-    :param remove_isolated_vertices: Whether to remove isolated vertices after removing null area facets.
-    """
-    ...
-
-def remove_topologically_degenerate_facets(mesh: lagrange.core.SurfaceMesh) -> None:
-    """
-    Remove topologically degenerate facets such as (0, 1, 1)
-    
-    For general polygons, topologically degeneracy means that the polygon is made of at most two unique
-    vertices. E.g. a quad of the form (0, 0, 1, 1) is degenerate, while a quad of the form (1, 1, 2, 3)
-    is not.
-    
-    :param mesh: The input mesh for inplace modification.
-    """
-    ...
-
-def separate_by_components(mesh: lagrange.core.SurfaceMesh, source_vertex_attr_name: str = '', source_facet_attr_name: str = '', map_attributes: bool = False, connectivity_type: lagrange.core.ConnectivityType = lagrange.core.ConnectivityType.Edge) -> list[lagrange.core.SurfaceMesh]:
-    """
-    Extract a set of submeshes based on connected components.
-    
-    :param mesh:                    The source mesh.
-    :param source_vertex_attr_name: The optional attribute name to track source vertices.
-    :param source_facet_attr_name:  The optional attribute name to track source facets.
-    :param map_attributes:          Map attributes from the source to target meshes.
-    :param connectivity_type:       The connectivity used for component computation.
-    
-    :returns: A list of meshes, one for each connected component.
-    """
-    ...
-
-def separate_by_facet_groups(mesh: lagrange.core.SurfaceMesh, facet_group_indices: numpy.typing.NDArray, source_vertex_attr_name: str = '', source_facet_attr_name: str = '', map_attributes: bool = False) -> list[lagrange.core.SurfaceMesh]:
-    """
-    Extract a set of submeshes based on facet groups.
-    
-    :param mesh:                    The source mesh.
-    :param facet_group_indices:     The group index for each facet. Each group index must be in the range of [0, max(facet_group_indices)]
-    :param source_vertex_attr_name: The optional attribute name to track source vertices.
-    :param source_facet_attr_name:  The optional attribute name to track source facets.
-    
-    :returns: A list of meshes, one for each facet group.
-    """
-    ...
-
-def transform_mesh(mesh: lagrange.core.SurfaceMesh, affine_transform: numpy.typing.NDArray, normalize_normals: bool = True, normalize_tangents_bitangents: bool = True, in_place: bool = True) -> Optional[lagrange.core.SurfaceMesh]:
-    """
-    Apply affine transformation to a mesh.
-    
-    :param mesh:                          The source mesh.
-    :param affine_transform:              The affine transformation matrix.
-    :param normalize_normals:             Whether to normalize normals.
-    :param normalize_tangents_bitangents: Whether to normalize tangents and bitangents.
-    :param in_place:                      Whether to apply the transformation in place.
-    
-    :return: The transformed mesh if in_place is False.
-    """
-    ...
-
-def triangulate_polygonal_facets(mesh: lagrange.core.SurfaceMesh) -> None:
-    """
-    Triangulate polygonal facets of the mesh.
-    
-    :param mesh: The input mesh.
-    """
-    ...
-
-def unify_index_buffer(mesh: lagrange.core.SurfaceMesh, attribute_names: list[str]) -> lagrange.core.SurfaceMesh:
-    """
-    Unify the index buffer of the mesh for selected attributes.
-    
-    :param mesh: The mesh to unify.
-    :type mesh: SurfaceMesh
-    :param attribute_names: The selected attribute names to unify.
-    :type attribute_names: list of str
-    
-    :returns: The unified mesh.
-    """
-    ...
-
-@overload
-def unify_index_buffer(mesh: lagrange.core.SurfaceMesh) -> lagrange.core.SurfaceMesh:
-    """
-    Unify the index buffer of the mesh.  All indexed attributes will be unified.
-    
-    :param mesh: The mesh to unify.
-    :type mesh: SurfaceMesh
-    
-    :returns: The unified mesh.
-    """
-    ...
-
-@overload
-def unify_index_buffer(mesh: lagrange.core.SurfaceMesh, attribute_ids: list[int]) -> lagrange.core.SurfaceMesh:
-    """
-    Unify the index buffer of the mesh for selected attributes.
-    
-    :param mesh: The mesh to unify.
-    :type mesh: SurfaceMesh
-    :param attribute_ids: The selected attribute ids to unify.
-    :type attribute_ids: list of int
-    
-    :returns: The unified mesh.
-    """
-    ...
-
-def weld_indexed_attribute(mesh: lagrange.core.SurfaceMesh, attribute_id: int) -> None:
-    """
-    Weld indexed attribute.
-    
-    :param mesh:         The source mesh.
-    :param attribute_id: The indexed attribute id to weld.
-    """
-    ...
-
+from collections.abc import Sequence, Set
+import enum
+from typing import Annotated, overload
+
+from numpy.typing import ArrayLike
+
+
+class Attribute:
+    """Mesh attribute"""
+
+    @property
+    def element_type(self) -> AttributeElement:
+        """Element type of the attribute."""
+
+    @property
+    def usage(self) -> AttributeUsage:
+        """Usage of the attribute."""
+
+    @property
+    def num_channels(self) -> int:
+        """Number of channels in the attribute."""
+
+    @property
+    def default_value(self) -> object:
+        """Default value of the attribute."""
+
+    @default_value.setter
+    def default_value(self, arg: float, /) -> None: ...
+
+    @property
+    def growth_policy(self) -> AttributeGrowthPolicy:
+        """Growth policy of the attribute."""
+
+    @growth_policy.setter
+    def growth_policy(self, arg: AttributeGrowthPolicy, /) -> None: ...
+
+    @property
+    def shrink_policy(self) -> AttributeShrinkPolicy:
+        """Shrink policy of the attribute."""
+
+    @shrink_policy.setter
+    def shrink_policy(self, arg: AttributeShrinkPolicy, /) -> None: ...
+
+    @property
+    def write_policy(self) -> AttributeWritePolicy:
+        """Write policy of the attribute."""
+
+    @write_policy.setter
+    def write_policy(self, arg: AttributeWritePolicy, /) -> None: ...
+
+    @property
+    def copy_policy(self) -> AttributeCopyPolicy:
+        """Copy policy of the attribute."""
+
+    @copy_policy.setter
+    def copy_policy(self, arg: AttributeCopyPolicy, /) -> None: ...
+
+    def create_internal_copy(self) -> None:
+        """Create an internal copy of the attribute."""
+
+    def clear(self) -> None:
+        """Clear the attribute so it has no elements."""
+
+    def reserve_entries(self, num_entries: int) -> None:
+        """
+        Reserve enough memory for `num_entries` entries.
+
+        :param num_entries: Number of entries to reserve. It does not need to be a multiple of `num_channels`.
+        """
+
+    @overload
+    def insert_elements(self, num_elements: int) -> None:
+        """
+        Insert new elements with default value to the attribute.
+
+        :param num_elements: Number of elements to insert.
+        """
+
+    @overload
+    def insert_elements(self, tensor: object) -> None:
+        """
+        Insert new elements to the attribute.
+
+        :param tensor: A tensor with shape (num_elements, num_channels) or (num_elements,).
+        """
+
+    def empty(self) -> bool:
+        """Return true if the attribute is empty."""
+
+    @property
+    def num_elements(self) -> int:
+        """Number of elements in the attribute."""
+
+    @property
+    def external(self) -> bool:
+        """Return true if the attribute wraps external buffer."""
+
+    @property
+    def readonly(self) -> bool:
+        """Return true if the attribute is read-only."""
+
+    @property
+    def data(self) -> object:
+        """Raw data buffer of the attribute."""
+
+    @data.setter
+    def data(self, arg: object, /) -> None: ...
+
+    @property
+    def dtype(self) -> type | None:
+        """Value type of the attribute."""
+
+class AttributeCopyPolicy(enum.Enum):
+    """Policy for copying attribute that is a view of an external buffer"""
+
+    CopyIfExternal = 0
+    """Copy attribute to internal buffer"""
+
+    KeepExternalPtr = 1
+    """Keep external buffer pointer"""
+
+    ErrorIfExternal = 2
+    """Error if external buffer is used"""
+
+class AttributeCreatePolicy(enum.Enum):
+    """Attribute creation policy"""
+
+    ErrorIfReserved = 0
+    """Default policy, error if attribute name is reserved"""
+
+    Force = 1
+    """Force create attribute even if name is reserved"""
+
+class AttributeDeletePolicy(enum.Enum):
+    """Policy for deleting attributes with reserved names"""
+
+    ErrorIfReserved = 0
+    """Disallow deletion (default)"""
+
+    Force = 1
+    """Force delete attribute"""
+
+class AttributeElement(enum.IntEnum):
+    """Attribute element type"""
+
+    Vertex = 1
+    """Per-vertex attribute"""
+
+    Facet = 2
+    """Per-facet attribute"""
+
+    Edge = 4
+    """Per-edge attribute"""
+
+    Corner = 8
+    """Per-corner attribute"""
+
+    Value = 16
+    """Value attribute not attached to any mesh elements"""
+
+    Indexed = 32
+    """Indexed attribute"""
+
+class AttributeExportPolicy(enum.Enum):
+    """Policy for exporting attribute that is a view of an external buffer"""
+
+    CopyIfExternal = 0
+    """Copy attribute to internal buffer"""
+
+    CopyIfUnmanaged = 1
+    """
+    Copy attribute to internal buffer if the external buffer is unmanaged (i.e. not reference counted)
+    """
+
+    KeepExternalPtr = 2
+    """Keep external buffer pointer"""
+
+    ErrorIfExternal = 3
+    """Error if external buffer is used"""
+
+class AttributeGrowthPolicy(enum.Enum):
+    """Attribute growth policy (for external buffers)"""
+
+    ErrorIfExtenal = 0
+    """Disallow growth if external buffer is used (default)"""
+
+    AllowWithinCapacity = 1
+    """
+    Allow growth as long as it is within the capacity of the external buffer
+    """
+
+    WarnAndCopy = 2
+    """
+    Warn and copy attribute to internal buffer when growth exceeds external buffer capacity
+    """
+
+    SilentCopy = 3
+    """
+    Silently copy attribute to internal buffer when growth exceeds external buffer capacity
+    """
+
+class AttributeShrinkPolicy(enum.Enum):
+    """Attribute shrink policy (for external buffers)"""
+
+    ErrorIfExternal = 0
+    """Disallow shrink if external buffer is used (default)"""
+
+    IgnoreIfExternal = 1
+    """Ignore shrink if external buffer is used"""
+
+    WarnAndCopy = 2
+    """
+    Warn and copy attribute to internal buffer when shrinking below external buffer capacity
+    """
+
+    SilentCopy = 3
+    """
+    Silently copy attribute to internal buffer when shrinking below external buffer capacity
+    """
+
+class AttributeUsage(enum.Enum):
+    """Attribute usage type"""
+
+    Vector = 1
+    """Vector attribute that may have any number of channels"""
+
+    Scalar = 2
+    """Scalar attribute that has exactly 1 channel"""
+
+    Position = 4
+    """Position attribute must have exactly dim channels"""
+
+    Normal = 8
+    """Normal attribute must have exactly dim channels"""
+
+    Tangent = 16
+    """Tangent attribute must have exactly dim channels"""
+
+    Bitangent = 32
+    """Bitangent attribute must have exactly dim channels"""
+
+    Color = 64
+    """Color attribute may have 1, 2, 3 or 4 channels"""
+
+    UV = 128
+    """UV attribute has exactly 2 channels"""
+
+    VertexIndex = 256
+    """Single channel integer attribute indexing mesh vertices"""
+
+    FacetIndex = 512
+    """Single channel integer attribute indexing mesh facets"""
+
+    CornerIndex = 1024
+    """Single channel integer attribute indexing mesh corners"""
+
+    EdgeIndex = 2048
+    """Single channel integer attribute indexing mesh edges"""
+
+class AttributeWritePolicy(enum.Enum):
+    """Policy for attempting to write to read-only external buffer"""
+
+    ErrorIfReadOnly = 0
+    """Disallow writing to read-only external buffer (default)"""
+
+    WarnAndCopy = 1
+    """
+    Warn and copy attribute to internal buffer when writing to read-only external buffer
+    """
+
+    SilentCopy = 2
+    """
+    Silently copy attribute to internal buffer when writing to read-only external buffer
+    """
+
+class CentroidWeightingType(enum.Enum):
+    """Centroid weighting type."""
+
+    Uniform = 0
+    """Uniform weighting."""
+
+    Area = 1
+    """Area weighting."""
+
+class ConnectivityType(enum.Enum):
+    """Mesh connectivity type"""
+
+    Vertex = 0
+    """Two facets are connected if they share a vertex"""
+
+    Edge = 1
+    """Two facets are connected if they share an edge"""
+
+class DistortionMetric(enum.Enum):
+    """Distortion metric."""
+
+    Dirichlet = 0
+    """Dirichlet energy"""
+
+    InverseDirichlet = 1
+    """Inverse Dirichlet energy"""
+
+    SymmetricDirichlet = 2
+    """Symmetric Dirichlet energy"""
+
+    AreaRatio = 3
+    """Area ratio"""
+
+    MIPS = 4
+    """Most isotropic parameterization energy"""
+
+class FacetAreaOptions:
+    """Options for computing facet area."""
+
+    def __init__(self) -> None: ...
+
+    @property
+    def output_attribute_name(self) -> str:
+        """The name of the output attribute."""
+
+    @output_attribute_name.setter
+    def output_attribute_name(self, arg: str, /) -> None: ...
+
+class FacetCentroidOptions:
+    """Facet centroid options."""
+
+    def __init__(self) -> None: ...
+
+    @property
+    def output_attribute_name(self) -> str:
+        """The name of the output attribute."""
+
+    @output_attribute_name.setter
+    def output_attribute_name(self, arg: str, /) -> None: ...
+
+class FacetNormalOptions:
+    """Facet normal computation options."""
+
+    def __init__(self) -> None: ...
+
+    @property
+    def output_attribute_name(self) -> str:
+        """Output attribute name. Default: '@facet_normal'"""
+
+    @output_attribute_name.setter
+    def output_attribute_name(self, arg: str, /) -> None: ...
+
+class IndexedAttribute:
+    @property
+    def element_type(self) -> AttributeElement: ...
+
+    @property
+    def usage(self) -> AttributeUsage: ...
+
+    @property
+    def num_channels(self) -> int: ...
+
+    @property
+    def values(self) -> Attribute: ...
+
+    @property
+    def indices(self) -> Attribute: ...
+
+class MappingPolicy(enum.Enum):
+    """Mapping policy for handling collisions."""
+
+    Average = 0
+    """Compute the average of the collided values."""
+
+    KeepFirst = 1
+    """Keep the first collided value."""
+
+    Error = 2
+    """Throw an error when collision happens."""
+
+class MeshAreaOptions:
+    """Options for computing mesh area."""
+
+    def __init__(self) -> None: ...
+
+    @property
+    def input_attribute_name(self) -> str:
+        """
+        The name of the pre-computed facet area attribute, default is '@facet_area'.
+        """
+
+    @input_attribute_name.setter
+    def input_attribute_name(self, arg: str, /) -> None: ...
+
+    @property
+    def use_signed_area(self) -> bool:
+        """Whether to use signed area."""
+
+    @use_signed_area.setter
+    def use_signed_area(self, arg: bool, /) -> None: ...
+
+class MeshCentroidOptions:
+    """Mesh centroid options."""
+
+    def __init__(self) -> None: ...
+
+    @property
+    def weighting_type(self) -> CentroidWeightingType:
+        """The weighting type."""
+
+    @weighting_type.setter
+    def weighting_type(self, arg: CentroidWeightingType, /) -> None: ...
+
+    @property
+    def facet_centroid_attribute_name(self) -> str:
+        """The name of the pre-computed facet centroid attribute if available."""
+
+    @facet_centroid_attribute_name.setter
+    def facet_centroid_attribute_name(self, arg: str, /) -> None: ...
+
+    @property
+    def facet_area_attribute_name(self) -> str:
+        """The name of the pre-computed facet area attribute if available."""
+
+    @facet_area_attribute_name.setter
+    def facet_area_attribute_name(self, arg: str, /) -> None: ...
+
+class NormalOptions:
+    """Normal computation options."""
+
+    def __init__(self) -> None: ...
+
+    @property
+    def output_attribute_name(self) -> str:
+        """Output attribute name. Default: '@normal'"""
+
+    @output_attribute_name.setter
+    def output_attribute_name(self, arg: str, /) -> None: ...
+
+    @property
+    def weight_type(self) -> NormalWeightingType:
+        """Weighting type for normal computation. Default is Angle."""
+
+    @weight_type.setter
+    def weight_type(self, arg: NormalWeightingType, /) -> None: ...
+
+    @property
+    def facet_normal_attribute_name(self) -> str:
+        """Facet normal attribute name to use. Default is '@facet_normal'."""
+
+    @facet_normal_attribute_name.setter
+    def facet_normal_attribute_name(self, arg: str, /) -> None: ...
+
+    @property
+    def recompute_facet_normals(self) -> bool:
+        """Whether to recompute facet normals. Default is false."""
+
+    @recompute_facet_normals.setter
+    def recompute_facet_normals(self, arg: bool, /) -> None: ...
+
+    @property
+    def keep_facet_normals(self) -> bool:
+        """Whether to keep the computed facet normal attribute. Default is false."""
+
+    @keep_facet_normals.setter
+    def keep_facet_normals(self, arg: bool, /) -> None: ...
+
+class NormalWeightingType(enum.Enum):
+    """Normal weighting type."""
+
+    Uniform = 0
+    """Uniform weighting"""
+
+    CornerTriangleArea = 1
+    """Weight by corner triangle area"""
+
+    Angle = 2
+    """Weight by corner angle"""
+
+class RemapVerticesOptions:
+    """Options for remapping vertices."""
+
+    def __init__(self) -> None: ...
+
+    @property
+    def collision_policy_float(self) -> MappingPolicy:
+        """The collision policy for float attributes."""
+
+    @collision_policy_float.setter
+    def collision_policy_float(self, arg: MappingPolicy, /) -> None: ...
+
+    @property
+    def collision_policy_integral(self) -> MappingPolicy:
+        """The collision policy for integral attributes."""
+
+    @collision_policy_integral.setter
+    def collision_policy_integral(self, arg: MappingPolicy, /) -> None: ...
+
+class SurfaceMesh:
+    def __init__(self, dimension: int = 3) -> None: ...
+
+    @overload
+    def add_vertex(self, vertex: Annotated[ArrayLike, dict(dtype='float64', order='C', device='cpu')]) -> None:
+        """
+        Add a vertex to the mesh.
+
+        :param vertex: vertex coordinates
+        :type vertex: numpy.ndarray or list
+        """
+
+    @overload
+    def add_vertex(self, arg: list, /) -> None: ...
+
+    def add_vertices(self, arg: Annotated[ArrayLike, dict(dtype='float64', order='C', device='cpu')], /) -> None: ...
+
+    def add_triangle(self, arg0: int, arg1: int, arg2: int, /) -> None: ...
+
+    def add_triangles(self, arg: Annotated[ArrayLike, dict(dtype='uint32', order='C', device='cpu')], /) -> None: ...
+
+    def add_quad(self, arg0: int, arg1: int, arg2: int, arg3: int, /) -> None: ...
+
+    def add_quads(self, arg: Annotated[ArrayLike, dict(dtype='uint32', order='C', device='cpu')], /) -> None: ...
+
+    def add_polygon(self, arg: Annotated[ArrayLike, dict(dtype='uint32', order='C', device='cpu')], /) -> None: ...
+
+    def add_polygons(self, arg: Annotated[ArrayLike, dict(dtype='uint32', order='C', device='cpu')], /) -> None: ...
+
+    def add_hybrid(self, arg0: Annotated[ArrayLike, dict(dtype='uint32', order='C', device='cpu')], arg1: Annotated[ArrayLike, dict(dtype='uint32', order='C', device='cpu')], /) -> None: ...
+
+    @overload
+    def remove_vertices(self, arg: Annotated[ArrayLike, dict(dtype='uint32', order='C', device='cpu')], /) -> None: ...
+
+    @overload
+    def remove_vertices(self, vertices: list) -> None:
+        """
+        Remove selected vertices from the mesh.
+
+        :param vertices: list of vertex indices to remove
+        """
+
+    @overload
+    def remove_facets(self, arg: Annotated[ArrayLike, dict(dtype='uint32', order='C', device='cpu')], /) -> None: ...
+
+    @overload
+    def remove_facets(self, facets: list) -> None:
+        """
+        Remove selected facets from the mesh.
+
+        :param facets: list of facet indices to remove
+        """
+
+    def clear_vertices(self) -> None: ...
+
+    def clear_facets(self) -> None: ...
+
+    def shrink_to_fit(self) -> None: ...
+
+    def compress_if_regular(self) -> None: ...
+
+    @property
+    def is_triangle_mesh(self) -> bool: ...
+
+    @property
+    def is_quad_mesh(self) -> bool: ...
+
+    @property
+    def is_regular(self) -> bool: ...
+
+    @property
+    def is_hybrid(self) -> bool: ...
+
+    @property
+    def dimension(self) -> int: ...
+
+    @property
+    def vertex_per_facet(self) -> int: ...
+
+    @property
+    def num_vertices(self) -> int: ...
+
+    @property
+    def num_facets(self) -> int: ...
+
+    @property
+    def num_corners(self) -> int: ...
+
+    @property
+    def num_edges(self) -> int: ...
+
+    def get_position(self, arg: int, /) -> Annotated[ArrayLike, dict(dtype='float64', order='C', device='cpu')]: ...
+
+    def ref_position(self, arg: int, /) -> Annotated[ArrayLike, dict(dtype='float64', order='C', device='cpu')]: ...
+
+    def get_facet_size(self, arg: int, /) -> int: ...
+
+    def get_facet_vertex(self, arg0: int, arg1: int, /) -> int: ...
+
+    def get_facet_corner_begin(self, arg: int, /) -> int: ...
+
+    def get_facet_corner_end(self, arg: int, /) -> int: ...
+
+    def get_corner_vertex(self, arg: int, /) -> int: ...
+
+    def get_corner_facet(self, arg: int, /) -> int: ...
+
+    def get_facet_vertices(self, arg: int, /) -> Annotated[ArrayLike, dict(dtype='uint32', order='C', device='cpu')]: ...
+
+    def ref_facet_vertices(self, arg: int, /) -> Annotated[ArrayLike, dict(dtype='uint32', order='C', device='cpu')]: ...
+
+    def get_attribute_id(self, arg: str, /) -> int: ...
+
+    def get_attribute_name(self, arg: int, /) -> str: ...
+
+    def create_attribute(self, name: str, element: AttributeElement | None = None, usage: AttributeUsage | None = None, initial_values: Annotated[ArrayLike, dict(order='C', device='cpu')] | list | None = None, initial_indices: Annotated[ArrayLike, dict(dtype='uint32', order='C', device='cpu')] | Annotated[ArrayLike, dict(order='C', device='cpu')] | list | None = None, num_channels: int | None = None, dtype: type | None = None) -> int:
+        """
+        Create an attribute.
+
+        :param name: Name of the attribute.
+        :type name: str
+        :param element: Element type of the attribute. If None, derive from the shape of initial values.
+        :type element: AttributeElement, optional
+        :param usage: Usage type of the attribute. If None, derive from the shape of initial values or the number of channels.
+        :type usage: AttributeUsage, optional
+        :param initial_values: Initial values of the attribute.
+        :type initial_values: numpy.ndarray, optional
+        :param initial_indices: Initial indices of the attribute (Indexed attribute only).
+        :type initial_indices: numpy.ndarray, optional
+        :param num_channels: Number of channels of the attribute.
+        :type num_channels: int, optional
+        :param dtype: Data type of the attribute.
+        :type dtype: valid numpy.dtype, optional
+
+        .. note::
+           If `element` is None, it will be derived based on the cardinality of the mesh elements.
+           If there is an ambiguity, an exception will be raised.
+           In addition, explicit `element` specification is required for value attributes.
+
+        .. note::
+           If `usage` is None, it will be derived based on the shape of `initial_values` or `num_channels` if specified.
+
+        :returns: The id of the created attribute.
+        """
+
+    def create_attribute_from(self, name: str, source_mesh: SurfaceMesh, source_name: str = '') -> int:
+        """
+        Shallow copy an attribute from another mesh.
+
+        :param name: Name of the attribute.
+        :type name: str
+        :param source_mesh: Source mesh.
+        :type source_mesh: SurfaceMesh
+        :param source_name: Name of the attribute in the source mesh. If empty, use the same name as `name`.
+        :type source_name: str, optional
+
+        :returns: The id of the created attribute.
+        """
+
+    def wrap_as_attribute(self, name: str, element: AttributeElement, usage: AttributeUsage, values: Annotated[ArrayLike, dict(order='C', device='cpu')]) -> int:
+        """
+        Wrap an existing numpy array as an attribute.
+
+        :param name: Name of the attribute.
+        :type name: str
+        :param element: Element type of the attribute.
+        :type element: AttributeElement
+        :param usage: Usage type of the attribute.
+        :type usage: AttributeUsage
+        :param values: Values of the attribute.
+        :type values: numpy.ndarray
+
+        :returns: The id of the created attribute.
+        """
+
+    def wrap_as_indexed_attribute(self, name: str, usage: AttributeUsage, values: Annotated[ArrayLike, dict(order='C', device='cpu')], indices: Annotated[ArrayLike, dict(dtype='uint32', order='C', device='cpu')]) -> int:
+        """
+        Wrap an existing numpy array as an indexed attribute.
+
+        :param name: Name of the attribute.
+        :type name: str
+        :param usage: Usage type of the attribute.
+        :type usage: AttributeUsage
+        :param values: Values of the attribute.
+        :type values: numpy.ndarray
+        :param indices: Indices of the attribute.
+        :type indices: numpy.ndarray
+
+        :returns: The id of the created attribute.
+        """
+
+    def duplicate_attribute(self, arg0: str, arg1: str, /) -> int: ...
+
+    def rename_attribute(self, arg0: str, arg1: str, /) -> None: ...
+
+    @overload
+    def delete_attribute(self, name: str, policy: AttributeDeletePolicy) -> None: ...
+
+    @overload
+    def delete_attribute(self, name: str) -> None:
+        """
+        Delete an attribute by name.
+
+        :param name: Name of the attribute.
+        :type name: str
+        """
+
+    @overload
+    def delete_attribute(self, id: int) -> None:
+        """
+        Delete an attribute by id.
+
+        :param id: Id of the attribute.
+        :type id: AttributeId
+        """
+
+    def has_attribute(self, arg: str, /) -> bool: ...
+
+    @overload
+    def is_attribute_indexed(self, arg: int, /) -> bool: ...
+
+    @overload
+    def is_attribute_indexed(self, arg: str, /) -> bool: ...
+
+    @overload
+    def attribute(self, id: int, sharing: bool = True) -> Attribute:
+        """
+        Get an attribute by id.
+
+        :param id: Id of the attribute.
+        :type id: AttributeId
+        :param sharing: Whether to allow sharing the attribute with other meshes.
+        :type sharing: bool
+
+        :returns: The attribute.
+        """
+
+    @overload
+    def attribute(self, name: str, sharing: bool = True) -> Attribute:
+        """
+        Get an attribute by name.
+
+        :param name: Name of the attribute.
+        :type name: str
+        :param sharing: Whether to allow sharing the attribute with other meshes.
+        :type sharing: bool
+
+        :return: The attribute.
+        """
+
+    @overload
+    def indexed_attribute(self, id: int, sharing: bool = True) -> IndexedAttribute:
+        """
+        Get an indexed attribute by id.
+
+        :param id: Id of the attribute.
+        :type id: AttributeId
+        :param sharing: Whether to allow sharing the attribute with other meshes.
+        :type sharing: bool
+
+        :returns: The indexed attribute.
+        """
+
+    @overload
+    def indexed_attribute(self, name: str, sharing: bool = True) -> IndexedAttribute:
+        """
+        Get an indexed attribute by name.
+
+        :param name: Name of the attribute.
+        :type name: str
+        :param sharing: Whether to allow sharing the attribute with other meshes.
+        :type sharing: bool
+
+        :returns: The indexed attribute.
+        """
+
+    def __attribute_ref_count__(self, arg: int, /) -> int: ...
+
+    @property
+    def vertices(self) -> Annotated[ArrayLike, dict(dtype='float64', order='C', device='cpu')]:
+        """Vertices of the mesh."""
+
+    @vertices.setter
+    def vertices(self, arg: Annotated[ArrayLike, dict(dtype='float64', order='C', device='cpu')], /) -> None: ...
+
+    @property
+    def facets(self) -> Annotated[ArrayLike, dict(dtype='uint32', order='C', device='cpu')]:
+        """Facets of the mesh."""
+
+    @facets.setter
+    def facets(self, arg: Annotated[ArrayLike, dict(dtype='uint32', order='C', device='cpu')], /) -> None: ...
+
+    def wrap_as_vertices(self, tensor: Annotated[ArrayLike, dict(dtype='float64', order='C', device='cpu')], num_vertices: int) -> int:
+        """
+        Wrap a tensor as vertices.
+
+        :param tensor: The tensor to wrap.
+        :type tensor: numpy.ndarray
+        :param num_vertices: Number of vertices.
+        :type num_vertices: int
+
+        :return: The id of the wrapped vertices attribute.
+        """
+
+    @overload
+    def wrap_as_facets(self, tensor: Annotated[ArrayLike, dict(dtype='uint32', order='C', device='cpu')], num_facets: int, vertex_per_facet: int) -> int:
+        """
+        Wrap a tensor as a list of regular facets.
+
+        :param tensor: The tensor to wrap.
+        :type tensor: numpy.ndarray
+        :param num_facets: Number of facets.
+        :type num_facets: int
+        :param vertex_per_facet: Number of vertices per facet.
+        :type vertex_per_facet: int
+
+        :return: The id of the wrapped facet attribute.
+        """
+
+    @overload
+    def wrap_as_facets(self, offsets: Annotated[ArrayLike, dict(dtype='uint32', order='C', device='cpu')], num_facets: int, facets: Annotated[ArrayLike, dict(dtype='uint32', order='C', device='cpu')], num_corners: int) -> int:
+        """
+        Wrap a tensor as a list of hybrid facets.
+
+        :param offsets: The offset indices into the facets array.
+        :type offsets: numpy.ndarray
+        :param num_facets: Number of facets.
+        :type num_facets: int
+        :param facets: The indices of the vertices of the facets.
+        :type facets: numpy.ndarray
+        :param num_corners: Number of corners.
+        :type num_corners: int
+
+        :return: The id of the wrapped facet attribute.
+        """
+
+    @staticmethod
+    def attr_name_is_reserved(arg: str, /) -> bool: ...
+
+    attr_name_vertex_to_position: str = ...
+    """The name of the attribute that stores the vertex positions."""
+
+    attr_name_corner_to_vertex: str = ...
+    """The name of the attribute that stores the corner to vertex mapping."""
+
+    attr_name_facet_to_first_corner: str = ...
+    """
+    The name of the attribute that stores the facet to first corner mapping.
+    """
+
+    attr_name_corner_to_facet: str = ...
+    """The name of the attribute that stores the corner to facet mapping."""
+
+    attr_name_corner_to_edge: str = ...
+    """The name of the attribute that stores the corner to edge mapping."""
+
+    attr_name_edge_to_first_corner: str = ...
+    """
+    The name of the attribute that stores the edge to first corner mapping.
+    """
+
+    attr_name_next_corner_around_edge: str = ...
+    """
+    The name of the attribute that stores the next corner around edge mapping.
+    """
+
+    attr_name_vertex_to_first_corner: str = ...
+    """
+    The name of the attribute that stores the vertex to first corner mapping.
+    """
+
+    attr_name_next_corner_around_vertex: str = ...
+    """
+    The name of the attribute that stores the next corner around vertex mapping.
+    """
+
+    @property
+    def attr_id_vertex_to_position(self) -> int: ...
+
+    @property
+    def attr_id_corner_to_vertex(self) -> int: ...
+
+    @property
+    def attr_id_facet_to_first_corner(self) -> int: ...
+
+    @property
+    def attr_id_corner_to_facet(self) -> int: ...
+
+    @property
+    def attr_id_corner_to_edge(self) -> int: ...
+
+    @property
+    def attr_id_edge_to_first_corner(self) -> int: ...
+
+    @property
+    def attr_id_next_corner_around_edge(self) -> int: ...
+
+    @property
+    def attr_id_vertex_to_first_corner(self) -> int: ...
+
+    @property
+    def attr_id_next_corner_around_vertex(self) -> int: ...
+
+    def initialize_edges(self, edges: Annotated[ArrayLike, dict(dtype='uint32', order='C', device='cpu')] | None = None) -> None:
+        """
+        Initialize the edges.
+
+        The `edges` tensor provides a predefined ordering of the edges.
+        If not provided, the edges are initialized in an arbitrary order.
+
+        :param edges: M x 2 tensor of predefined edge vertex indices, where M is the number of edges.
+        :type edges: numpy.ndarray, optional
+        """
+
+    def clear_edges(self) -> None: ...
+
+    @property
+    def has_edges(self) -> bool: ...
+
+    def get_edge(self, arg0: int, arg1: int, /) -> int: ...
+
+    def get_corner_edge(self, arg: int, /) -> int: ...
+
+    def get_edge_vertices(self, arg: int, /) -> list[int]: ...
+
+    def find_edge_from_vertices(self, arg0: int, arg1: int, /) -> int: ...
+
+    def get_first_corner_around_edge(self, arg: int, /) -> int: ...
+
+    def get_next_corner_around_edge(self, arg: int, /) -> int: ...
+
+    def get_first_corner_around_vertex(self, arg: int, /) -> int: ...
+
+    def get_next_corner_around_vertex(self, arg: int, /) -> int: ...
+
+    def count_num_corners_around_edge(self, arg: int, /) -> int: ...
+
+    def count_num_corners_around_vertex(self, arg: int, /) -> int: ...
+
+    def get_one_facet_around_edge(self, arg: int, /) -> int: ...
+
+    def get_one_corner_around_edge(self, arg: int, /) -> int: ...
+
+    def get_one_corner_around_vertex(self, arg: int, /) -> int: ...
+
+    def is_boundary_edge(self, arg: int, /) -> bool: ...
+
+    def get_matching_attribute_ids(self, element: AttributeElement | None = None, usage: AttributeUsage | None = None, num_channels: int = 0) -> list[int]:
+        """
+        Get all matching attribute ids with the desired element type, usage and number of channels.
+
+        :param element:       The target element type. None matches all element types.
+        :param usage:         The target usage type.  None matches all usage types.
+        :param num_channels:  The target number of channels. 0 matches arbitrary number of channels.
+
+        :returns: A list of attribute ids matching the target element, usage and number of channels.
+        """
+
+    def __copy__(self) -> SurfaceMesh:
+        """Create a shallow copy of this mesh."""
+
+    def __deepcopy__(self, memo: dict | None = None) -> SurfaceMesh:
+        """Create a deep copy of this mesh."""
+
+    def clone(self) -> object:
+        """Create a deep copy of this mesh."""
+
+class TangentBitangentOptions:
+    """Tangent bitangent options"""
+
+    def __init__(self) -> None: ...
+
+    @property
+    def tangent_attribute_name(self) -> str:
+        """The name of the output tangent attribute, default is '@tangent'"""
+
+    @tangent_attribute_name.setter
+    def tangent_attribute_name(self, arg: str, /) -> None: ...
+
+    @property
+    def bitangent_attribute_name(self) -> str:
+        """The name of the output bitangent attribute, default is '@bitangent'"""
+
+    @bitangent_attribute_name.setter
+    def bitangent_attribute_name(self, arg: str, /) -> None: ...
+
+    @property
+    def uv_attribute_name(self) -> str:
+        """The name of the uv attribute"""
+
+    @uv_attribute_name.setter
+    def uv_attribute_name(self, arg: str, /) -> None: ...
+
+    @property
+    def normal_attribute_name(self) -> str:
+        """The name of the normal attribute"""
+
+    @normal_attribute_name.setter
+    def normal_attribute_name(self, arg: str, /) -> None: ...
+
+    @property
+    def output_element_type(self) -> AttributeElement:
+        """The output element type"""
+
+    @output_element_type.setter
+    def output_element_type(self, arg: AttributeElement, /) -> None: ...
+
+    @property
+    def pad_with_sign(self) -> bool:
+        """Whether to pad the output tangent/bitangent with sign"""
+
+    @pad_with_sign.setter
+    def pad_with_sign(self, arg: bool, /) -> None: ...
+
+class TangentBitangentResult:
+    """Tangent bitangent result"""
+
+    def __init__(self) -> None: ...
+
+    @property
+    def tangent_id(self) -> int:
+        """The output tangent attribute id"""
+
+    @tangent_id.setter
+    def tangent_id(self, arg: int, /) -> None: ...
+
+    @property
+    def bitangent_id(self) -> int:
+        """The output bitangent attribute id"""
+
+    @bitangent_id.setter
+    def bitangent_id(self, arg: int, /) -> None: ...
+
+class VertexNormalOptions:
+    """Options for computing vertex normals"""
+
+    def __init__(self) -> None: ...
+
+    @property
+    def output_attribute_name(self) -> str:
+        """Output attribute name. Default is '@vertex_normal'."""
+
+    @output_attribute_name.setter
+    def output_attribute_name(self, arg: str, /) -> None: ...
+
+    @property
+    def weight_type(self) -> NormalWeightingType:
+        """Weighting type for normal computation. Default is Angle."""
+
+    @weight_type.setter
+    def weight_type(self, arg: NormalWeightingType, /) -> None: ...
+
+    @property
+    def weighted_corner_normal_attribute_name(self) -> str:
+        """
+        Precomputed weighted corner normals attribute name.Default is '@weighted_corner_normal'. If attribute exists, the weighted corner normals will be used instead of recomputing them.
+        """
+
+    @weighted_corner_normal_attribute_name.setter
+    def weighted_corner_normal_attribute_name(self, arg: str, /) -> None: ...
+
+    @property
+    def recompute_weighted_corner_normals(self) -> bool:
+        """Whether to recompute weighted corner normals. Default is false"""
+
+    @recompute_weighted_corner_normals.setter
+    def recompute_weighted_corner_normals(self, arg: bool, /) -> None: ...
+
+    @property
+    def keep_weighted_corner_normals(self) -> bool:
+        """
+        Whether to keep the weighted corner normal attribute. Default is false.
+        """
+
+    @keep_weighted_corner_normals.setter
+    def keep_weighted_corner_normals(self, arg: bool, /) -> None: ...
+
+class VertexValenceOptions:
+    """Vertex valence options"""
+
+    def __init__(self) -> None: ...
+
+    @property
+    def output_attribute_name(self) -> str:
+        """The name of the output attribute"""
+
+    @output_attribute_name.setter
+    def output_attribute_name(self, arg: str, /) -> None: ...
+
+def cast_attribute(mesh: SurfaceMesh, input_attribute: int | str, dtype: type, output_attribute_name: str | None = None) -> int:
+    """
+    Cast an attribute to a new dtype.
+
+    :param mesh:            The input mesh.
+    :param input_attribute: The input attribute id or name.
+    :param dtype:           The new dtype.
+    :param output_attribute_name: The output attribute name. If none, cast will replace the input attribute.
+
+    :returns: The id of the new attribute.
+    """
+
+def combine_meshes(meshes: Sequence[SurfaceMesh], preserve_attributes: bool = True) -> SurfaceMesh:
+    """
+    Combine a list of meshes into a single mesh.
+
+    :param meshes: input meshes
+    :type meshes: list[SurfaceMesh]
+    :param preserve_attributes: whether to preserve attributes
+    :type preserve_attributes: bool
+
+    :returns: the combined mesh
+    """
+
+def compute_components(mesh: SurfaceMesh, output_attribute_name: str | None = None, connectivity_type: ConnectivityType | None = None, blocker_elements: list | None = None) -> int:
+    """
+    Compute connected components.
+
+    This method will create a per-facet component id attribute named by the `output_attribute_name`
+    argument. Each component id is in [0, num_components-1] range.
+
+    :param mesh: The input mesh.
+    :param output_attribute_name: The name of the output attribute.
+    :param connectivity_type: The connectivity type.  Either "Vertex" or "Edge".
+    :param blocker_elements: The list of blocker element indices. If `connectivity_type` is `Edge`, facets adjacent to a blocker edge are not considered as connected through this edge. If `connectivity_type` is `Vertex`, facets sharing a blocker vertex are not considered as connected through this vertex.
+
+    :returns: The total number of components.
+    """
+
+def compute_dihedral_angles(mesh: SurfaceMesh, output_attribute_name: str | None = None, facet_normal_attribute_name: str | None = None, recompute_facet_normals: bool | None = None, keep_facet_normals: bool | None = None) -> int:
+    """
+    Compute dihedral angles for each edge.
+
+    The dihedral angle of an edge is defined as the angle between the __normals__ of two facets adjacent
+    to the edge. The dihedral angle is always in the range [0, pi] for manifold edges. For boundary
+    edges, the dihedral angle defaults to 0.  For non-manifold edges, the dihedral angle is not
+    well-defined and will be set to the special value 2 * M_PI.
+
+    :param mesh:                        The source mesh.
+    :param output_attribute_name:       The optional edge attribute name to store the dihedral angles.
+    :param facet_normal_attribute_name: The optional attribute name to store the facet normals.
+    :param recompute_facet_normals:     Whether to recompute facet normals.
+    :param keep_facet_normals:          Whether to keep newly computed facet normals. It has no effect on pre-existing facet normals.
+
+    :return: The edge attribute id of dihedral angles.
+    """
+
+def compute_dijkstra_distance(mesh: SurfaceMesh, seed_facet: int, barycentric_coords: list, radius: float | None = None, output_attribute_name: str = '@dijkstra_distance', output_involved_vertices: bool = False) -> list[int] | None:
+    """
+    Compute Dijkstra distance from a seed facet.
+
+    :param mesh:                  The source mesh.
+    :param seed_facet:            The seed facet index.
+    :param barycentric_coords:    The barycentric coordinates of the seed facet.
+    :param radius:                The maximum radius of the dijkstra distance.
+    :param output_attribute_name: The output attribute name to store the dijkstra distance.
+    :param output_involved_vertices: Whether to output the list of involved vertices.
+    """
+
+def compute_edge_lengths(mesh: SurfaceMesh, output_attribute_name: str | None = None) -> int:
+    """
+    Compute edge lengths.
+
+    :param mesh:                  The source mesh.
+    :param output_attribute_name: The optional edge attribute name to store the edge lengths.
+
+    :return: The edge attribute id of edge lengths.
+    """
+
+def compute_euler(mesh: SurfaceMesh) -> int:
+    """
+    Compute the Euler characteristic.
+
+    :param mesh: The source mesh.
+
+    :return: The Euler characteristic.
+    """
+
+@overload
+def compute_facet_area(mesh: SurfaceMesh, options: FacetAreaOptions = ...) -> int:
+    """
+    Compute facet area.
+
+    :param mesh: The input mesh.
+    :param options: The options for computing facet area.
+
+    :returns: The id of the new attribute.
+    """
+
+@overload
+def compute_facet_area(mesh: SurfaceMesh, output_attribute_name: str | None = None) -> int:
+    """
+    Compute facet area (Pythonic API).
+
+    :param mesh: The input mesh.
+    :param output_attribute_name: The name of the output attribute.
+
+    :returns: The id of the new attribute.
+    """
+
+@overload
+def compute_facet_centroid(mesh: SurfaceMesh, options: FacetCentroidOptions = ...) -> int:
+    """
+    Compute facet centroid.
+
+    :param mesh: The input mesh.
+    :param options: The options for computing facet centroid.
+
+    :returns: The id of the new attribute.
+    """
+
+@overload
+def compute_facet_centroid(mesh: SurfaceMesh, output_attribute_name: str | None = None) -> int:
+    """
+    Compute facet centroid (Pythonic API).
+
+    :param mesh: The input mesh.
+    :param output_attribute_name: The name of the output attribute.
+
+    :returns: The id of the new attribute.
+    """
+
+@overload
+def compute_facet_normal(mesh: SurfaceMesh, options: FacetNormalOptions = ...) -> int:
+    """
+    Compute facet normal.
+
+    :param mesh: Input mesh.
+    :param options: Options for computing facet normals.
+
+    :returns: Facet normal attribute id.
+    """
+
+@overload
+def compute_facet_normal(mesh: SurfaceMesh, output_attribute_name: str | None = None) -> int:
+    """
+    Compute facet normal (Pythonic API).
+
+    :param mesh: Input mesh.
+    :param output_attribute_name: Output attribute name.
+
+    :returns: Facet normal attribute id.
+    """
+
+def compute_greedy_coloring(mesh: SurfaceMesh, element_type: AttributeElement = AttributeElement.Facet, num_color_used: int = 8, output_attribute_name: str | None = None) -> int:
+    """
+    Compute greedy coloring of mesh elements.
+
+    :param mesh: Input mesh.
+    :param element_type: Element type to be colored. Can be either Vertex or Facet.
+    :param num_color_used: Minimum number of colors to use. The algorithm will cycle through them but may use more.
+    :param output_attribute_name: Output attribute name.
+
+    :returns: Color attribute id.
+    """
+
+@overload
+def compute_mesh_area(mesh: SurfaceMesh, options: MeshAreaOptions = ...) -> float:
+    """
+    Compute mesh area.
+
+    :param mesh: The input mesh.
+    :param options: The options for computing mesh area.
+
+    :returns: The mesh area.
+    """
+
+@overload
+def compute_mesh_area(mesh: SurfaceMesh, input_attribute_name: str | None = None, use_signed_area: bool | None = None) -> float:
+    """
+    Compute mesh area (Pythonic API).
+
+    :param mesh: The input mesh.
+    :param input_attribute_name: The name of the pre-computed facet area attribute.
+    :param use_signed_area: Whether to use signed area.
+
+    :returns: The mesh area.
+    """
+
+@overload
+def compute_mesh_centroid(mesh: SurfaceMesh, options: MeshCentroidOptions = ...) -> list[float]:
+    """
+    Compute mesh centroid.
+
+    :param mesh: The input mesh.
+    :param options: The options for computing mesh centroid.
+
+    :returns: The mesh centroid.
+    """
+
+@overload
+def compute_mesh_centroid(mesh: SurfaceMesh, weighting_type: CentroidWeightingType | None = None, facet_centroid_attribute_name: str | None = None, facet_area_attribute_name: str | None = None) -> list[float]:
+    """
+    Compute mesh centroid (Pythonic API).
+
+    :param mesh: The input mesh.
+    :param weighting_type: The weighting type. Default is `Area`.
+    :param facet_centroid_attribute_name: The name of the pre-computed facet centroid attribute if available. Default is '@facet_centroid'.
+    :param facet_area_attribute_name: The name of the pre-computed facet area attribute if available. Default is '@facet_area'.
+
+    :returns: The mesh centroid.
+    """
+
+@overload
+def compute_normal(mesh: SurfaceMesh, feature_angle_threshold: float = 0.7853981633974483, cone_vertices: object | None = None, options: NormalOptions | None = None) -> int:
+    """
+    Compute indexed normal attribute.
+
+    Edge with dihedral angles larger than `feature_angle_threshold` are considered as sharp edges.
+    Vertices listed in `cone_vertices` are considered as cone vertices, which is always sharp.
+
+    :param mesh: input mesh
+    :type mesh: SurfaceMesh
+    :param feature_angle_threshold: feature angle threshold
+    :type feature_angle_threshold: float, optional
+    :param cone_vertices: cone vertices
+    :type cone_vertices: list[int] or numpy.ndarray, optional
+    :param options: normal options
+    :type optional: NormalOptions, optional
+
+    :returns: the id of the indexed normal attribute.
+    """
+
+@overload
+def compute_normal(mesh: SurfaceMesh, feature_angle_threshold: float = 0.7853981633974483, cone_vertices: object | None = None, output_attribute_name: str | None = None, weight_type: NormalWeightingType | None = None, facet_normal_attribute_name: str | None = None, recompute_facet_normals: bool | None = None, keep_facet_normals: bool | None = None) -> int:
+    """
+    Compute indexed normal attribute (Pythonic API).
+
+    :param mesh: input mesh
+    :type mesh: SurfaceMesh
+    :param feature_angle_threshold: feature angle threshold
+    :type feature_angle_threshold: float, optional
+    :param cone_vertices: cone vertices
+    :type cone_vertices: list[int] or numpy.ndarray, optional
+    :param output_attribute_name: output normal attribute name
+    :type output_attribute_name: str, optional
+    :param weight_type: normal weighting type
+    :type weight_type: NormalWeightingType, optional
+    :param facet_normal_attribute_name: facet normal attribute name
+    :type facet_normal_attribute_name: str, optional
+    :param recompute_facet_normals: whether to recompute facet normals
+    :type recompute_facet_normals: bool, optional
+    :param keep_facet_normals: whether to keep the computed facet normal attribute
+    :type keep_facet_normals: bool, optional
+
+    :returns: the id of the indexed normal attribute.
+    """
+
+def compute_seam_edges(mesh: SurfaceMesh, indexed_attribute_id: int, output_attribute_name: str | None = None) -> int:
+    """
+    Computer seam edges for a given indexed attribute.
+
+    :param mesh: Input mesh.
+    :param indexed_attribute_id: Input indexed attribute id.
+    :param output_attribute_name: Output attribute name.
+
+    :returns: Attribute id for the output per-edge seam attribute (1 is a seam, 0 is not).
+    """
+
+@overload
+def compute_tangent_bitangent(mesh: SurfaceMesh, options: TangentBitangentOptions = ...) -> TangentBitangentResult:
+    """
+    Compute tangent and bitangent vector attributes.
+
+    :param mesh: The input mesh.
+    :param options: The tangent bitangent options.
+
+    :returns: The tangent and bitangent attribute ids
+    """
+
+@overload
+def compute_tangent_bitangent(mesh: SurfaceMesh, tangent_attribute_name: str | None = None, bitangent_attribute_name: str | None = None, uv_attribute_name: str | None = None, normal_attribute_name: str | None = None, output_attribute_type: AttributeElement | None = None, pad_with_sign: bool | None = None) -> tuple[int, int]:
+    """
+    Compute tangent and bitangent vector attributes (Pythonic API).
+
+    :param mesh: The input mesh.
+    :param tangent_attribute_name: The name of the output tangent attribute.
+    :param bitangent_attribute_name: The name of the output bitangent attribute.
+    :param uv_attribute_name: The name of the uv attribute.
+    :param normal_attribute_name: The name of the normal attribute.
+    :param output_attribute_type: The output element type.
+    :param pad_with_sign: Whether to pad the output tangent/bitangent with sign.
+
+    :returns: The tangent and bitangent attribute ids
+    """
+
+def compute_uv_distortion(mesh: SurfaceMesh, uv_attribute_name: str = '@uv', output_attribute_name: str = '@uv_measure', metric: DistortionMetric = DistortionMetric.MIPS) -> int:
+    """
+    Compute UV distortion.
+
+    :param mesh:                  The source mesh.
+    :param uv_attribute_name:     The input UV attribute name. Default is "@uv".
+    :param output_attribute_name: The output attribute name to store the distortion. Default is "@uv_measure".
+    :param metric:                The distortion metric. Default is MIPS.
+
+    :return: The facet attribute id for distortion.
+    """
+
+@overload
+def compute_vertex_normal(mesh: SurfaceMesh, options: VertexNormalOptions = ...) -> int:
+    """
+    Computer vertex normal.
+
+    :param mesh: Input mesh.
+    :param options: Options for computing vertex normals.
+
+    :returns: Vertex normal attribute id.
+    """
+
+@overload
+def compute_vertex_normal(mesh: SurfaceMesh, output_attribute_name: str | None = None, weight_type: NormalWeightingType | None = None, weighted_corner_normal_attribute_name: str | None = None, recompute_weighted_corner_normals: bool | None = None, keep_weighted_corner_normals: bool | None = None) -> int:
+    """
+    Computer vertex normal (Pythonic API).
+
+    :param mesh: Input mesh.
+    :param output_attribute_name: Output attribute name.
+    :param weight_type: Weighting type for normal computation.
+    :param weighted_corner_normal_attribute_name: Precomputed weighted corner normals attribute name.
+    :param recompute_weighted_corner_normals: Whether to recompute weighted corner normals.
+    :param keep_weighted_corner_normals: Whether to keep the weighted corner normal attribute.
+
+    :returns: Vertex normal attribute id.
+    """
+
+@overload
+def compute_vertex_valence(mesh: SurfaceMesh, options: VertexValenceOptions = ...) -> int:
+    """
+    Compute vertex valence
+
+    :param mesh: The input mesh.
+    :param options: The vertex valence options.
+
+    :returns: The vertex valence attribute id.
+    """
+
+@overload
+def compute_vertex_valence(mesh: SurfaceMesh, output_attribute_name: str | None = None) -> int:
+    """
+    Compute vertex valence);
+
+    :param mesh: The input mesh.
+    :param output_attribute_name: The name of the output attribute.
+
+    :returns: The vertex valence attribute id
+    """
+
+def detect_degenerate_facets(mesh: SurfaceMesh) -> list[int]:
+    """
+    Detect degenerate facets in a mesh.
+
+    .. note:
+        Only __exaxtly__ degenerate facets are detected.
+
+    :param mesh: The input mesh.
+
+    :returns: A list of indices of degenerate facets.
+    """
+
+def extract_submesh(mesh: SurfaceMesh, selected_facets: Annotated[ArrayLike, dict(dtype='uint32', order='C', device='cpu')], source_vertex_attr_name: str = '', source_facet_attr_name: str = '', map_attributes: bool = False) -> SurfaceMesh:
+    """
+    Extract a submesh based on the selected facets.
+
+    :param mesh:                    The source mesh.
+    :param selected_facets:         A listed of facet ids to extract.
+    :param source_vertex_attr_name: The optional attribute name to track source vertices.
+    :param source_facet_attr_name:  The optional attribute name to track source facets.
+    :param map_attributes:          Map attributes from the source to target meshes.
+
+    :returns: A mesh that contains only the selected facets.
+    """
+
+def filter_attributes(mesh: SurfaceMesh, included_attributes: Sequence[int | str] | None = None, excluded_attributes: Sequence[int | str] | None = None, included_usages: Set[AttributeUsage] | None = None, included_element_types: Set[AttributeElement] | None = None) -> SurfaceMesh:
+    """
+    Filters the attributes of mesh according to user specifications.
+
+    :param mesh: Input mesh.
+    :param included_attributes: List of attribute names or ids to include. By default, all attributes are included.
+    :param excluded_attributes: List of attribute names or ids to exclude. By default, no attribute is excluded.
+    :param included_usages: List of attribute usages to include. By default, all usages are included.
+    :param included_element_types: List of attribute element types to include. By default, all element types are included.
+    """
+
+invalid_index: int = 4294967295
+
+invalid_scalar: float = float('inf')
+
+def is_edge_manifold(mesh: SurfaceMesh) -> bool:
+    """
+    Check if the mesh is edge manifold.
+
+    :param mesh: The source mesh.
+
+    :return: Whether the mesh is edge manifold.
+    """
+
+def is_manifold(mesh: SurfaceMesh) -> bool:
+    """
+    Check if the mesh is manifold.
+
+    A mesh considered as manifold if it is both vertex and edge manifold.
+
+    :param mesh: The source mesh.
+
+    :return: Whether the mesh is manifold.
+    """
+
+def is_vertex_manifold(mesh: SurfaceMesh) -> bool:
+    """
+    Check if the mesh is vertex manifold.
+
+    :param mesh: The source mesh.
+
+    :return: Whether the mesh is vertex manifold.
+    """
+
+@overload
+def map_attribute(mesh: SurfaceMesh, old_attribute_id: int, new_attribute_name: str, new_element: AttributeElement) -> int:
+    """
+    Map an attribute to a new element type.
+
+    :param mesh: The input mesh.
+    :param old_attribute_id: The id of the input attribute.
+    :param new_attribute_name: The name of the new attribute.
+    :param new_element: The new element type.
+
+    :returns: The id of the new attribute.
+    """
+
+@overload
+def map_attribute(mesh: SurfaceMesh, old_attribute_name: str, new_attribute_name: str, new_element: AttributeElement) -> int:
+    """
+    Map an attribute to a new element type.
+
+    :param mesh: The input mesh.
+    :param old_attribute_name: The name of the input attribute.
+    :param new_attribute_name: The name of the new attribute.
+    :param new_element: The new element type.
+
+    :returns: The id of the new attribute.
+    """
+
+@overload
+def map_attribute_in_place(mesh: SurfaceMesh, id: int, new_element: AttributeElement) -> int:
+    """
+    Map an attribute to a new element type in place.
+
+    :param mesh: The input mesh.
+    :param id: The id of the input attribute.
+    :param new_element: The new element type.
+
+    :returns: The id of the new attribute.
+    """
+
+@overload
+def map_attribute_in_place(mesh: SurfaceMesh, name: str, new_element: AttributeElement) -> int:
+    """
+    Map an attribute to a new element type in place.
+
+    :param mesh: The input mesh.
+    :param name: The name of the input attribute.
+    :param new_element: The new element type.
+
+    :returns: The id of the new attribute.
+    """
+
+def normalize_mesh(mesh: SurfaceMesh) -> None:
+    """
+    Normalize a mesh to fit into a unit box centered at the origin.
+
+    :param mesh: input mesh
+    """
+
+def normalize_meshes(meshes: Sequence[SurfaceMesh]) -> None:
+    """
+    Normalize a list of meshes to fit into a unit box centered at the origin.
+
+    :param meshes: input meshes
+    """
+
+def permute_facets(mesh: SurfaceMesh, new_to_old: Annotated[ArrayLike, dict(dtype='uint32', order='C', device='cpu')]) -> None:
+    """
+    Reorder facets of a mesh in place based on a permutation.
+
+    :param mesh: input mesh
+    :param new_to_old: permutation vector for facets
+    """
+
+def permute_vertices(mesh: SurfaceMesh, new_to_old: Annotated[ArrayLike, dict(dtype='uint32', order='C', device='cpu')]) -> None:
+    """
+    Reorder vertices of a mesh in place based on a permutation.
+
+    :param mesh: input mesh
+    :param new_to_old: permutation vector for vertices
+    """
+
+@overload
+def remap_vertices(mesh: SurfaceMesh, old_to_new: Annotated[ArrayLike, dict(dtype='uint32', order='C', device='cpu')], options: RemapVerticesOptions = ...) -> None:
+    """
+    Remap vertices of a mesh in place based on a permutation.
+
+    :param mesh: input mesh
+    :param old_to_new: permutation vector for vertices
+    :param options: options for remapping vertices
+    """
+
+@overload
+def remap_vertices(mesh: SurfaceMesh, old_to_new: Annotated[ArrayLike, dict(dtype='uint32', order='C', device='cpu')], collision_policy_float: MappingPolicy | None = None, collision_policy_integral: MappingPolicy | None = None) -> None:
+    """
+    Remap vertices of a mesh in place based on a permutation (Pythonic API).
+
+    :param mesh: input mesh
+    :param old_to_new: permutation vector for vertices
+    :param collision_policy_float: The collision policy for float attributes.
+    :param collision_policy_integral: The collision policy for integral attributes.
+    """
+
+def remove_duplicate_facets(mesh: SurfaceMesh, consider_orientation: bool = False) -> None:
+    """
+    Remove duplicate facets from a mesh.
+
+    Facets of different orientations (e.g. (0, 1, 2) and (2, 1, 0)) are considered as duplicates.
+    If both orientations have equal number of duplicate facets, all of them are removed.
+    If one orientation has more duplicate facets, all but one facet with the majority orientation are removed.
+
+    :param mesh: The input mesh. The mesh is modified in place.
+    :param consider_orientation: Whether to consider orientation when detecting duplicate facets.
+    """
+
+def remove_duplicate_vertices(mesh: SurfaceMesh, extra_attributes: Sequence[int] | None = None) -> None:
+    """
+    Remove duplicate vertices from a mesh.
+
+    :param mesh:             The input mesh.
+    :param extra_attributes: Two vertices are considered duplicates if they have the same position and the same values for all attributes in `extra_attributes`.
+    """
+
+def remove_isolated_vertices(mesh: SurfaceMesh) -> None:
+    """
+    Remove isolated vertices from a mesh.
+
+    .. note:
+        A vertex is considered isolated if it is not referenced by any facet.
+
+    :param mesh: The input mesh for inplace modification.
+    """
+
+def remove_null_area_facets(mesh: SurfaceMesh, null_area_threshold: float = 0, remove_isolated_vertices: bool = False) -> None:
+    """
+    Remove facets with unsigned facets area <= `null_area_threhsold`.
+
+    :param mesh:                     The input mesh.
+    :param null_area_threshold:      The area threshold below which a facet is considered as null facet.
+    :param remove_isolated_vertices: Whether to remove isolated vertices after removing null area facets.
+    """
+
+def remove_topologically_degenerate_facets(mesh: SurfaceMesh) -> None:
+    """
+    Remove topologically degenerate facets such as (0, 1, 1)
+
+    For general polygons, topologically degeneracy means that the polygon is made of at most two unique
+    vertices. E.g. a quad of the form (0, 0, 1, 1) is degenerate, while a quad of the form (1, 1, 2, 3)
+    is not.
+
+    :param mesh: The input mesh for inplace modification.
+    """
+
+def separate_by_components(mesh: SurfaceMesh, source_vertex_attr_name: str = '', source_facet_attr_name: str = '', map_attributes: bool = False, connectivity_type: ConnectivityType = ConnectivityType.Edge) -> list[SurfaceMesh]:
+    """
+    Extract a set of submeshes based on connected components.
+
+    :param mesh:                    The source mesh.
+    :param source_vertex_attr_name: The optional attribute name to track source vertices.
+    :param source_facet_attr_name:  The optional attribute name to track source facets.
+    :param map_attributes:          Map attributes from the source to target meshes.
+    :param connectivity_type:       The connectivity used for component computation.
+
+    :returns: A list of meshes, one for each connected component.
+    """
+
+def separate_by_facet_groups(mesh: SurfaceMesh, facet_group_indices: Annotated[ArrayLike, dict(dtype='uint32', order='C', device='cpu')], source_vertex_attr_name: str = '', source_facet_attr_name: str = '', map_attributes: bool = False) -> list[SurfaceMesh]:
+    """
+    Extract a set of submeshes based on facet groups.
+
+    :param mesh:                    The source mesh.
+    :param facet_group_indices:     The group index for each facet. Each group index must be in the range of [0, max(facet_group_indices)]
+    :param source_vertex_attr_name: The optional attribute name to track source vertices.
+    :param source_facet_attr_name:  The optional attribute name to track source facets.
+
+    :returns: A list of meshes, one for each facet group.
+    """
+
+def transform_mesh(mesh: SurfaceMesh, affine_transform: Annotated[ArrayLike, dict(dtype='float64', shape=(4, 4), order='F')], normalize_normals: bool = True, normalize_tangents_bitangents: bool = True, in_place: bool = True) -> SurfaceMesh | None:
+    """
+    Apply affine transformation to a mesh.
+
+    :param mesh:                          The source mesh.
+    :param affine_transform:              The affine transformation matrix.
+    :param normalize_normals:             Whether to normalize normals.
+    :param normalize_tangents_bitangents: Whether to normalize tangents and bitangents.
+    :param in_place:                      Whether to apply the transformation in place.
+
+    :return: The transformed mesh if in_place is False.
+    """
+
+def triangulate_polygonal_facets(mesh: SurfaceMesh) -> None:
+    """
+    Triangulate polygonal facets of the mesh.
+
+    :param mesh: The input mesh.
+    """
+
+@overload
+def unify_index_buffer(mesh: SurfaceMesh) -> SurfaceMesh:
+    """
+    Unify the index buffer of the mesh.  All indexed attributes will be unified.
+
+    :param mesh: The mesh to unify.
+    :type mesh: SurfaceMesh
+
+    :returns: The unified mesh.
+    """
+
+@overload
+def unify_index_buffer(mesh: SurfaceMesh, attribute_ids: Sequence[int]) -> SurfaceMesh:
+    """
+    Unify the index buffer of the mesh for selected attributes.
+
+    :param mesh: The mesh to unify.
+    :type mesh: SurfaceMesh
+    :param attribute_ids: The selected attribute ids to unify.
+    :type attribute_ids: list of int
+
+    :returns: The unified mesh.
+    """
+
+@overload
+def unify_index_buffer(mesh: SurfaceMesh, attribute_names: Sequence[str]) -> SurfaceMesh:
+    """
+    Unify the index buffer of the mesh for selected attributes.
+
+    :param mesh: The mesh to unify.
+    :type mesh: SurfaceMesh
+    :param attribute_names: The selected attribute names to unify.
+    :type attribute_names: list of str
+
+    :returns: The unified mesh.
+    """
+
+def weld_indexed_attribute(mesh: SurfaceMesh, attribute_id: int) -> None:
+    """
+    Weld indexed attribute.
+
+    :param mesh:         The source mesh.
+    :param attribute_id: The indexed attribute id to weld.
+    """
```

## lagrange/lagrange/image.pyi

```diff
@@ -1,62 +1,46 @@
-from typing import Any, Optional, overload, Typing, Sequence
-from enum import Enum
-import lagrange.image
-
-class ImageChannel(Enum):
-    """
-    <attribute '__doc__' of 'ImageChannel' objects>
-    """
-
-    four: Any
-    
-    one: Any
-    
-    three: Any
-    
-    unknown: Any
-    
-class ImagePrecision(Enum):
-    """
-    <attribute '__doc__' of 'ImagePrecision' objects>
-    """
-
-    float16: Any
-    
-    float32: Any
-    
-    float64: Any
-    
-    int32: Any
-    
-    int8: Any
-    
-    uint32: Any
-    
-    uint8: Any
-    
-    unknown: Any
-    
-class ImageStorage:
-    """
-    None
-    """
-
-    def __init__(self, arg0: int, arg1: int, arg2: int, /) -> None:
-        ...
-    
-    @property
-    def data(self) -> numpy.typing.NDArray:
-        ...
-    
-    @property
-    def height(self) -> int:
-        ...
-    
-    @property
-    def stride(self) -> int:
-        ...
-    
-    @property
-    def width(self) -> int:
-        ...
-    
+import enum
+from typing import Annotated
+
+from numpy.typing import ArrayLike
+
+
+class ImageChannel(enum.Enum):
+    one = 1
+
+    three = 3
+
+    four = 4
+
+    unknown = 5
+
+class ImagePrecision(enum.Enum):
+    uint8 = 0
+
+    int8 = 1
+
+    uint32 = 2
+
+    int32 = 3
+
+    float32 = 4
+
+    float64 = 5
+
+    float16 = 6
+
+    unknown = 7
+
+class ImageStorage:
+    def __init__(self, arg0: int, arg1: int, arg2: int, /) -> None: ...
+
+    @property
+    def width(self) -> int: ...
+
+    @property
+    def height(self) -> int: ...
+
+    @property
+    def stride(self) -> int: ...
+
+    @property
+    def data(self) -> Annotated[ArrayLike, dict(dtype='uint8', order='C', device='cpu')]: ...
```

## lagrange/lagrange/io.pyi

```diff
@@ -1,270 +1,220 @@
-from typing import Any, Optional, overload, Typing, Sequence
-from enum import Enum
-import lagrange.io
-
-class FileEncoding(Enum):
-    """
-    <attribute '__doc__' of 'FileEncoding' objects>
-    """
-
-    Ascii: Any
-    
-    Binary: Any
-    
-class FileFormat(Enum):
-    """
-    <attribute '__doc__' of 'FileFormat' objects>
-    """
-
-    Gltf: Any
-    
-    Msh: Any
-    
-    Obj: Any
-    
-    Ply: Any
-    
-    Unknown: Any
-    
-class LoadOptions:
-    """
-    None
-    """
-
-    def __init__(self) -> None:
-        ...
-    
-    @property
-    def load_materials(self) -> bool:
-        ...
-    @load_materials.setter
-    def load_materials(self, arg: bool, /) -> None:
-        ...
-    
-    @property
-    def load_normals(self) -> bool:
-        ...
-    @load_normals.setter
-    def load_normals(self, arg: bool, /) -> None:
-        ...
-    
-    @property
-    def load_object_ids(self) -> bool:
-        ...
-    @load_object_ids.setter
-    def load_object_ids(self, arg: bool, /) -> None:
-        ...
-    
-    @property
-    def load_tangents(self) -> bool:
-        ...
-    @load_tangents.setter
-    def load_tangents(self, arg: bool, /) -> None:
-        ...
-    
-    @property
-    def load_uvs(self) -> bool:
-        ...
-    @load_uvs.setter
-    def load_uvs(self, arg: bool, /) -> None:
-        ...
-    
-    @property
-    def load_vertex_colors(self) -> bool:
-        ...
-    @load_vertex_colors.setter
-    def load_vertex_colors(self, arg: bool, /) -> None:
-        ...
-    
-    @property
-    def load_weights(self) -> bool:
-        ...
-    @load_weights.setter
-    def load_weights(self, arg: bool, /) -> None:
-        ...
-    
-    @property
-    def search_path(self) -> os.PathLike:
-        ...
-    @search_path.setter
-    def search_path(self, arg: os.PathLike, /) -> None:
-        ...
-    
-    @property
-    def triangulate(self) -> bool:
-        ...
-    @triangulate.setter
-    def triangulate(self, arg: bool, /) -> None:
-        ...
-    
-class SaveOptions:
-    """
-    None
-    """
-
-    class AttributeConversionPolicy(Enum):
-        """
-        <attribute '__doc__' of 'AttributeConversionPolicy' objects>
-        """
-    
-        ConvertAsNeeded: Any
-        
-        ExactMatchOnly: Any
-        
-    class OutputAttributes(Enum):
-        """
-        <attribute '__doc__' of 'OutputAttributes' objects>
-        """
-    
-        All: Any
-        
-        SelectedOnly: Any
-        
-    def __init__(self) -> None:
-        ...
-    
-    @property
-    def attribute_conversion_policy(self) -> lagrange.io.SaveOptions.AttributeConversionPolicy:
-        ...
-    @attribute_conversion_policy.setter
-    def attribute_conversion_policy(self, arg: lagrange.io.SaveOptions.AttributeConversionPolicy, /) -> None:
-        ...
-    
-    @property
-    def embed_images(self) -> bool:
-        ...
-    @embed_images.setter
-    def embed_images(self, arg: bool, /) -> None:
-        ...
-    
-    @property
-    def encoding(self) -> lagrange.io.FileEncoding:
-        ...
-    @encoding.setter
-    def encoding(self, arg: lagrange.io.FileEncoding, /) -> None:
-        ...
-    
-    @property
-    def output_attributes(self) -> lagrange.io.SaveOptions.OutputAttributes:
-        ...
-    @output_attributes.setter
-    def output_attributes(self, arg: lagrange.io.SaveOptions.OutputAttributes, /) -> None:
-        ...
-    
-    @property
-    def selected_attributes(self) -> list[int]:
-        ...
-    @selected_attributes.setter
-    def selected_attributes(self, arg: list[int], /) -> None:
-        ...
-    
-def load_mesh(*args, **kwargs):
-    """
-    load_mesh(filename: os.PathLike, triangulate: bool = False, load_normals: bool = True, load_tangents: bool = True, load_uvs: bool = True, load_weights: bool = True, load_materials: bool = True, load_vertex_colors: bool = True, load_object_ids: bool = True, load_images: bool = True, search_path: os.PathLike = .) -> lagrange.core.SurfaceMesh
-    
-    Load mesh from a file.
-    
-    :param filename:           The input file name.
-    :param triangulate:        Whether to triangulate the mesh if it is not already triangulated. Defaults to False.
-    :param load_normals:       Whether to load vertex normals from mesh if available. Defaults to True.
-    :param load_tangents:      Whether to load tangents and bitangents from mesh if available. Defaults to True.
-    :param load_uvs:           Whether to load texture coordinates from mesh if available. Defaults to True.
-    :param load_weights:       Whether to load skinning weights attributes from mesh if available. Defaults to True.
-    :param load_materials:     Whether to load material ids from mesh if available. Defaults to True.
-    :param load_vertex_colors: Whether to load vertex colors from mesh if available. Defaults to True.
-    :param load_object_id:     Whether to load object ids from mesh if available. Defaults to True.
-    :param load_images:        Whether to load external images if available. Defaults to True.
-    
-    :return SurfaceMesh: The mesh object extracted from the input string.
-    """
-    ...
-
-def load_scene(*args, **kwargs):
-    """
-    load_scene(filename: os.PathLike, options: lagrange.io.LoadOptions = <lagrange.io.LoadOptions object at 0x000001A7A5886D50>) -> lagrange.scene.Scene
-    
-    Load a scene.
-    
-    :param filename:    The input file name.
-    :param options:     Load scene options. Check the class for more details.
-    
-    :return Scene: The loaded scene object.
-    """
-    ...
-
-def load_simple_scene(filename: os.PathLike, triangulate: bool = False, search_path: Optional[os.PathLike] = None) -> lagrange.scene.SimpleScene3D:
-    """
-    Load a simple scene from file.
-    
-    :param filename:    The input file name.
-    :param triangulate: Whether to triangulate the scene if it is not already triangulated. Defaults to False.
-    :param search_path: Optional search path for external references (e.g. .mtl, .bin, etc.). Defaults to None.
-    
-    :return SimpleScene: The scene object extracted from the input string.
-    """
-    ...
-
-def mesh_to_string(mesh: lagrange.core.SurfaceMesh, format: str = 'ply', binary: bool = True, exact_match: bool = True, selected_attributes: Optional[list[int]] = None) -> bytes:
-    """
-    Convert a mesh to a binary string based on specified format.
-    
-    :param mesh: The input mesh.
-    :param format: Format to use. Supported formats are "obj", "ply", "gltf" and "msh".
-    :param binary: Whether to save the mesh in binary format if supported. Defaults to True. Only `msh`, `ply` and `glb` support binary format.
-    :param exact_match: Whether to save attributes in their exact form. Some mesh formats may not support all the attribute types. If set to False, attributes will be converted to the closest supported attribute type. Defaults to True.
-    :param selected_attributes: A list of attribute ids to save. If not specified, all attributes will be saved. Defaults to None.
-    
-    :return str: The string representing the input mesh.
-    """
-    ...
-
-def save_mesh(filename: os.PathLike, mesh: lagrange.core.SurfaceMesh, binary: bool = True, exact_match: bool = True, selected_attributes: Optional[list[int]] = None) -> None:
-    """
-    Save mesh to file.
-    
-    Filename extension determines the file format. Supported formats are: `obj`, `ply`, `msh`, `glb` and `gltf`.
-    
-    :param filename: The output file name.
-    :param mesh: The input mesh.
-    :param binary: Whether to save the mesh in binary format if supported. Defaults to True. Only `msh`, `ply` and `glb` support binary format.
-    :param exact_match: Whether to save attributes in their exact form. Some mesh formats may not support all the attribute types. If set to False, attributes will be converted to the closest supported attribute type. Defaults to True.
-    :param selected_attributes: A list of attribute ids to save. If not specified, all attributes will be saved. Defaults to None.
-    """
-    ...
-
-def save_scene(*args, **kwargs):
-    """
-    save_scene(filename: os.PathLike, scene: lagrange.scene.Scene, options: lagrange.io.SaveOptions = <lagrange.io.SaveOptions object at 0x000001A7A5886DB0>) -> None
-    
-    Save a scene.
-    
-    :param filename:    The output file name.
-    :param scene:       The scene to save.
-    :param options:     Save options. Check the class for more details.
-    """
-    ...
-
-def save_simple_scene(filename: os.PathLike, scene: lagrange.scene.SimpleScene3D, binary: bool = True) -> None:
-    """
-    Save a simple scene to file.
-    
-    :param filename: The output file name.
-    :param scene:    The input scene.
-    :param binary:   Whether to save the scene in binary format if supported. Defaults to True. Only `glb` supports binary format.
-    """
-    ...
-
-def string_to_mesh(data: bytes, triangulate: bool = False) -> lagrange.core.SurfaceMesh:
-    """
-    Convert a binary string to a mesh.
-    
-    The binary string should use one of the supported formats. Supported formats include `obj`, `ply`,
-    `gltf`, `glb` and `msh`. Format is automatically detected.
-    
-    :param data:        A binary string representing the mesh data in a supported format.
-    :param triangulate: Whether to triangulate the mesh if it is not already triangulated. Defaults to False.
-    
-    :return SurfaceMesh: The mesh object extracted from the input string.
-    """
-    ...
-
+from collections.abc import Sequence
+import enum
+import os
+import pathlib
+
+import lagrange.core
+import lagrange.scene
+
+
+class FileEncoding(enum.Enum):
+    Binary = 0
+
+    Ascii = 1
+
+class FileFormat(enum.Enum):
+    Obj = 0
+
+    Ply = 1
+
+    Gltf = 2
+
+    Msh = 3
+
+    Unknown = 4
+
+class LoadOptions:
+    def __init__(self) -> None: ...
+
+    @property
+    def triangulate(self) -> bool: ...
+
+    @triangulate.setter
+    def triangulate(self, arg: bool, /) -> None: ...
+
+    @property
+    def load_normals(self) -> bool: ...
+
+    @load_normals.setter
+    def load_normals(self, arg: bool, /) -> None: ...
+
+    @property
+    def load_tangents(self) -> bool: ...
+
+    @load_tangents.setter
+    def load_tangents(self, arg: bool, /) -> None: ...
+
+    @property
+    def load_uvs(self) -> bool: ...
+
+    @load_uvs.setter
+    def load_uvs(self, arg: bool, /) -> None: ...
+
+    @property
+    def load_weights(self) -> bool: ...
+
+    @load_weights.setter
+    def load_weights(self, arg: bool, /) -> None: ...
+
+    @property
+    def load_materials(self) -> bool: ...
+
+    @load_materials.setter
+    def load_materials(self, arg: bool, /) -> None: ...
+
+    @property
+    def load_vertex_colors(self) -> bool: ...
+
+    @load_vertex_colors.setter
+    def load_vertex_colors(self, arg: bool, /) -> None: ...
+
+    @property
+    def load_object_ids(self) -> bool: ...
+
+    @load_object_ids.setter
+    def load_object_ids(self, arg: bool, /) -> None: ...
+
+    @property
+    def search_path(self) -> pathlib.Path: ...
+
+    @search_path.setter
+    def search_path(self, arg: str | os.PathLike, /) -> None: ...
+
+class SaveOptions:
+    def __init__(self) -> None: ...
+
+    @property
+    def encoding(self) -> FileEncoding: ...
+
+    @encoding.setter
+    def encoding(self, arg: FileEncoding, /) -> None: ...
+
+    @property
+    def output_attributes(self) -> SaveOptions.OutputAttributes: ...
+
+    @output_attributes.setter
+    def output_attributes(self, arg: SaveOptions.OutputAttributes, /) -> None: ...
+
+    @property
+    def selected_attributes(self) -> list[int]: ...
+
+    @selected_attributes.setter
+    def selected_attributes(self, arg: Sequence[int], /) -> None: ...
+
+    @property
+    def attribute_conversion_policy(self) -> SaveOptions.AttributeConversionPolicy: ...
+
+    @attribute_conversion_policy.setter
+    def attribute_conversion_policy(self, arg: SaveOptions.AttributeConversionPolicy, /) -> None: ...
+
+    @property
+    def embed_images(self) -> bool: ...
+
+    @embed_images.setter
+    def embed_images(self, arg: bool, /) -> None: ...
+
+    class OutputAttributes(enum.Enum):
+        All = 0
+
+        SelectedOnly = 1
+
+    class AttributeConversionPolicy(enum.Enum):
+        ExactMatchOnly = 0
+
+        ConvertAsNeeded = 1
+
+def load_mesh(filename: str | os.PathLike, triangulate: bool = False, load_normals: bool = True, load_tangents: bool = True, load_uvs: bool = True, load_weights: bool = True, load_materials: bool = True, load_vertex_colors: bool = True, load_object_ids: bool = True, load_images: bool = True, search_path: str | os.PathLike = ...) -> lagrange.core.SurfaceMesh:
+    """
+    Load mesh from a file.
+
+    :param filename:           The input file name.
+    :param triangulate:        Whether to triangulate the mesh if it is not already triangulated. Defaults to False.
+    :param load_normals:       Whether to load vertex normals from mesh if available. Defaults to True.
+    :param load_tangents:      Whether to load tangents and bitangents from mesh if available. Defaults to True.
+    :param load_uvs:           Whether to load texture coordinates from mesh if available. Defaults to True.
+    :param load_weights:       Whether to load skinning weights attributes from mesh if available. Defaults to True.
+    :param load_materials:     Whether to load material ids from mesh if available. Defaults to True.
+    :param load_vertex_colors: Whether to load vertex colors from mesh if available. Defaults to True.
+    :param load_object_id:     Whether to load object ids from mesh if available. Defaults to True.
+    :param load_images:        Whether to load external images if available. Defaults to True.
+
+    :return SurfaceMesh: The mesh object extracted from the input string.
+    """
+
+def load_scene(filename: str | os.PathLike, options: LoadOptions = ...) -> lagrange.scene.Scene:
+    """
+    Load a scene.
+
+    :param filename:    The input file name.
+    :param options:     Load scene options. Check the class for more details.
+
+    :return Scene: The loaded scene object.
+    """
+
+def load_simple_scene(filename: str | os.PathLike, triangulate: bool = False, search_path: str | os.PathLike | None = None) -> lagrange.scene.SimpleScene3D:
+    """
+    Load a simple scene from file.
+
+    :param filename:    The input file name.
+    :param triangulate: Whether to triangulate the scene if it is not already triangulated. Defaults to False.
+    :param search_path: Optional search path for external references (e.g. .mtl, .bin, etc.). Defaults to None.
+
+    :return SimpleScene: The scene object extracted from the input string.
+    """
+
+def mesh_to_string(mesh: lagrange.core.SurfaceMesh, format: str = 'ply', binary: bool = True, exact_match: bool = True, selected_attributes: Sequence[int] | None = None) -> bytes:
+    """
+    Convert a mesh to a binary string based on specified format.
+
+    :param mesh: The input mesh.
+    :param format: Format to use. Supported formats are "obj", "ply", "gltf" and "msh".
+    :param binary: Whether to save the mesh in binary format if supported. Defaults to True. Only `msh`, `ply` and `glb` support binary format.
+    :param exact_match: Whether to save attributes in their exact form. Some mesh formats may not support all the attribute types. If set to False, attributes will be converted to the closest supported attribute type. Defaults to True.
+    :param selected_attributes: A list of attribute ids to save. If not specified, all attributes will be saved. Defaults to None.
+
+    :return str: The string representing the input mesh.
+    """
+
+def save_mesh(filename: str | os.PathLike, mesh: lagrange.core.SurfaceMesh, binary: bool = True, exact_match: bool = True, selected_attributes: Sequence[int] | None = None) -> None:
+    """
+    Save mesh to file.
+
+    Filename extension determines the file format. Supported formats are: `obj`, `ply`, `msh`, `glb` and `gltf`.
+
+    :param filename: The output file name.
+    :param mesh: The input mesh.
+    :param binary: Whether to save the mesh in binary format if supported. Defaults to True. Only `msh`, `ply` and `glb` support binary format.
+    :param exact_match: Whether to save attributes in their exact form. Some mesh formats may not support all the attribute types. If set to False, attributes will be converted to the closest supported attribute type. Defaults to True.
+    :param selected_attributes: A list of attribute ids to save. If not specified, all attributes will be saved. Defaults to None.
+    """
+
+def save_scene(filename: str | os.PathLike, scene: lagrange.scene.Scene, options: SaveOptions = ...) -> None:
+    """
+    Save a scene.
+
+    :param filename:    The output file name.
+    :param scene:       The scene to save.
+    :param options:     Save options. Check the class for more details.
+    """
+
+def save_simple_scene(filename: str | os.PathLike, scene: lagrange.scene.SimpleScene3D, binary: bool = True) -> None:
+    """
+    Save a simple scene to file.
+
+    :param filename: The output file name.
+    :param scene:    The input scene.
+    :param binary:   Whether to save the scene in binary format if supported. Defaults to True. Only `glb` supports binary format.
+    """
+
+def string_to_mesh(data: bytes, triangulate: bool = False) -> lagrange.core.SurfaceMesh:
+    """
+    Convert a binary string to a mesh.
+
+    The binary string should use one of the supported formats. Supported formats include `obj`, `ply`,
+    `gltf`, `glb` and `msh`. Format is automatically detected.
+
+    :param data:        A binary string representing the mesh data in a supported format.
+    :param triangulate: Whether to triangulate the mesh if it is not already triangulated. Defaults to False.
+
+    :return SurfaceMesh: The mesh object extracted from the input string.
+    """
```

## lagrange/lagrange/scene.pyi

```diff
@@ -1,1960 +1,1705 @@
-from typing import Any, Optional, overload, Typing, Sequence
-from enum import Enum
-import lagrange.scene
-
-class Animation:
-
-    def __init__(self) -> None:
-        ...
-    
-    @property
-    def extensions(self) -> lagrange.scene.Extensions:
-        ...
-    @extensions.setter
-    def extensions(self, arg: lagrange.scene.Extensions, /) -> None:
-        ...
-    
-    @property
-    def name(self) -> str:
-        ...
-    @name.setter
-    def name(self, arg: str, /) -> None:
-        ...
-    
-class AnimationList:
-    """
-    None
-    """
-
-    def __init__(self, arg: Iterable[lagrange.scene.Animation], /) -> None:
-        """
-        Construct from an iterable object
-        """
-        ...
-    
-    @overload
-    def __init__(self) -> None:
-        """
-        Default constructor
-        """
-        ...
-    
-    @overload
-    def __init__(self, arg: lagrange.scene.AnimationList) -> None:
-        """
-        Copy constructor
-        """
-        ...
-    
-    def append(self, arg: lagrange.scene.Animation, /) -> None:
-        """
-        Append `arg` to the end of the list.
-        """
-        ...
-    
-    def clear(self) -> None:
-        """
-        Remove all items from list.
-        """
-        ...
-    
-    def extend(self, arg: lagrange.scene.AnimationList, /) -> None:
-        """
-        Extend `self` by appending elements from `arg`.
-        """
-        ...
-    
-    def insert(self, arg0: int, arg1: lagrange.scene.Animation, /) -> None:
-        """
-        Insert object `arg1` before index `arg0`.
-        """
-        ...
-    
-    def pop(self, index: int = -1) -> lagrange.scene.Animation:
-        """
-        Remove and return item at `index` (default last).
-        """
-        ...
-    
-class BufferList:
-    """
-    None
-    """
-
-    def __init__(self, arg: Iterable[int], /) -> None:
-        """
-        Construct from an iterable object
-        """
-        ...
-    
-    @overload
-    def __init__(self) -> None:
-        """
-        Default constructor
-        """
-        ...
-    
-    @overload
-    def __init__(self, arg: lagrange.scene.BufferList) -> None:
-        """
-        Copy constructor
-        """
-        ...
-    
-    def append(self, arg: int, /) -> None:
-        """
-        Append `arg` to the end of the list.
-        """
-        ...
-    
-    def clear(self) -> None:
-        """
-        Remove all items from list.
-        """
-        ...
-    
-    def count(self, arg: int, /) -> int:
-        """
-        Return number of occurrences of `arg`.
-        """
-        ...
-    
-    def extend(self, arg: lagrange.scene.BufferList, /) -> None:
-        """
-        Extend `self` by appending elements from `arg`.
-        """
-        ...
-    
-    def insert(self, arg0: int, arg1: int, /) -> None:
-        """
-        Insert object `arg1` before index `arg0`.
-        """
-        ...
-    
-    def pop(self, index: int = -1) -> int:
-        """
-        Remove and return item at `index` (default last).
-        """
-        ...
-    
-    def remove(self, arg: int, /) -> None:
-        """
-        Remove first occurrence of `arg`.
-        """
-        ...
-    
-class Camera:
-    """
-    Camera
-    """
-
-    class Type(Enum):
-        """
-        <attribute '__doc__' of 'Type' objects>
-        """
-    
-        Orthographic: Any
-        
-        Perspective: Any
-        
-    def __init__(self) -> None:
-        ...
-    
-    @property
-    def aspect_ratio(self) -> float:
-        ...
-    @aspect_ratio.setter
-    def aspect_ratio(self, arg: float, /) -> None:
-        ...
-    
-    @property
-    def extensions(self) -> lagrange.scene.Extensions:
-        ...
-    @extensions.setter
-    def extensions(self, arg: lagrange.scene.Extensions, /) -> None:
-        ...
-    
-    @property
-    def far_plane(self) -> float:
-        ...
-    @far_plane.setter
-    def far_plane(self, arg: float, /) -> None:
-        ...
-    
-    @property
-    def get_vertical_fov(self) -> float:
-        ...
-    
-    @property
-    def horizontal_fov(self) -> float:
-        ...
-    @horizontal_fov.setter
-    def horizontal_fov(self, arg: float, /) -> None:
-        ...
-    
-    @property
-    def look_at(self) -> numpy.typing.NDArray:
-        ...
-    @look_at.setter
-    def look_at(self, arg: numpy.typing.NDArray, /) -> None:
-        ...
-    
-    @property
-    def name(self) -> str:
-        ...
-    @name.setter
-    def name(self, arg: str, /) -> None:
-        ...
-    
-    @property
-    def near_plane(self) -> float:
-        ...
-    @near_plane.setter
-    def near_plane(self, arg: float, /) -> None:
-        ...
-    
-    @property
-    def orthographic_width(self) -> float:
-        ...
-    @orthographic_width.setter
-    def orthographic_width(self, arg: float, /) -> None:
-        ...
-    
-    @property
-    def position(self) -> numpy.typing.NDArray:
-        ...
-    @position.setter
-    def position(self, arg: numpy.typing.NDArray, /) -> None:
-        ...
-    
-    @property
-    def set_horizontal_fov_from_vertical_fov(self, arg: float, /) -> None:
-        ...
-    
-    @property
-    def type(self) -> lagrange.scene.Camera.Type:
-        ...
-    @type.setter
-    def type(self, arg: lagrange.scene.Camera.Type, /) -> None:
-        ...
-    
-    @property
-    def up(self) -> numpy.typing.NDArray:
-        ...
-    @up.setter
-    def up(self, arg: numpy.typing.NDArray, /) -> None:
-        ...
-    
-class CameraList:
-    """
-    None
-    """
-
-    def __init__(self, arg: Iterable[lagrange.scene.Camera], /) -> None:
-        """
-        Construct from an iterable object
-        """
-        ...
-    
-    @overload
-    def __init__(self) -> None:
-        """
-        Default constructor
-        """
-        ...
-    
-    @overload
-    def __init__(self, arg: lagrange.scene.CameraList) -> None:
-        """
-        Copy constructor
-        """
-        ...
-    
-    def append(self, arg: lagrange.scene.Camera, /) -> None:
-        """
-        Append `arg` to the end of the list.
-        """
-        ...
-    
-    def clear(self) -> None:
-        """
-        Remove all items from list.
-        """
-        ...
-    
-    def extend(self, arg: lagrange.scene.CameraList, /) -> None:
-        """
-        Extend `self` by appending elements from `arg`.
-        """
-        ...
-    
-    def insert(self, arg0: int, arg1: lagrange.scene.Camera, /) -> None:
-        """
-        Insert object `arg1` before index `arg0`.
-        """
-        ...
-    
-    def pop(self, index: int = -1) -> lagrange.scene.Camera:
-        """
-        Remove and return item at `index` (default last).
-        """
-        ...
-    
-class ElementIdList:
-    """
-    None
-    """
-
-    def __init__(self, arg: Iterable[int], /) -> None:
-        """
-        Construct from an iterable object
-        """
-        ...
-    
-    @overload
-    def __init__(self) -> None:
-        """
-        Default constructor
-        """
-        ...
-    
-    @overload
-    def __init__(self, arg: lagrange.scene.ElementIdList) -> None:
-        """
-        Copy constructor
-        """
-        ...
-    
-    def append(self, arg: int, /) -> None:
-        """
-        Append `arg` to the end of the list.
-        """
-        ...
-    
-    def clear(self) -> None:
-        """
-        Remove all items from list.
-        """
-        ...
-    
-    def count(self, arg: int, /) -> int:
-        """
-        Return number of occurrences of `arg`.
-        """
-        ...
-    
-    def extend(self, arg: lagrange.scene.ElementIdList, /) -> None:
-        """
-        Extend `self` by appending elements from `arg`.
-        """
-        ...
-    
-    def insert(self, arg0: int, arg1: int, /) -> None:
-        """
-        Insert object `arg1` before index `arg0`.
-        """
-        ...
-    
-    def pop(self, index: int = -1) -> int:
-        """
-        Remove and return item at `index` (default last).
-        """
-        ...
-    
-    def remove(self, arg: int, /) -> None:
-        """
-        Remove first occurrence of `arg`.
-        """
-        ...
-    
-class Extensions:
-    """
-    None
-    """
-
-    def __init__(*args, **kwargs):
-        """
-        Initialize self.  See help(type(self)) for accurate signature.
-        """
-        ...
-    
-    @property
-    def data(self) -> lagrange.scene.ValueUnorderedMap:
-        ...
-    @data.setter
-    def data(self, arg: lagrange.scene.ValueUnorderedMap, /) -> None:
-        ...
-    
-    @property
-    def empty(self) -> bool:
-        ...
-    
-    @property
-    def size(self) -> int:
-        ...
-    
-class FacetAllocationStrategy(Enum):
-    """
-    <attribute '__doc__' of 'FacetAllocationStrategy' objects>
-    """
-
-    EvenSplit: Any
-    
-    RelativeToMeshArea: Any
-    
-    RelativeToNumFacets: Any
-    
-    Synchronized: Any
-    
-class Image:
-    """
-    None
-    """
-
-    def __init__(self) -> None:
-        ...
-    
-    @property
-    def extensions(self) -> lagrange.scene.Extensions:
-        """
-        Additional data associated with the image
-        """
-        ...
-    @extensions.setter
-    def extensions(self, arg: lagrange.scene.Extensions, /) -> None:
-        """
-        Additional data associated with the image
-        """
-        ...
-    
-    @property
-    def image(self) -> lagrange.scene.ImageBuffer:
-        """
-        Image buffer
-        """
-        ...
-    @image.setter
-    def image(self, arg: lagrange.scene.ImageBuffer, /) -> None:
-        """
-        Image buffer
-        """
-        ...
-    
-    @property
-    def name(self) -> str:
-        """
-        Name of the image object
-        """
-        ...
-    @name.setter
-    def name(self, arg: str, /) -> None:
-        """
-        Name of the image object
-        """
-        ...
-    
-    @property
-    def uri(self) -> os.PathLike:
-        """
-        URI of the image file
-        """
-        ...
-    @uri.setter
-    def uri(self, arg: os.PathLike, /) -> None:
-        """
-        URI of the image file
-        """
-        ...
-    
-class ImageBuffer:
-    """
-    None
-    """
-
-    def __init__(self) -> None:
-        ...
-    
-    @property
-    def data(self) -> object:
-        """
-        Raw image data.
-        """
-        ...
-    @data.setter
-    def data(self, arg: numpy.typing.NDArray, /) -> None:
-        """
-        Raw image data.
-        """
-        ...
-    
-    @property
-    def dtype(self) -> Optional[type]:
-        """
-        The element data type of the image buffer.
-        """
-        ...
-    
-    @property
-    def height(self) -> int:
-        """
-        Image height
-        """
-        ...
-    
-    @property
-    def num_channels(self) -> int:
-        """
-        Number of channels in each pixel
-        """
-        ...
-    
-    @property
-    def width(self) -> int:
-        """
-        Image width
-        """
-        ...
-    
-class ImageList:
-    """
-    None
-    """
-
-    def __init__(self, arg: Iterable[lagrange.scene.Image], /) -> None:
-        """
-        Construct from an iterable object
-        """
-        ...
-    
-    @overload
-    def __init__(self) -> None:
-        """
-        Default constructor
-        """
-        ...
-    
-    @overload
-    def __init__(self, arg: lagrange.scene.ImageList) -> None:
-        """
-        Copy constructor
-        """
-        ...
-    
-    def append(self, arg: lagrange.scene.Image, /) -> None:
-        """
-        Append `arg` to the end of the list.
-        """
-        ...
-    
-    def clear(self) -> None:
-        """
-        Remove all items from list.
-        """
-        ...
-    
-    def extend(self, arg: lagrange.scene.ImageList, /) -> None:
-        """
-        Extend `self` by appending elements from `arg`.
-        """
-        ...
-    
-    def insert(self, arg0: int, arg1: lagrange.scene.Image, /) -> None:
-        """
-        Insert object `arg1` before index `arg0`.
-        """
-        ...
-    
-    def pop(self, index: int = -1) -> lagrange.scene.Image:
-        """
-        Remove and return item at `index` (default last).
-        """
-        ...
-    
-class Light:
-    """
-    Light
-    """
-
-    class Type(Enum):
-        """
-        <attribute '__doc__' of 'Type' objects>
-        """
-    
-        Ambient: Any
-        
-        Area: Any
-        
-        Directional: Any
-        
-        Point: Any
-        
-        Spot: Any
-        
-        Undefined: Any
-        
-    def __init__(self) -> None:
-        ...
-    
-    @property
-    def angle_inner_cone(self) -> float:
-        ...
-    @angle_inner_cone.setter
-    def angle_inner_cone(self, arg: float, /) -> None:
-        ...
-    
-    @property
-    def angle_outer_cone(self) -> float:
-        ...
-    @angle_outer_cone.setter
-    def angle_outer_cone(self, arg: float, /) -> None:
-        ...
-    
-    @property
-    def attenuation_constant(self) -> float:
-        ...
-    @attenuation_constant.setter
-    def attenuation_constant(self, arg: float, /) -> None:
-        ...
-    
-    @property
-    def attenuation_cubic(self) -> float:
-        ...
-    @attenuation_cubic.setter
-    def attenuation_cubic(self, arg: float, /) -> None:
-        ...
-    
-    @property
-    def attenuation_linear(self) -> float:
-        ...
-    @attenuation_linear.setter
-    def attenuation_linear(self, arg: float, /) -> None:
-        ...
-    
-    @property
-    def attenuation_quadratic(self) -> float:
-        ...
-    @attenuation_quadratic.setter
-    def attenuation_quadratic(self, arg: float, /) -> None:
-        ...
-    
-    @property
-    def color_ambient(self) -> numpy.typing.NDArray:
-        ...
-    @color_ambient.setter
-    def color_ambient(self, arg: numpy.typing.NDArray, /) -> None:
-        ...
-    
-    @property
-    def color_diffuse(self) -> numpy.typing.NDArray:
-        ...
-    @color_diffuse.setter
-    def color_diffuse(self, arg: numpy.typing.NDArray, /) -> None:
-        ...
-    
-    @property
-    def color_specular(self) -> numpy.typing.NDArray:
-        ...
-    @color_specular.setter
-    def color_specular(self, arg: numpy.typing.NDArray, /) -> None:
-        ...
-    
-    @property
-    def direction(self) -> numpy.typing.NDArray:
-        ...
-    @direction.setter
-    def direction(self, arg: numpy.typing.NDArray, /) -> None:
-        ...
-    
-    @property
-    def extensions(self) -> lagrange.scene.Extensions:
-        ...
-    @extensions.setter
-    def extensions(self, arg: lagrange.scene.Extensions, /) -> None:
-        ...
-    
-    @property
-    def intensity(self) -> float:
-        ...
-    @intensity.setter
-    def intensity(self, arg: float, /) -> None:
-        ...
-    
-    @property
-    def name(self) -> str:
-        ...
-    @name.setter
-    def name(self, arg: str, /) -> None:
-        ...
-    
-    @property
-    def position(self) -> numpy.typing.NDArray:
-        ...
-    @position.setter
-    def position(self, arg: numpy.typing.NDArray, /) -> None:
-        ...
-    
-    @property
-    def range(self) -> float:
-        ...
-    @range.setter
-    def range(self, arg: float, /) -> None:
-        ...
-    
-    @property
-    def size(self) -> numpy.typing.NDArray:
-        ...
-    @size.setter
-    def size(self, arg: numpy.typing.NDArray, /) -> None:
-        ...
-    
-    @property
-    def type(self) -> lagrange.scene.Light.Type:
-        ...
-    @type.setter
-    def type(self, arg: lagrange.scene.Light.Type, /) -> None:
-        ...
-    
-    @property
-    def up(self) -> numpy.typing.NDArray:
-        ...
-    @up.setter
-    def up(self, arg: numpy.typing.NDArray, /) -> None:
-        ...
-    
-class LightList:
-    """
-    None
-    """
-
-    def __init__(self, arg: Iterable[lagrange.scene.Light], /) -> None:
-        """
-        Construct from an iterable object
-        """
-        ...
-    
-    @overload
-    def __init__(self) -> None:
-        """
-        Default constructor
-        """
-        ...
-    
-    @overload
-    def __init__(self, arg: lagrange.scene.LightList) -> None:
-        """
-        Copy constructor
-        """
-        ...
-    
-    def append(self, arg: lagrange.scene.Light, /) -> None:
-        """
-        Append `arg` to the end of the list.
-        """
-        ...
-    
-    def clear(self) -> None:
-        """
-        Remove all items from list.
-        """
-        ...
-    
-    def extend(self, arg: lagrange.scene.LightList, /) -> None:
-        """
-        Extend `self` by appending elements from `arg`.
-        """
-        ...
-    
-    def insert(self, arg0: int, arg1: lagrange.scene.Light, /) -> None:
-        """
-        Insert object `arg1` before index `arg0`.
-        """
-        ...
-    
-    def pop(self, index: int = -1) -> lagrange.scene.Light:
-        """
-        Remove and return item at `index` (default last).
-        """
-        ...
-    
-class Material:
-    """
-    None
-    """
-
-    class AlphaMode(Enum):
-        """
-        <attribute '__doc__' of 'AlphaMode' objects>
-        """
-    
-        Blend: Any
-        
-        Mask: Any
-        
-        Opaque: Any
-        
-    def __init__(self) -> None:
-        ...
-    
-    @property
-    def alpha_cutoff(self) -> float:
-        ...
-    @alpha_cutoff.setter
-    def alpha_cutoff(self, arg: float, /) -> None:
-        ...
-    
-    @property
-    def alpha_mode(self) -> lagrange.scene.Material.AlphaMode:
-        ...
-    @alpha_mode.setter
-    def alpha_mode(self, arg: lagrange.scene.Material.AlphaMode, /) -> None:
-        ...
-    
-    @property
-    def base_color_texture(self) -> lagrange.scene.TextureInfo:
-        ...
-    @base_color_texture.setter
-    def base_color_texture(self, arg: lagrange.scene.TextureInfo, /) -> None:
-        ...
-    
-    @property
-    def base_color_value(self) -> numpy.typing.NDArray:
-        ...
-    @base_color_value.setter
-    def base_color_value(self, arg: numpy.typing.NDArray, /) -> None:
-        ...
-    
-    @property
-    def double_sided(self) -> bool:
-        ...
-    @double_sided.setter
-    def double_sided(self, arg: bool, /) -> None:
-        ...
-    
-    @property
-    def emissive_texture(self) -> lagrange.scene.TextureInfo:
-        ...
-    @emissive_texture.setter
-    def emissive_texture(self, arg: lagrange.scene.TextureInfo, /) -> None:
-        ...
-    
-    @property
-    def emissive_value(self) -> numpy.typing.NDArray:
-        ...
-    @emissive_value.setter
-    def emissive_value(self, arg: numpy.typing.NDArray, /) -> None:
-        ...
-    
-    @property
-    def extensions(self) -> lagrange.scene.Extensions:
-        ...
-    @extensions.setter
-    def extensions(self, arg: lagrange.scene.Extensions, /) -> None:
-        ...
-    
-    @property
-    def metallic_roughness_texture(self) -> lagrange.scene.TextureInfo:
-        ...
-    @metallic_roughness_texture.setter
-    def metallic_roughness_texture(self, arg: lagrange.scene.TextureInfo, /) -> None:
-        ...
-    
-    @property
-    def metallic_value(self) -> float:
-        ...
-    @metallic_value.setter
-    def metallic_value(self, arg: float, /) -> None:
-        ...
-    
-    @property
-    def name(self) -> str:
-        ...
-    @name.setter
-    def name(self, arg: str, /) -> None:
-        ...
-    
-    @property
-    def normal_scale(self) -> float:
-        ...
-    @normal_scale.setter
-    def normal_scale(self, arg: float, /) -> None:
-        ...
-    
-    @property
-    def normal_texture(self) -> lagrange.scene.TextureInfo:
-        ...
-    @normal_texture.setter
-    def normal_texture(self, arg: lagrange.scene.TextureInfo, /) -> None:
-        ...
-    
-    @property
-    def occlusion_strength(self) -> float:
-        ...
-    @occlusion_strength.setter
-    def occlusion_strength(self, arg: float, /) -> None:
-        ...
-    
-    @property
-    def occlusion_texture(self) -> lagrange.scene.TextureInfo:
-        ...
-    @occlusion_texture.setter
-    def occlusion_texture(self, arg: lagrange.scene.TextureInfo, /) -> None:
-        ...
-    
-    @property
-    def roughness_value(self) -> float:
-        ...
-    @roughness_value.setter
-    def roughness_value(self, arg: float, /) -> None:
-        ...
-    
-class MaterialList:
-    """
-    None
-    """
-
-    def __init__(self, arg: Iterable[lagrange.scene.Material], /) -> None:
-        """
-        Construct from an iterable object
-        """
-        ...
-    
-    @overload
-    def __init__(self) -> None:
-        """
-        Default constructor
-        """
-        ...
-    
-    @overload
-    def __init__(self, arg: lagrange.scene.MaterialList) -> None:
-        """
-        Copy constructor
-        """
-        ...
-    
-    def append(self, arg: lagrange.scene.Material, /) -> None:
-        """
-        Append `arg` to the end of the list.
-        """
-        ...
-    
-    def clear(self) -> None:
-        """
-        Remove all items from list.
-        """
-        ...
-    
-    def extend(self, arg: lagrange.scene.MaterialList, /) -> None:
-        """
-        Extend `self` by appending elements from `arg`.
-        """
-        ...
-    
-    def insert(self, arg0: int, arg1: lagrange.scene.Material, /) -> None:
-        """
-        Insert object `arg1` before index `arg0`.
-        """
-        ...
-    
-    def pop(self, index: int = -1) -> lagrange.scene.Material:
-        """
-        Remove and return item at `index` (default last).
-        """
-        ...
-    
-class MeshInstance3D:
-    """
-    A single mesh instance in a scene
-    """
-
-    def __init__(self) -> None:
-        ...
-    
-    @property
-    def mesh_index(self) -> int:
-        ...
-    @mesh_index.setter
-    def mesh_index(self, arg: int, /) -> None:
-        ...
-    
-    @property
-    def transform(self) -> numpy.typing.NDArray:
-        ...
-    @transform.setter
-    def transform(self, arg: numpy.typing.NDArray, /) -> None:
-        ...
-    
-class Node:
-    """
-    None
-    """
-
-    def __init__(self) -> None:
-        ...
-    
-    @property
-    def cameras(self) -> lagrange.scene.ElementIdList:
-        ...
-    @cameras.setter
-    def cameras(self, arg: lagrange.scene.ElementIdList, /) -> None:
-        ...
-    
-    @property
-    def children(self) -> lagrange.scene.ElementIdList:
-        ...
-    @children.setter
-    def children(self, arg: lagrange.scene.ElementIdList, /) -> None:
-        ...
-    
-    @property
-    def extensions(self) -> lagrange.scene.Extensions:
-        ...
-    @extensions.setter
-    def extensions(self, arg: lagrange.scene.Extensions, /) -> None:
-        ...
-    
-    @property
-    def lights(self) -> lagrange.scene.ElementIdList:
-        ...
-    @lights.setter
-    def lights(self, arg: lagrange.scene.ElementIdList, /) -> None:
-        ...
-    
-    @property
-    def meshes(self) -> lagrange.scene.SceneMeshInstanceList:
-        ...
-    @meshes.setter
-    def meshes(self, arg: lagrange.scene.SceneMeshInstanceList, /) -> None:
-        ...
-    
-    @property
-    def name(self) -> str:
-        ...
-    @name.setter
-    def name(self, arg: str, /) -> None:
-        ...
-    
-    @property
-    def parent(self) -> int:
-        ...
-    @parent.setter
-    def parent(self, arg: int, /) -> None:
-        ...
-    
-    @property
-    def transform(self) -> numpy.typing.NDArray:
-        """
-        The affine transform associated with this node
-        """
-        ...
-    @transform.setter
-    def transform(self, arg: numpy.typing.NDArray, /) -> None:
-        """
-        The affine transform associated with this node
-        """
-        ...
-    
-class NodeList:
-    """
-    None
-    """
-
-    def __init__(self, arg: Iterable[lagrange.scene.Node], /) -> None:
-        """
-        Construct from an iterable object
-        """
-        ...
-    
-    @overload
-    def __init__(self) -> None:
-        """
-        Default constructor
-        """
-        ...
-    
-    @overload
-    def __init__(self, arg: lagrange.scene.NodeList) -> None:
-        """
-        Copy constructor
-        """
-        ...
-    
-    def append(self, arg: lagrange.scene.Node, /) -> None:
-        """
-        Append `arg` to the end of the list.
-        """
-        ...
-    
-    def clear(self) -> None:
-        """
-        Remove all items from list.
-        """
-        ...
-    
-    def extend(self, arg: lagrange.scene.NodeList, /) -> None:
-        """
-        Extend `self` by appending elements from `arg`.
-        """
-        ...
-    
-    def insert(self, arg0: int, arg1: lagrange.scene.Node, /) -> None:
-        """
-        Insert object `arg1` before index `arg0`.
-        """
-        ...
-    
-    def pop(self, index: int = -1) -> lagrange.scene.Node:
-        """
-        Remove and return item at `index` (default last).
-        """
-        ...
-    
-class RemeshingOptions:
-    """
-    None
-    """
-
-    def __init__(self) -> None:
-        ...
-    
-    @property
-    def facet_allocation_strategy(self) -> lagrange.scene.FacetAllocationStrategy:
-        ...
-    @facet_allocation_strategy.setter
-    def facet_allocation_strategy(self, arg: lagrange.scene.FacetAllocationStrategy, /) -> None:
-        ...
-    
-    @property
-    def min_facets(self) -> int:
-        ...
-    @min_facets.setter
-    def min_facets(self, arg: int, /) -> None:
-        ...
-    
-class Scene:
-    """
-    A 3D scene
-    """
-
-    def __init__(self) -> None:
-        ...
-    
-    def add(self, element: Union[lagrange.scene.Node, lagrange.core.SurfaceMesh, lagrange.scene.Image, lagrange.scene.Texture, lagrange.scene.Material, lagrange.scene.Light, lagrange.scene.Camera, lagrange.scene.Skeleton, lagrange.scene.Animation]) -> int:
-        """
-        Add an element to the scene.
-        
-        :param element: The element to add to the scene. E.g. node, mesh, image, texture, material, light, camera, skeleton, or animation.
-        
-        :returns: The id of the added element.
-        """
-        ...
-    
-    def add_child(self, parent_id: int, child_id: int) -> None:
-        """
-        Add a child node to a parent node.
-        
-        :param parent_id: The parent node id.
-        :param child_id: The child node id.
-        
-        :returns: The id of the added child node.
-        """
-        ...
-    
-    @property
-    def animations(self) -> lagrange.scene.AnimationList:
-        ...
-    @animations.setter
-    def animations(self, arg: lagrange.scene.AnimationList, /) -> None:
-        ...
-    
-    @property
-    def cameras(self) -> lagrange.scene.CameraList:
-        ...
-    @cameras.setter
-    def cameras(self, arg: lagrange.scene.CameraList, /) -> None:
-        ...
-    
-    @property
-    def extensions(self) -> lagrange.scene.Extensions:
-        ...
-    @extensions.setter
-    def extensions(self, arg: lagrange.scene.Extensions, /) -> None:
-        ...
-    
-    @property
-    def images(self) -> lagrange.scene.ImageList:
-        ...
-    @images.setter
-    def images(self, arg: lagrange.scene.ImageList, /) -> None:
-        ...
-    
-    @property
-    def lights(self) -> lagrange.scene.LightList:
-        ...
-    @lights.setter
-    def lights(self, arg: lagrange.scene.LightList, /) -> None:
-        ...
-    
-    @property
-    def materials(self) -> lagrange.scene.MaterialList:
-        ...
-    @materials.setter
-    def materials(self, arg: lagrange.scene.MaterialList, /) -> None:
-        ...
-    
-    @property
-    def meshes(self) -> lagrange.scene.SurfaceMeshList:
-        ...
-    @meshes.setter
-    def meshes(self, arg: lagrange.scene.SurfaceMeshList, /) -> None:
-        ...
-    
-    @property
-    def name(self) -> str:
-        ...
-    @name.setter
-    def name(self, arg: str, /) -> None:
-        ...
-    
-    @property
-    def nodes(self) -> lagrange.scene.NodeList:
-        ...
-    @nodes.setter
-    def nodes(self, arg: lagrange.scene.NodeList, /) -> None:
-        ...
-    
-    @property
-    def root_nodes(self) -> lagrange.scene.ElementIdList:
-        ...
-    @root_nodes.setter
-    def root_nodes(self, arg: lagrange.scene.ElementIdList, /) -> None:
-        ...
-    
-    @property
-    def skeletons(self) -> lagrange.scene.SkeletonList:
-        ...
-    @skeletons.setter
-    def skeletons(self, arg: lagrange.scene.SkeletonList, /) -> None:
-        ...
-    
-    @property
-    def textures(self) -> lagrange.scene.TextureList:
-        ...
-    @textures.setter
-    def textures(self, arg: lagrange.scene.TextureList, /) -> None:
-        ...
-    
-class SceneMeshInstance:
-    """
-    Mesh and material index of a node
-    """
-
-    def __init__(self) -> None:
-        ...
-    
-    @property
-    def materials(self) -> lagrange.scene.ElementIdList:
-        ...
-    @materials.setter
-    def materials(self, arg: lagrange.scene.ElementIdList, /) -> None:
-        ...
-    
-    @property
-    def mesh(self) -> int:
-        ...
-    @mesh.setter
-    def mesh(self, arg: int, /) -> None:
-        ...
-    
-class SceneMeshInstanceList:
-    """
-    None
-    """
-
-    def __init__(self, arg: Iterable[lagrange.scene.SceneMeshInstance], /) -> None:
-        """
-        Construct from an iterable object
-        """
-        ...
-    
-    @overload
-    def __init__(self) -> None:
-        """
-        Default constructor
-        """
-        ...
-    
-    @overload
-    def __init__(self, arg: lagrange.scene.SceneMeshInstanceList) -> None:
-        """
-        Copy constructor
-        """
-        ...
-    
-    def append(self, arg: lagrange.scene.SceneMeshInstance, /) -> None:
-        """
-        Append `arg` to the end of the list.
-        """
-        ...
-    
-    def clear(self) -> None:
-        """
-        Remove all items from list.
-        """
-        ...
-    
-    def extend(self, arg: lagrange.scene.SceneMeshInstanceList, /) -> None:
-        """
-        Extend `self` by appending elements from `arg`.
-        """
-        ...
-    
-    def insert(self, arg0: int, arg1: lagrange.scene.SceneMeshInstance, /) -> None:
-        """
-        Insert object `arg1` before index `arg0`.
-        """
-        ...
-    
-    def pop(self, index: int = -1) -> lagrange.scene.SceneMeshInstance:
-        """
-        Remove and return item at `index` (default last).
-        """
-        ...
-    
-class SimpleScene3D:
-    """
-    Simple scene container for instanced meshes
-    """
-
-    def __init__(self) -> None:
-        ...
-    
-    def add_instance(self, instance: lagrange.scene.MeshInstance3D) -> int:
-        ...
-    
-    def add_mesh(self, mesh: lagrange.core.SurfaceMesh) -> int:
-        ...
-    
-    def get_instance(self, mesh_index: int, instance_index: int) -> lagrange.scene.MeshInstance3D:
-        ...
-    
-    def get_mesh(self, mesh_index: int) -> lagrange.core.SurfaceMesh:
-        ...
-    
-    def num_instances(self, mesh_index: int) -> int:
-        ...
-    
-    @property
-    def num_meshes(self) -> int:
-        """
-        Number of meshes in the scene
-        """
-        ...
-    
-    def ref_mesh(self, mesh_index: int) -> lagrange.core.SurfaceMesh:
-        ...
-    
-    def reserve_instances(self, mesh_index: int, num_instances: int) -> None:
-        ...
-    
-    def reserve_meshes(self, num_meshes: int) -> None:
-        ...
-    
-    @property
-    def total_num_instances(self) -> int:
-        """
-        Total number of instances for all meshes in the scene
-        """
-        ...
-    
-class Skeleton:
-
-    def __init__(self) -> None:
-        ...
-    
-    @property
-    def extensions(self) -> lagrange.scene.Extensions:
-        ...
-    @extensions.setter
-    def extensions(self, arg: lagrange.scene.Extensions, /) -> None:
-        ...
-    
-    @property
-    def meshes(self) -> lagrange.scene.ElementIdList:
-        ...
-    @meshes.setter
-    def meshes(self, arg: lagrange.scene.ElementIdList, /) -> None:
-        ...
-    
-class SkeletonList:
-    """
-    None
-    """
-
-    def __init__(self, arg: Iterable[lagrange.scene.Skeleton], /) -> None:
-        """
-        Construct from an iterable object
-        """
-        ...
-    
-    @overload
-    def __init__(self) -> None:
-        """
-        Default constructor
-        """
-        ...
-    
-    @overload
-    def __init__(self, arg: lagrange.scene.SkeletonList) -> None:
-        """
-        Copy constructor
-        """
-        ...
-    
-    def append(self, arg: lagrange.scene.Skeleton, /) -> None:
-        """
-        Append `arg` to the end of the list.
-        """
-        ...
-    
-    def clear(self) -> None:
-        """
-        Remove all items from list.
-        """
-        ...
-    
-    def extend(self, arg: lagrange.scene.SkeletonList, /) -> None:
-        """
-        Extend `self` by appending elements from `arg`.
-        """
-        ...
-    
-    def insert(self, arg0: int, arg1: lagrange.scene.Skeleton, /) -> None:
-        """
-        Insert object `arg1` before index `arg0`.
-        """
-        ...
-    
-    def pop(self, index: int = -1) -> lagrange.scene.Skeleton:
-        """
-        Remove and return item at `index` (default last).
-        """
-        ...
-    
-class SurfaceMeshList:
-    """
-    None
-    """
-
-    def __init__(self, arg: Iterable[lagrange.core.SurfaceMesh], /) -> None:
-        """
-        Construct from an iterable object
-        """
-        ...
-    
-    @overload
-    def __init__(self) -> None:
-        """
-        Default constructor
-        """
-        ...
-    
-    @overload
-    def __init__(self, arg: lagrange.scene.SurfaceMeshList) -> None:
-        """
-        Copy constructor
-        """
-        ...
-    
-    def append(self, arg: lagrange.core.SurfaceMesh, /) -> None:
-        """
-        Append `arg` to the end of the list.
-        """
-        ...
-    
-    def clear(self) -> None:
-        """
-        Remove all items from list.
-        """
-        ...
-    
-    def extend(self, arg: lagrange.scene.SurfaceMeshList, /) -> None:
-        """
-        Extend `self` by appending elements from `arg`.
-        """
-        ...
-    
-    def insert(self, arg0: int, arg1: lagrange.core.SurfaceMesh, /) -> None:
-        """
-        Insert object `arg1` before index `arg0`.
-        """
-        ...
-    
-    def pop(self, index: int = -1) -> lagrange.core.SurfaceMesh:
-        """
-        Remove and return item at `index` (default last).
-        """
-        ...
-    
-class Texture:
-    """
-    Texture
-    """
-
-    class TextureFilter(Enum):
-        """
-        <attribute '__doc__' of 'TextureFilter' objects>
-        """
-    
-        Linear: Any
-        
-        LinearMipmapLinear: Any
-        
-        LinearMipmapNearest: Any
-        
-        Nearest: Any
-        
-        NearestMimpapNearest: Any
-        
-        NearestMipmapLinear: Any
-        
-        Undefined: Any
-        
-    class WrapMode(Enum):
-        """
-        <attribute '__doc__' of 'WrapMode' objects>
-        """
-    
-        Clamp: Any
-        
-        Decal: Any
-        
-        Mirror: Any
-        
-        Wrap: Any
-        
-    def __init__(self) -> None:
-        ...
-    
-    @property
-    def extensions(self) -> lagrange.scene.Extensions:
-        ...
-    @extensions.setter
-    def extensions(self, arg: lagrange.scene.Extensions, /) -> None:
-        ...
-    
-    @property
-    def image(self) -> int:
-        ...
-    @image.setter
-    def image(self, arg: int, /) -> None:
-        ...
-    
-    @property
-    def mag_filter(self) -> lagrange.scene.Texture.TextureFilter:
-        ...
-    @mag_filter.setter
-    def mag_filter(self, arg: lagrange.scene.Texture.TextureFilter, /) -> None:
-        ...
-    
-    @property
-    def min_filter(self) -> lagrange.scene.Texture.TextureFilter:
-        ...
-    @min_filter.setter
-    def min_filter(self, arg: lagrange.scene.Texture.TextureFilter, /) -> None:
-        ...
-    
-    @property
-    def name(self) -> str:
-        ...
-    @name.setter
-    def name(self, arg: str, /) -> None:
-        ...
-    
-    @property
-    def offset(self) -> numpy.typing.NDArray:
-        ...
-    @offset.setter
-    def offset(self, arg: numpy.typing.NDArray, /) -> None:
-        ...
-    
-    @property
-    def rotation(self) -> float:
-        ...
-    @rotation.setter
-    def rotation(self, arg: float, /) -> None:
-        ...
-    
-    @property
-    def scale(self) -> numpy.typing.NDArray:
-        ...
-    @scale.setter
-    def scale(self, arg: numpy.typing.NDArray, /) -> None:
-        ...
-    
-    @property
-    def wrap_u(self) -> lagrange.scene.Texture.WrapMode:
-        ...
-    @wrap_u.setter
-    def wrap_u(self, arg: lagrange.scene.Texture.WrapMode, /) -> None:
-        ...
-    
-    @property
-    def wrap_v(self) -> lagrange.scene.Texture.WrapMode:
-        ...
-    @wrap_v.setter
-    def wrap_v(self, arg: lagrange.scene.Texture.WrapMode, /) -> None:
-        ...
-    
-class TextureInfo:
-    """
-    None
-    """
-
-    def __init__(self) -> None:
-        ...
-    
-    @property
-    def index(self) -> int:
-        ...
-    @index.setter
-    def index(self, arg: int, /) -> None:
-        ...
-    
-    @property
-    def texcoord(self) -> int:
-        ...
-    @texcoord.setter
-    def texcoord(self, arg: int, /) -> None:
-        ...
-    
-class TextureList:
-    """
-    None
-    """
-
-    def __init__(self, arg: Iterable[lagrange.scene.Texture], /) -> None:
-        """
-        Construct from an iterable object
-        """
-        ...
-    
-    @overload
-    def __init__(self) -> None:
-        """
-        Default constructor
-        """
-        ...
-    
-    @overload
-    def __init__(self, arg: lagrange.scene.TextureList) -> None:
-        """
-        Copy constructor
-        """
-        ...
-    
-    def append(self, arg: lagrange.scene.Texture, /) -> None:
-        """
-        Append `arg` to the end of the list.
-        """
-        ...
-    
-    def clear(self) -> None:
-        """
-        Remove all items from list.
-        """
-        ...
-    
-    def extend(self, arg: lagrange.scene.TextureList, /) -> None:
-        """
-        Extend `self` by appending elements from `arg`.
-        """
-        ...
-    
-    def insert(self, arg0: int, arg1: lagrange.scene.Texture, /) -> None:
-        """
-        Insert object `arg1` before index `arg0`.
-        """
-        ...
-    
-    def pop(self, index: int = -1) -> lagrange.scene.Texture:
-        """
-        Remove and return item at `index` (default last).
-        """
-        ...
-    
-class ValueList:
-    """
-    None
-    """
-
-    def __init__(self, arg: Iterable[Value], /) -> None:
-        """
-        Construct from an iterable object
-        """
-        ...
-    
-    @overload
-    def __init__(self) -> None:
-        """
-        Default constructor
-        """
-        ...
-    
-    @overload
-    def __init__(self, arg: lagrange.scene.ValueList) -> None:
-        """
-        Copy constructor
-        """
-        ...
-    
-    def append(self, arg: Value, /) -> None:
-        """
-        Append `arg` to the end of the list.
-        """
-        ...
-    
-    def clear(self) -> None:
-        """
-        Remove all items from list.
-        """
-        ...
-    
-    def extend(self, arg: lagrange.scene.ValueList, /) -> None:
-        """
-        Extend `self` by appending elements from `arg`.
-        """
-        ...
-    
-    def insert(self, arg0: int, arg1: Value, /) -> None:
-        """
-        Insert object `arg1` before index `arg0`.
-        """
-        ...
-    
-    def pop(self, index: int = -1) -> Value:
-        """
-        Remove and return item at `index` (default last).
-        """
-        ...
-    
-class ValueMap:
-    """
-    None
-    """
-
-    class ItemView:
-        """
-        None
-        """
-    
-        def __init__(*args, **kwargs):
-            """
-            Initialize self.  See help(type(self)) for accurate signature.
-            """
-            ...
-        
-    class KeyView:
-        """
-        None
-        """
-    
-        def __init__(*args, **kwargs):
-            """
-            Initialize self.  See help(type(self)) for accurate signature.
-            """
-            ...
-        
-    class ValueView:
-        """
-        None
-        """
-    
-        def __init__(*args, **kwargs):
-            """
-            Initialize self.  See help(type(self)) for accurate signature.
-            """
-            ...
-        
-    def __init__(self, arg: dict[str, Value], /) -> None:
-        """
-        Construct from a dictionary
-        """
-        ...
-    
-    @overload
-    def __init__(self) -> None:
-        """
-        Default constructor
-        """
-        ...
-    
-    @overload
-    def __init__(self, arg: lagrange.scene.ValueMap) -> None:
-        """
-        Copy constructor
-        """
-        ...
-    
-    def clear(self) -> None:
-        """
-        Remove all items
-        """
-        ...
-    
-    def items(self) -> lagrange.scene.ValueMap.ItemView:
-        """
-        Returns an iterable view of the map's items.
-        """
-        ...
-    
-    def keys(self) -> lagrange.scene.ValueMap.KeyView:
-        """
-        Returns an iterable view of the map's keys.
-        """
-        ...
-    
-    def update(self, arg: lagrange.scene.ValueMap, /) -> None:
-        """
-        Update the map with element from `arg`
-        """
-        ...
-    
-    def values(self) -> lagrange.scene.ValueMap.ValueView:
-        """
-        Returns an iterable view of the map's values.
-        """
-        ...
-    
-class ValueUnorderedMap:
-    """
-    None
-    """
-
-    class ItemView:
-        """
-        None
-        """
-    
-        def __init__(*args, **kwargs):
-            """
-            Initialize self.  See help(type(self)) for accurate signature.
-            """
-            ...
-        
-    class KeyView:
-        """
-        None
-        """
-    
-        def __init__(*args, **kwargs):
-            """
-            Initialize self.  See help(type(self)) for accurate signature.
-            """
-            ...
-        
-    class ValueView:
-        """
-        None
-        """
-    
-        def __init__(*args, **kwargs):
-            """
-            Initialize self.  See help(type(self)) for accurate signature.
-            """
-            ...
-        
-    def __init__(self, arg: dict[str, Value], /) -> None:
-        """
-        Construct from a dictionary
-        """
-        ...
-    
-    @overload
-    def __init__(self) -> None:
-        """
-        Default constructor
-        """
-        ...
-    
-    @overload
-    def __init__(self, arg: lagrange.scene.ValueUnorderedMap) -> None:
-        """
-        Copy constructor
-        """
-        ...
-    
-    def clear(self) -> None:
-        """
-        Remove all items
-        """
-        ...
-    
-    def items(self) -> lagrange.scene.ValueUnorderedMap.ItemView:
-        """
-        Returns an iterable view of the map's items.
-        """
-        ...
-    
-    def keys(self) -> lagrange.scene.ValueUnorderedMap.KeyView:
-        """
-        Returns an iterable view of the map's keys.
-        """
-        ...
-    
-    def update(self, arg: lagrange.scene.ValueUnorderedMap, /) -> None:
-        """
-        Update the map with element from `arg`
-        """
-        ...
-    
-    def values(self) -> lagrange.scene.ValueUnorderedMap.ValueView:
-        """
-        Returns an iterable view of the map's values.
-        """
-        ...
-    
-def compute_global_node_transform(scene: lagrange.scene.Scene, node_idx: int) -> numpy.typing.NDArray:
-    """
-    Compute the global transform associated with a node.
-    
-    :param scene: The input node.
-    :param node_idx: The index of the taget node.
-    
-    :returns: The global transform of the target node, which is the combination of transforms from this node all the way to the root.
-    """
-    ...
-
-def mesh_to_simple_scene(mesh: lagrange.core.SurfaceMesh) -> lagrange.scene.SimpleScene3D:
-    """
-    Converts a single mesh into a simple scene with a single identity instance of the input mesh.
-    
-    :param mesh: Input mesh to convert.
-    
-    :return: Simple scene containing the input mesh.
-    """
-    ...
-
-def meshes_to_simple_scene(meshes: lagrange.scene.SurfaceMeshList) -> lagrange.scene.SimpleScene3D:
-    """
-    Converts a list of meshes into a simple scene with a single identity instance of each input mesh.
-    
-    :param meshes: Input meshes to convert.
-    
-    :return: Simple scene containing the input meshes.
-    """
-    ...
-
-def simple_scene_to_mesh(scene: lagrange.scene.SimpleScene3D, normalize_normals: bool = True, normalize_tangents_bitangents: bool = True, preserve_attributes: bool = True) -> lagrange.core.SurfaceMesh:
-    """
-    Converts a scene into a concatenated mesh with all the transforms applied.
-    
-    :param scene: Scene to convert.
-    :param normalize_normals: If enabled, normals are normalized after transformation.
-    :param normalize_tangents_bitangents: If enabled, tangents and bitangents are normalized after transformation.
-    :param preserve_attributes: Preserve shared attributes and map them to the output mesh.
-    
-    :return: Concatenated mesh.
-    """
-    ...
-
+from collections.abc import Iterable, Iterator
+import enum
+import os
+import pathlib
+from typing import Annotated, overload
+
+import lagrange.core
+from numpy.typing import ArrayLike
+
+
+class Animation:
+    def __init__(self) -> None: ...
+
+    def __repr__(self) -> str: ...
+
+    @property
+    def name(self) -> str: ...
+
+    @name.setter
+    def name(self, arg: str, /) -> None: ...
+
+    @property
+    def extensions(self) -> Extensions: ...
+
+    @extensions.setter
+    def extensions(self, arg: Extensions, /) -> None: ...
+
+class AnimationList:
+    @overload
+    def __init__(self) -> None:
+        """Default constructor"""
+
+    @overload
+    def __init__(self, arg: AnimationList) -> None:
+        """Copy constructor"""
+
+    @overload
+    def __init__(self, arg: Iterable[Animation], /) -> None:
+        """Construct from an iterable object"""
+
+    def __len__(self) -> int: ...
+
+    def __bool__(self) -> bool:
+        """Check whether the vector is nonempty"""
+
+    def __repr__(self) -> str: ...
+
+    def __iter__(self) -> Iterator[Animation]: ...
+
+    @overload
+    def __getitem__(self, arg: int, /) -> Animation: ...
+
+    @overload
+    def __getitem__(self, arg: slice, /) -> AnimationList: ...
+
+    def clear(self) -> None:
+        """Remove all items from list."""
+
+    def append(self, arg: Animation, /) -> None:
+        """Append `arg` to the end of the list."""
+
+    def insert(self, arg0: int, arg1: Animation, /) -> None:
+        """Insert object `arg1` before index `arg0`."""
+
+    def pop(self, index: int = -1) -> Animation:
+        """Remove and return item at `index` (default last)."""
+
+    def extend(self, arg: AnimationList, /) -> None:
+        """Extend `self` by appending elements from `arg`."""
+
+    @overload
+    def __setitem__(self, arg0: int, arg1: Animation, /) -> None: ...
+
+    @overload
+    def __setitem__(self, arg0: slice, arg1: AnimationList, /) -> None: ...
+
+    @overload
+    def __delitem__(self, arg: int, /) -> None: ...
+
+    @overload
+    def __delitem__(self, arg: slice, /) -> None: ...
+
+class BufferList:
+    @overload
+    def __init__(self) -> None:
+        """Default constructor"""
+
+    @overload
+    def __init__(self, arg: BufferList) -> None:
+        """Copy constructor"""
+
+    @overload
+    def __init__(self, arg: Iterable[int], /) -> None:
+        """Construct from an iterable object"""
+
+    def __len__(self) -> int: ...
+
+    def __bool__(self) -> bool:
+        """Check whether the vector is nonempty"""
+
+    def __repr__(self) -> str: ...
+
+    def __iter__(self) -> Iterator[int]: ...
+
+    @overload
+    def __getitem__(self, arg: int, /) -> int: ...
+
+    @overload
+    def __getitem__(self, arg: slice, /) -> BufferList: ...
+
+    def clear(self) -> None:
+        """Remove all items from list."""
+
+    def append(self, arg: int, /) -> None:
+        """Append `arg` to the end of the list."""
+
+    def insert(self, arg0: int, arg1: int, /) -> None:
+        """Insert object `arg1` before index `arg0`."""
+
+    def pop(self, index: int = -1) -> int:
+        """Remove and return item at `index` (default last)."""
+
+    def extend(self, arg: BufferList, /) -> None:
+        """Extend `self` by appending elements from `arg`."""
+
+    @overload
+    def __setitem__(self, arg0: int, arg1: int, /) -> None: ...
+
+    @overload
+    def __setitem__(self, arg0: slice, arg1: BufferList, /) -> None: ...
+
+    @overload
+    def __delitem__(self, arg: int, /) -> None: ...
+
+    @overload
+    def __delitem__(self, arg: slice, /) -> None: ...
+
+    def __eq__(self, arg: BufferList, /) -> bool: ...
+
+    def __ne__(self, arg: BufferList, /) -> bool: ...
+
+    @overload
+    def __contains__(self, arg: int, /) -> bool: ...
+
+    @overload
+    def __contains__(self, arg: object, /) -> bool: ...
+
+    def count(self, arg: int, /) -> int:
+        """Return number of occurrences of `arg`."""
+
+    def remove(self, arg: int, /) -> None:
+        """Remove first occurrence of `arg`."""
+
+class Camera:
+    """Camera"""
+
+    def __init__(self) -> None: ...
+
+    def __repr__(self) -> str: ...
+
+    @property
+    def name(self) -> str: ...
+
+    @name.setter
+    def name(self, arg: str, /) -> None: ...
+
+    @property
+    def position(self) -> Annotated[ArrayLike, dict(dtype='float32', shape=(3), order='C')]: ...
+
+    @position.setter
+    def position(self, arg: Annotated[ArrayLike, dict(dtype='float32', shape=(3), order='C')], /) -> None: ...
+
+    @property
+    def up(self) -> Annotated[ArrayLike, dict(dtype='float32', shape=(3), order='C')]: ...
+
+    @up.setter
+    def up(self, arg: Annotated[ArrayLike, dict(dtype='float32', shape=(3), order='C')], /) -> None: ...
+
+    @property
+    def look_at(self) -> Annotated[ArrayLike, dict(dtype='float32', shape=(3), order='C')]: ...
+
+    @look_at.setter
+    def look_at(self, arg: Annotated[ArrayLike, dict(dtype='float32', shape=(3), order='C')], /) -> None: ...
+
+    @property
+    def near_plane(self) -> float: ...
+
+    @near_plane.setter
+    def near_plane(self, arg: float, /) -> None: ...
+
+    @property
+    def far_plane(self) -> float: ...
+
+    @far_plane.setter
+    def far_plane(self, arg: float, /) -> None: ...
+
+    @property
+    def type(self) -> Camera.Type: ...
+
+    @type.setter
+    def type(self, arg: Camera.Type, /) -> None: ...
+
+    @property
+    def aspect_ratio(self) -> float: ...
+
+    @aspect_ratio.setter
+    def aspect_ratio(self, arg: float, /) -> None: ...
+
+    @property
+    def horizontal_fov(self) -> float: ...
+
+    @horizontal_fov.setter
+    def horizontal_fov(self, arg: float, /) -> None: ...
+
+    @property
+    def orthographic_width(self) -> float: ...
+
+    @orthographic_width.setter
+    def orthographic_width(self, arg: float, /) -> None: ...
+
+    @property
+    def get_vertical_fov(self) -> float: ...
+
+    @property
+    def set_horizontal_fov_from_vertical_fov(self, arg: float, /) -> None: ...
+
+    @property
+    def extensions(self) -> Extensions: ...
+
+    @extensions.setter
+    def extensions(self, arg: Extensions, /) -> None: ...
+
+    class Type(enum.Enum):
+        Perspective = 0
+
+        Orthographic = 1
+
+class CameraList:
+    @overload
+    def __init__(self) -> None:
+        """Default constructor"""
+
+    @overload
+    def __init__(self, arg: CameraList) -> None:
+        """Copy constructor"""
+
+    @overload
+    def __init__(self, arg: Iterable[Camera], /) -> None:
+        """Construct from an iterable object"""
+
+    def __len__(self) -> int: ...
+
+    def __bool__(self) -> bool:
+        """Check whether the vector is nonempty"""
+
+    def __repr__(self) -> str: ...
+
+    def __iter__(self) -> Iterator[Camera]: ...
+
+    @overload
+    def __getitem__(self, arg: int, /) -> Camera: ...
+
+    @overload
+    def __getitem__(self, arg: slice, /) -> CameraList: ...
+
+    def clear(self) -> None:
+        """Remove all items from list."""
+
+    def append(self, arg: Camera, /) -> None:
+        """Append `arg` to the end of the list."""
+
+    def insert(self, arg0: int, arg1: Camera, /) -> None:
+        """Insert object `arg1` before index `arg0`."""
+
+    def pop(self, index: int = -1) -> Camera:
+        """Remove and return item at `index` (default last)."""
+
+    def extend(self, arg: CameraList, /) -> None:
+        """Extend `self` by appending elements from `arg`."""
+
+    @overload
+    def __setitem__(self, arg0: int, arg1: Camera, /) -> None: ...
+
+    @overload
+    def __setitem__(self, arg0: slice, arg1: CameraList, /) -> None: ...
+
+    @overload
+    def __delitem__(self, arg: int, /) -> None: ...
+
+    @overload
+    def __delitem__(self, arg: slice, /) -> None: ...
+
+class ElementIdList:
+    @overload
+    def __init__(self) -> None:
+        """Default constructor"""
+
+    @overload
+    def __init__(self, arg: ElementIdList) -> None:
+        """Copy constructor"""
+
+    @overload
+    def __init__(self, arg: Iterable[int], /) -> None:
+        """Construct from an iterable object"""
+
+    def __len__(self) -> int: ...
+
+    def __bool__(self) -> bool:
+        """Check whether the vector is nonempty"""
+
+    def __repr__(self) -> str: ...
+
+    def __iter__(self) -> Iterator[int]: ...
+
+    @overload
+    def __getitem__(self, arg: int, /) -> int: ...
+
+    @overload
+    def __getitem__(self, arg: slice, /) -> ElementIdList: ...
+
+    def clear(self) -> None:
+        """Remove all items from list."""
+
+    def append(self, arg: int, /) -> None:
+        """Append `arg` to the end of the list."""
+
+    def insert(self, arg0: int, arg1: int, /) -> None:
+        """Insert object `arg1` before index `arg0`."""
+
+    def pop(self, index: int = -1) -> int:
+        """Remove and return item at `index` (default last)."""
+
+    def extend(self, arg: ElementIdList, /) -> None:
+        """Extend `self` by appending elements from `arg`."""
+
+    @overload
+    def __setitem__(self, arg0: int, arg1: int, /) -> None: ...
+
+    @overload
+    def __setitem__(self, arg0: slice, arg1: ElementIdList, /) -> None: ...
+
+    @overload
+    def __delitem__(self, arg: int, /) -> None: ...
+
+    @overload
+    def __delitem__(self, arg: slice, /) -> None: ...
+
+    def __eq__(self, arg: ElementIdList, /) -> bool: ...
+
+    def __ne__(self, arg: ElementIdList, /) -> bool: ...
+
+    @overload
+    def __contains__(self, arg: int, /) -> bool: ...
+
+    @overload
+    def __contains__(self, arg: object, /) -> bool: ...
+
+    def count(self, arg: int, /) -> int:
+        """Return number of occurrences of `arg`."""
+
+    def remove(self, arg: int, /) -> None:
+        """Remove first occurrence of `arg`."""
+
+class Extensions:
+    @property
+    def size(self) -> int: ...
+
+    @property
+    def empty(self) -> bool: ...
+
+    @property
+    def data(self) -> ValueUnorderedMap: ...
+
+    @data.setter
+    def data(self, arg: ValueUnorderedMap, /) -> None: ...
+
+class FacetAllocationStrategy(enum.Enum):
+    EvenSplit = 0
+
+    RelativeToMeshArea = 1
+
+    RelativeToNumFacets = 2
+
+    Synchronized = 3
+
+class Image:
+    def __init__(self) -> None: ...
+
+    @property
+    def name(self) -> str:
+        """Name of the image object"""
+
+    @name.setter
+    def name(self, arg: str, /) -> None: ...
+
+    @property
+    def image(self) -> ImageBuffer:
+        """Image buffer"""
+
+    @image.setter
+    def image(self, arg: ImageBuffer, /) -> None: ...
+
+    @property
+    def uri(self) -> pathlib.Path:
+        """URI of the image file"""
+
+    @uri.setter
+    def uri(self, arg: str | os.PathLike, /) -> None: ...
+
+    @property
+    def extensions(self) -> Extensions:
+        """Additional data associated with the image"""
+
+    @extensions.setter
+    def extensions(self, arg: Extensions, /) -> None: ...
+
+    def __repr__(self) -> str: ...
+
+class ImageBuffer:
+    def __init__(self) -> None: ...
+
+    @property
+    def width(self) -> int:
+        """Image width"""
+
+    @property
+    def height(self) -> int:
+        """Image height"""
+
+    @property
+    def num_channels(self) -> int:
+        """Number of channels in each pixel"""
+
+    @property
+    def data(self) -> object:
+        """Raw image data."""
+
+    @data.setter
+    def data(self, arg: Annotated[ArrayLike, dict(order='C', device='cpu')], /) -> None: ...
+
+    @property
+    def dtype(self) -> type | None:
+        """The element data type of the image buffer."""
+
+class ImageList:
+    @overload
+    def __init__(self) -> None:
+        """Default constructor"""
+
+    @overload
+    def __init__(self, arg: ImageList) -> None:
+        """Copy constructor"""
+
+    @overload
+    def __init__(self, arg: Iterable[Image], /) -> None:
+        """Construct from an iterable object"""
+
+    def __len__(self) -> int: ...
+
+    def __bool__(self) -> bool:
+        """Check whether the vector is nonempty"""
+
+    def __repr__(self) -> str: ...
+
+    def __iter__(self) -> Iterator[Image]: ...
+
+    @overload
+    def __getitem__(self, arg: int, /) -> Image: ...
+
+    @overload
+    def __getitem__(self, arg: slice, /) -> ImageList: ...
+
+    def clear(self) -> None:
+        """Remove all items from list."""
+
+    def append(self, arg: Image, /) -> None:
+        """Append `arg` to the end of the list."""
+
+    def insert(self, arg0: int, arg1: Image, /) -> None:
+        """Insert object `arg1` before index `arg0`."""
+
+    def pop(self, index: int = -1) -> Image:
+        """Remove and return item at `index` (default last)."""
+
+    def extend(self, arg: ImageList, /) -> None:
+        """Extend `self` by appending elements from `arg`."""
+
+    @overload
+    def __setitem__(self, arg0: int, arg1: Image, /) -> None: ...
+
+    @overload
+    def __setitem__(self, arg0: slice, arg1: ImageList, /) -> None: ...
+
+    @overload
+    def __delitem__(self, arg: int, /) -> None: ...
+
+    @overload
+    def __delitem__(self, arg: slice, /) -> None: ...
+
+class Light:
+    """Light"""
+
+    def __init__(self) -> None: ...
+
+    def __repr__(self) -> str: ...
+
+    @property
+    def name(self) -> str: ...
+
+    @name.setter
+    def name(self, arg: str, /) -> None: ...
+
+    @property
+    def type(self) -> Light.Type: ...
+
+    @type.setter
+    def type(self, arg: Light.Type, /) -> None: ...
+
+    @property
+    def position(self) -> Annotated[ArrayLike, dict(dtype='float32', shape=(3), order='C')]: ...
+
+    @position.setter
+    def position(self, arg: Annotated[ArrayLike, dict(dtype='float32', shape=(3), order='C')], /) -> None: ...
+
+    @property
+    def direction(self) -> Annotated[ArrayLike, dict(dtype='float32', shape=(3), order='C')]: ...
+
+    @direction.setter
+    def direction(self, arg: Annotated[ArrayLike, dict(dtype='float32', shape=(3), order='C')], /) -> None: ...
+
+    @property
+    def up(self) -> Annotated[ArrayLike, dict(dtype='float32', shape=(3), order='C')]: ...
+
+    @up.setter
+    def up(self, arg: Annotated[ArrayLike, dict(dtype='float32', shape=(3), order='C')], /) -> None: ...
+
+    @property
+    def intensity(self) -> float: ...
+
+    @intensity.setter
+    def intensity(self, arg: float, /) -> None: ...
+
+    @property
+    def attenuation_constant(self) -> float: ...
+
+    @attenuation_constant.setter
+    def attenuation_constant(self, arg: float, /) -> None: ...
+
+    @property
+    def attenuation_linear(self) -> float: ...
+
+    @attenuation_linear.setter
+    def attenuation_linear(self, arg: float, /) -> None: ...
+
+    @property
+    def attenuation_quadratic(self) -> float: ...
+
+    @attenuation_quadratic.setter
+    def attenuation_quadratic(self, arg: float, /) -> None: ...
+
+    @property
+    def attenuation_cubic(self) -> float: ...
+
+    @attenuation_cubic.setter
+    def attenuation_cubic(self, arg: float, /) -> None: ...
+
+    @property
+    def range(self) -> float: ...
+
+    @range.setter
+    def range(self, arg: float, /) -> None: ...
+
+    @property
+    def color_diffuse(self) -> Annotated[ArrayLike, dict(dtype='float32', shape=(3), order='C')]: ...
+
+    @color_diffuse.setter
+    def color_diffuse(self, arg: Annotated[ArrayLike, dict(dtype='float32', shape=(3), order='C')], /) -> None: ...
+
+    @property
+    def color_specular(self) -> Annotated[ArrayLike, dict(dtype='float32', shape=(3), order='C')]: ...
+
+    @color_specular.setter
+    def color_specular(self, arg: Annotated[ArrayLike, dict(dtype='float32', shape=(3), order='C')], /) -> None: ...
+
+    @property
+    def color_ambient(self) -> Annotated[ArrayLike, dict(dtype='float32', shape=(3), order='C')]: ...
+
+    @color_ambient.setter
+    def color_ambient(self, arg: Annotated[ArrayLike, dict(dtype='float32', shape=(3), order='C')], /) -> None: ...
+
+    @property
+    def angle_inner_cone(self) -> float: ...
+
+    @angle_inner_cone.setter
+    def angle_inner_cone(self, arg: float, /) -> None: ...
+
+    @property
+    def angle_outer_cone(self) -> float: ...
+
+    @angle_outer_cone.setter
+    def angle_outer_cone(self, arg: float, /) -> None: ...
+
+    @property
+    def size(self) -> Annotated[ArrayLike, dict(dtype='float32', shape=(2), order='C')]: ...
+
+    @size.setter
+    def size(self, arg: Annotated[ArrayLike, dict(dtype='float32', shape=(2), order='C')], /) -> None: ...
+
+    @property
+    def extensions(self) -> Extensions: ...
+
+    @extensions.setter
+    def extensions(self, arg: Extensions, /) -> None: ...
+
+    class Type(enum.Enum):
+        Undefined = 0
+
+        Directional = 1
+
+        Point = 2
+
+        Spot = 3
+
+        Ambient = 4
+
+        Area = 5
+
+class LightList:
+    @overload
+    def __init__(self) -> None:
+        """Default constructor"""
+
+    @overload
+    def __init__(self, arg: LightList) -> None:
+        """Copy constructor"""
+
+    @overload
+    def __init__(self, arg: Iterable[Light], /) -> None:
+        """Construct from an iterable object"""
+
+    def __len__(self) -> int: ...
+
+    def __bool__(self) -> bool:
+        """Check whether the vector is nonempty"""
+
+    def __repr__(self) -> str: ...
+
+    def __iter__(self) -> Iterator[Light]: ...
+
+    @overload
+    def __getitem__(self, arg: int, /) -> Light: ...
+
+    @overload
+    def __getitem__(self, arg: slice, /) -> LightList: ...
+
+    def clear(self) -> None:
+        """Remove all items from list."""
+
+    def append(self, arg: Light, /) -> None:
+        """Append `arg` to the end of the list."""
+
+    def insert(self, arg0: int, arg1: Light, /) -> None:
+        """Insert object `arg1` before index `arg0`."""
+
+    def pop(self, index: int = -1) -> Light:
+        """Remove and return item at `index` (default last)."""
+
+    def extend(self, arg: LightList, /) -> None:
+        """Extend `self` by appending elements from `arg`."""
+
+    @overload
+    def __setitem__(self, arg0: int, arg1: Light, /) -> None: ...
+
+    @overload
+    def __setitem__(self, arg0: slice, arg1: LightList, /) -> None: ...
+
+    @overload
+    def __delitem__(self, arg: int, /) -> None: ...
+
+    @overload
+    def __delitem__(self, arg: slice, /) -> None: ...
+
+class Material:
+    def __init__(self) -> None: ...
+
+    def __repr__(self) -> str: ...
+
+    @property
+    def name(self) -> str: ...
+
+    @name.setter
+    def name(self, arg: str, /) -> None: ...
+
+    @property
+    def base_color_value(self) -> Annotated[ArrayLike, dict(dtype='float32', shape=(4), order='C')]: ...
+
+    @base_color_value.setter
+    def base_color_value(self, arg: Annotated[ArrayLike, dict(dtype='float32', shape=(4), order='C')], /) -> None: ...
+
+    @property
+    def base_color_texture(self) -> TextureInfo: ...
+
+    @base_color_texture.setter
+    def base_color_texture(self, arg: TextureInfo, /) -> None: ...
+
+    @property
+    def alpha_mode(self) -> Material.AlphaMode: ...
+
+    @alpha_mode.setter
+    def alpha_mode(self, arg: Material.AlphaMode, /) -> None: ...
+
+    @property
+    def alpha_cutoff(self) -> float: ...
+
+    @alpha_cutoff.setter
+    def alpha_cutoff(self, arg: float, /) -> None: ...
+
+    @property
+    def emissive_value(self) -> Annotated[ArrayLike, dict(dtype='float32', shape=(3), order='C')]: ...
+
+    @emissive_value.setter
+    def emissive_value(self, arg: Annotated[ArrayLike, dict(dtype='float32', shape=(3), order='C')], /) -> None: ...
+
+    @property
+    def emissive_texture(self) -> TextureInfo: ...
+
+    @emissive_texture.setter
+    def emissive_texture(self, arg: TextureInfo, /) -> None: ...
+
+    @property
+    def metallic_value(self) -> float: ...
+
+    @metallic_value.setter
+    def metallic_value(self, arg: float, /) -> None: ...
+
+    @property
+    def roughness_value(self) -> float: ...
+
+    @roughness_value.setter
+    def roughness_value(self, arg: float, /) -> None: ...
+
+    @property
+    def metallic_roughness_texture(self) -> TextureInfo: ...
+
+    @metallic_roughness_texture.setter
+    def metallic_roughness_texture(self, arg: TextureInfo, /) -> None: ...
+
+    @property
+    def normal_texture(self) -> TextureInfo: ...
+
+    @normal_texture.setter
+    def normal_texture(self, arg: TextureInfo, /) -> None: ...
+
+    @property
+    def normal_scale(self) -> float: ...
+
+    @normal_scale.setter
+    def normal_scale(self, arg: float, /) -> None: ...
+
+    @property
+    def occlusion_texture(self) -> TextureInfo: ...
+
+    @occlusion_texture.setter
+    def occlusion_texture(self, arg: TextureInfo, /) -> None: ...
+
+    @property
+    def occlusion_strength(self) -> float: ...
+
+    @occlusion_strength.setter
+    def occlusion_strength(self, arg: float, /) -> None: ...
+
+    @property
+    def double_sided(self) -> bool: ...
+
+    @double_sided.setter
+    def double_sided(self, arg: bool, /) -> None: ...
+
+    @property
+    def extensions(self) -> Extensions: ...
+
+    @extensions.setter
+    def extensions(self, arg: Extensions, /) -> None: ...
+
+    class AlphaMode(enum.Enum):
+        Opaque = 0
+
+        Mask = 1
+
+        Blend = 2
+
+class MaterialList:
+    @overload
+    def __init__(self) -> None:
+        """Default constructor"""
+
+    @overload
+    def __init__(self, arg: MaterialList) -> None:
+        """Copy constructor"""
+
+    @overload
+    def __init__(self, arg: Iterable[Material], /) -> None:
+        """Construct from an iterable object"""
+
+    def __len__(self) -> int: ...
+
+    def __bool__(self) -> bool:
+        """Check whether the vector is nonempty"""
+
+    def __repr__(self) -> str: ...
+
+    def __iter__(self) -> Iterator[Material]: ...
+
+    @overload
+    def __getitem__(self, arg: int, /) -> Material: ...
+
+    @overload
+    def __getitem__(self, arg: slice, /) -> MaterialList: ...
+
+    def clear(self) -> None:
+        """Remove all items from list."""
+
+    def append(self, arg: Material, /) -> None:
+        """Append `arg` to the end of the list."""
+
+    def insert(self, arg0: int, arg1: Material, /) -> None:
+        """Insert object `arg1` before index `arg0`."""
+
+    def pop(self, index: int = -1) -> Material:
+        """Remove and return item at `index` (default last)."""
+
+    def extend(self, arg: MaterialList, /) -> None:
+        """Extend `self` by appending elements from `arg`."""
+
+    @overload
+    def __setitem__(self, arg0: int, arg1: Material, /) -> None: ...
+
+    @overload
+    def __setitem__(self, arg0: slice, arg1: MaterialList, /) -> None: ...
+
+    @overload
+    def __delitem__(self, arg: int, /) -> None: ...
+
+    @overload
+    def __delitem__(self, arg: slice, /) -> None: ...
+
+class MeshInstance3D:
+    """A single mesh instance in a scene"""
+
+    def __init__(self) -> None: ...
+
+    @property
+    def mesh_index(self) -> int: ...
+
+    @mesh_index.setter
+    def mesh_index(self, arg: int, /) -> None: ...
+
+    @property
+    def transform(self) -> Annotated[ArrayLike, dict(dtype='float64', order='C', device='cpu')]: ...
+
+    @transform.setter
+    def transform(self, arg: Annotated[ArrayLike, dict(dtype='float64', order='C', device='cpu')], /) -> None: ...
+
+class Node:
+    def __init__(self) -> None: ...
+
+    def __repr__(self) -> str: ...
+
+    @property
+    def name(self) -> str: ...
+
+    @name.setter
+    def name(self, arg: str, /) -> None: ...
+
+    @property
+    def transform(self) -> Annotated[ArrayLike, dict(dtype='float32', order='F', shape=(4, 4))]:
+        """The affine transform associated with this node"""
+
+    @transform.setter
+    def transform(self, arg: Annotated[ArrayLike, dict(dtype='float32', writable=False, shape=(4, 4))], /) -> None: ...
+
+    @property
+    def parent(self) -> int: ...
+
+    @parent.setter
+    def parent(self, arg: int, /) -> None: ...
+
+    @property
+    def children(self) -> ElementIdList: ...
+
+    @children.setter
+    def children(self, arg: ElementIdList, /) -> None: ...
+
+    @property
+    def meshes(self) -> SceneMeshInstanceList: ...
+
+    @meshes.setter
+    def meshes(self, arg: SceneMeshInstanceList, /) -> None: ...
+
+    @property
+    def cameras(self) -> ElementIdList: ...
+
+    @cameras.setter
+    def cameras(self, arg: ElementIdList, /) -> None: ...
+
+    @property
+    def lights(self) -> ElementIdList: ...
+
+    @lights.setter
+    def lights(self, arg: ElementIdList, /) -> None: ...
+
+    @property
+    def extensions(self) -> Extensions: ...
+
+    @extensions.setter
+    def extensions(self, arg: Extensions, /) -> None: ...
+
+class NodeList:
+    @overload
+    def __init__(self) -> None:
+        """Default constructor"""
+
+    @overload
+    def __init__(self, arg: NodeList) -> None:
+        """Copy constructor"""
+
+    @overload
+    def __init__(self, arg: Iterable[Node], /) -> None:
+        """Construct from an iterable object"""
+
+    def __len__(self) -> int: ...
+
+    def __bool__(self) -> bool:
+        """Check whether the vector is nonempty"""
+
+    def __repr__(self) -> str: ...
+
+    def __iter__(self) -> Iterator[Node]: ...
+
+    @overload
+    def __getitem__(self, arg: int, /) -> Node: ...
+
+    @overload
+    def __getitem__(self, arg: slice, /) -> NodeList: ...
+
+    def clear(self) -> None:
+        """Remove all items from list."""
+
+    def append(self, arg: Node, /) -> None:
+        """Append `arg` to the end of the list."""
+
+    def insert(self, arg0: int, arg1: Node, /) -> None:
+        """Insert object `arg1` before index `arg0`."""
+
+    def pop(self, index: int = -1) -> Node:
+        """Remove and return item at `index` (default last)."""
+
+    def extend(self, arg: NodeList, /) -> None:
+        """Extend `self` by appending elements from `arg`."""
+
+    @overload
+    def __setitem__(self, arg0: int, arg1: Node, /) -> None: ...
+
+    @overload
+    def __setitem__(self, arg0: slice, arg1: NodeList, /) -> None: ...
+
+    @overload
+    def __delitem__(self, arg: int, /) -> None: ...
+
+    @overload
+    def __delitem__(self, arg: slice, /) -> None: ...
+
+class RemeshingOptions:
+    def __init__(self) -> None: ...
+
+    @property
+    def facet_allocation_strategy(self) -> FacetAllocationStrategy: ...
+
+    @facet_allocation_strategy.setter
+    def facet_allocation_strategy(self, arg: FacetAllocationStrategy, /) -> None: ...
+
+    @property
+    def min_facets(self) -> int: ...
+
+    @min_facets.setter
+    def min_facets(self, arg: int, /) -> None: ...
+
+class Scene:
+    """A 3D scene"""
+
+    def __init__(self) -> None: ...
+
+    def __repr__(self) -> str: ...
+
+    @property
+    def name(self) -> str: ...
+
+    @name.setter
+    def name(self, arg: str, /) -> None: ...
+
+    @property
+    def nodes(self) -> NodeList: ...
+
+    @nodes.setter
+    def nodes(self, arg: NodeList, /) -> None: ...
+
+    @property
+    def root_nodes(self) -> ElementIdList: ...
+
+    @root_nodes.setter
+    def root_nodes(self, arg: ElementIdList, /) -> None: ...
+
+    @property
+    def meshes(self) -> SurfaceMeshList: ...
+
+    @meshes.setter
+    def meshes(self, arg: SurfaceMeshList, /) -> None: ...
+
+    @property
+    def images(self) -> ImageList: ...
+
+    @images.setter
+    def images(self, arg: ImageList, /) -> None: ...
+
+    @property
+    def textures(self) -> TextureList: ...
+
+    @textures.setter
+    def textures(self, arg: TextureList, /) -> None: ...
+
+    @property
+    def materials(self) -> MaterialList: ...
+
+    @materials.setter
+    def materials(self, arg: MaterialList, /) -> None: ...
+
+    @property
+    def lights(self) -> LightList: ...
+
+    @lights.setter
+    def lights(self, arg: LightList, /) -> None: ...
+
+    @property
+    def cameras(self) -> CameraList: ...
+
+    @cameras.setter
+    def cameras(self, arg: CameraList, /) -> None: ...
+
+    @property
+    def skeletons(self) -> SkeletonList: ...
+
+    @skeletons.setter
+    def skeletons(self, arg: SkeletonList, /) -> None: ...
+
+    @property
+    def animations(self) -> AnimationList: ...
+
+    @animations.setter
+    def animations(self, arg: AnimationList, /) -> None: ...
+
+    @property
+    def extensions(self) -> Extensions: ...
+
+    @extensions.setter
+    def extensions(self, arg: Extensions, /) -> None: ...
+
+    def add(self, element: Node | lagrange.core.SurfaceMesh | Image | Texture | Material | Light | Camera | Skeleton | Animation) -> int:
+        """
+        Add an element to the scene.
+
+        :param element: The element to add to the scene. E.g. node, mesh, image, texture, material, light, camera, skeleton, or animation.
+
+        :returns: The id of the added element.
+        """
+
+    def add_child(self, parent_id: int, child_id: int) -> None:
+        """
+        Add a child node to a parent node.
+
+        :param parent_id: The parent node id.
+        :param child_id: The child node id.
+
+        :returns: The id of the added child node.
+        """
+
+class SceneMeshInstance:
+    """Mesh and material index of a node"""
+
+    def __init__(self) -> None: ...
+
+    @property
+    def mesh(self) -> int: ...
+
+    @mesh.setter
+    def mesh(self, arg: int, /) -> None: ...
+
+    @property
+    def materials(self) -> ElementIdList: ...
+
+    @materials.setter
+    def materials(self, arg: ElementIdList, /) -> None: ...
+
+class SceneMeshInstanceList:
+    @overload
+    def __init__(self) -> None:
+        """Default constructor"""
+
+    @overload
+    def __init__(self, arg: SceneMeshInstanceList) -> None:
+        """Copy constructor"""
+
+    @overload
+    def __init__(self, arg: Iterable[SceneMeshInstance], /) -> None:
+        """Construct from an iterable object"""
+
+    def __len__(self) -> int: ...
+
+    def __bool__(self) -> bool:
+        """Check whether the vector is nonempty"""
+
+    def __repr__(self) -> str: ...
+
+    def __iter__(self) -> Iterator[SceneMeshInstance]: ...
+
+    @overload
+    def __getitem__(self, arg: int, /) -> SceneMeshInstance: ...
+
+    @overload
+    def __getitem__(self, arg: slice, /) -> SceneMeshInstanceList: ...
+
+    def clear(self) -> None:
+        """Remove all items from list."""
+
+    def append(self, arg: SceneMeshInstance, /) -> None:
+        """Append `arg` to the end of the list."""
+
+    def insert(self, arg0: int, arg1: SceneMeshInstance, /) -> None:
+        """Insert object `arg1` before index `arg0`."""
+
+    def pop(self, index: int = -1) -> SceneMeshInstance:
+        """Remove and return item at `index` (default last)."""
+
+    def extend(self, arg: SceneMeshInstanceList, /) -> None:
+        """Extend `self` by appending elements from `arg`."""
+
+    @overload
+    def __setitem__(self, arg0: int, arg1: SceneMeshInstance, /) -> None: ...
+
+    @overload
+    def __setitem__(self, arg0: slice, arg1: SceneMeshInstanceList, /) -> None: ...
+
+    @overload
+    def __delitem__(self, arg: int, /) -> None: ...
+
+    @overload
+    def __delitem__(self, arg: slice, /) -> None: ...
+
+class SimpleScene3D:
+    """Simple scene container for instanced meshes"""
+
+    def __init__(self) -> None: ...
+
+    @property
+    def num_meshes(self) -> int:
+        """Number of meshes in the scene"""
+
+    def num_instances(self, mesh_index: int) -> int: ...
+
+    @property
+    def total_num_instances(self) -> int:
+        """Total number of instances for all meshes in the scene"""
+
+    def get_mesh(self, mesh_index: int) -> lagrange.core.SurfaceMesh: ...
+
+    def ref_mesh(self, mesh_index: int) -> lagrange.core.SurfaceMesh: ...
+
+    def get_instance(self, mesh_index: int, instance_index: int) -> MeshInstance3D: ...
+
+    def reserve_meshes(self, num_meshes: int) -> None: ...
+
+    def add_mesh(self, mesh: lagrange.core.SurfaceMesh) -> int: ...
+
+    def reserve_instances(self, mesh_index: int, num_instances: int) -> None: ...
+
+    def add_instance(self, instance: MeshInstance3D) -> int: ...
+
+class Skeleton:
+    def __init__(self) -> None: ...
+
+    @property
+    def meshes(self) -> ElementIdList: ...
+
+    @meshes.setter
+    def meshes(self, arg: ElementIdList, /) -> None: ...
+
+    @property
+    def extensions(self) -> Extensions: ...
+
+    @extensions.setter
+    def extensions(self, arg: Extensions, /) -> None: ...
+
+class SkeletonList:
+    @overload
+    def __init__(self) -> None:
+        """Default constructor"""
+
+    @overload
+    def __init__(self, arg: SkeletonList) -> None:
+        """Copy constructor"""
+
+    @overload
+    def __init__(self, arg: Iterable[Skeleton], /) -> None:
+        """Construct from an iterable object"""
+
+    def __len__(self) -> int: ...
+
+    def __bool__(self) -> bool:
+        """Check whether the vector is nonempty"""
+
+    def __repr__(self) -> str: ...
+
+    def __iter__(self) -> Iterator[Skeleton]: ...
+
+    @overload
+    def __getitem__(self, arg: int, /) -> Skeleton: ...
+
+    @overload
+    def __getitem__(self, arg: slice, /) -> SkeletonList: ...
+
+    def clear(self) -> None:
+        """Remove all items from list."""
+
+    def append(self, arg: Skeleton, /) -> None:
+        """Append `arg` to the end of the list."""
+
+    def insert(self, arg0: int, arg1: Skeleton, /) -> None:
+        """Insert object `arg1` before index `arg0`."""
+
+    def pop(self, index: int = -1) -> Skeleton:
+        """Remove and return item at `index` (default last)."""
+
+    def extend(self, arg: SkeletonList, /) -> None:
+        """Extend `self` by appending elements from `arg`."""
+
+    @overload
+    def __setitem__(self, arg0: int, arg1: Skeleton, /) -> None: ...
+
+    @overload
+    def __setitem__(self, arg0: slice, arg1: SkeletonList, /) -> None: ...
+
+    @overload
+    def __delitem__(self, arg: int, /) -> None: ...
+
+    @overload
+    def __delitem__(self, arg: slice, /) -> None: ...
+
+class SurfaceMeshList:
+    @overload
+    def __init__(self) -> None:
+        """Default constructor"""
+
+    @overload
+    def __init__(self, arg: SurfaceMeshList) -> None:
+        """Copy constructor"""
+
+    @overload
+    def __init__(self, arg: Iterable[lagrange.core.SurfaceMesh], /) -> None:
+        """Construct from an iterable object"""
+
+    def __len__(self) -> int: ...
+
+    def __bool__(self) -> bool:
+        """Check whether the vector is nonempty"""
+
+    def __repr__(self) -> str: ...
+
+    def __iter__(self) -> Iterator[lagrange.core.SurfaceMesh]: ...
+
+    @overload
+    def __getitem__(self, arg: int, /) -> lagrange.core.SurfaceMesh: ...
+
+    @overload
+    def __getitem__(self, arg: slice, /) -> SurfaceMeshList: ...
+
+    def clear(self) -> None:
+        """Remove all items from list."""
+
+    def append(self, arg: lagrange.core.SurfaceMesh, /) -> None:
+        """Append `arg` to the end of the list."""
+
+    def insert(self, arg0: int, arg1: lagrange.core.SurfaceMesh, /) -> None:
+        """Insert object `arg1` before index `arg0`."""
+
+    def pop(self, index: int = -1) -> lagrange.core.SurfaceMesh:
+        """Remove and return item at `index` (default last)."""
+
+    def extend(self, arg: SurfaceMeshList, /) -> None:
+        """Extend `self` by appending elements from `arg`."""
+
+    @overload
+    def __setitem__(self, arg0: int, arg1: lagrange.core.SurfaceMesh, /) -> None: ...
+
+    @overload
+    def __setitem__(self, arg0: slice, arg1: SurfaceMeshList, /) -> None: ...
+
+    @overload
+    def __delitem__(self, arg: int, /) -> None: ...
+
+    @overload
+    def __delitem__(self, arg: slice, /) -> None: ...
+
+class Texture:
+    """Texture"""
+
+    def __init__(self) -> None: ...
+
+    def __repr__(self) -> str: ...
+
+    @property
+    def name(self) -> str: ...
+
+    @name.setter
+    def name(self, arg: str, /) -> None: ...
+
+    @property
+    def image(self) -> int: ...
+
+    @image.setter
+    def image(self, arg: int, /) -> None: ...
+
+    @property
+    def mag_filter(self) -> Texture.TextureFilter: ...
+
+    @mag_filter.setter
+    def mag_filter(self, arg: Texture.TextureFilter, /) -> None: ...
+
+    @property
+    def min_filter(self) -> Texture.TextureFilter: ...
+
+    @min_filter.setter
+    def min_filter(self, arg: Texture.TextureFilter, /) -> None: ...
+
+    @property
+    def wrap_u(self) -> Texture.WrapMode: ...
+
+    @wrap_u.setter
+    def wrap_u(self, arg: Texture.WrapMode, /) -> None: ...
+
+    @property
+    def wrap_v(self) -> Texture.WrapMode: ...
+
+    @wrap_v.setter
+    def wrap_v(self, arg: Texture.WrapMode, /) -> None: ...
+
+    @property
+    def scale(self) -> Annotated[ArrayLike, dict(dtype='float32', shape=(2), order='C')]: ...
+
+    @scale.setter
+    def scale(self, arg: Annotated[ArrayLike, dict(dtype='float32', shape=(2), order='C')], /) -> None: ...
+
+    @property
+    def offset(self) -> Annotated[ArrayLike, dict(dtype='float32', shape=(2), order='C')]: ...
+
+    @offset.setter
+    def offset(self, arg: Annotated[ArrayLike, dict(dtype='float32', shape=(2), order='C')], /) -> None: ...
+
+    @property
+    def rotation(self) -> float: ...
+
+    @rotation.setter
+    def rotation(self, arg: float, /) -> None: ...
+
+    @property
+    def extensions(self) -> Extensions: ...
+
+    @extensions.setter
+    def extensions(self, arg: Extensions, /) -> None: ...
+
+    class WrapMode(enum.Enum):
+        Wrap = 0
+
+        Clamp = 1
+
+        Decal = 2
+
+        Mirror = 3
+
+    class TextureFilter(enum.Enum):
+        Undefined = 0
+
+        Nearest = 9728
+
+        Linear = 9729
+
+        NearestMimpapNearest = 9984
+
+        LinearMipmapNearest = 9985
+
+        NearestMipmapLinear = 9986
+
+        LinearMipmapLinear = 9987
+
+class TextureInfo:
+    def __init__(self) -> None: ...
+
+    @property
+    def index(self) -> int: ...
+
+    @index.setter
+    def index(self, arg: int, /) -> None: ...
+
+    @property
+    def texcoord(self) -> int: ...
+
+    @texcoord.setter
+    def texcoord(self, arg: int, /) -> None: ...
+
+class TextureList:
+    @overload
+    def __init__(self) -> None:
+        """Default constructor"""
+
+    @overload
+    def __init__(self, arg: TextureList) -> None:
+        """Copy constructor"""
+
+    @overload
+    def __init__(self, arg: Iterable[Texture], /) -> None:
+        """Construct from an iterable object"""
+
+    def __len__(self) -> int: ...
+
+    def __bool__(self) -> bool:
+        """Check whether the vector is nonempty"""
+
+    def __repr__(self) -> str: ...
+
+    def __iter__(self) -> Iterator[Texture]: ...
+
+    @overload
+    def __getitem__(self, arg: int, /) -> Texture: ...
+
+    @overload
+    def __getitem__(self, arg: slice, /) -> TextureList: ...
+
+    def clear(self) -> None:
+        """Remove all items from list."""
+
+    def append(self, arg: Texture, /) -> None:
+        """Append `arg` to the end of the list."""
+
+    def insert(self, arg0: int, arg1: Texture, /) -> None:
+        """Insert object `arg1` before index `arg0`."""
+
+    def pop(self, index: int = -1) -> Texture:
+        """Remove and return item at `index` (default last)."""
+
+    def extend(self, arg: TextureList, /) -> None:
+        """Extend `self` by appending elements from `arg`."""
+
+    @overload
+    def __setitem__(self, arg0: int, arg1: Texture, /) -> None: ...
+
+    @overload
+    def __setitem__(self, arg0: slice, arg1: TextureList, /) -> None: ...
+
+    @overload
+    def __delitem__(self, arg: int, /) -> None: ...
+
+    @overload
+    def __delitem__(self, arg: slice, /) -> None: ...
+
+class ValueList:
+    @overload
+    def __init__(self) -> None:
+        """Default constructor"""
+
+    @overload
+    def __init__(self, arg: ValueList) -> None:
+        """Copy constructor"""
+
+    @overload
+    def __init__(self, arg: Iterable[Value], /) -> None:
+        """Construct from an iterable object"""
+
+    def __len__(self) -> int: ...
+
+    def __bool__(self) -> bool:
+        """Check whether the vector is nonempty"""
+
+    def __repr__(self) -> str: ...
+
+    def __iter__(self) -> Iterator[Value]: ...
+
+    @overload
+    def __getitem__(self, arg: int, /) -> Value: ...
+
+    @overload
+    def __getitem__(self, arg: slice, /) -> ValueList: ...
+
+    def clear(self) -> None:
+        """Remove all items from list."""
+
+    def append(self, arg: Value, /) -> None:
+        """Append `arg` to the end of the list."""
+
+    def insert(self, arg0: int, arg1: Value, /) -> None:
+        """Insert object `arg1` before index `arg0`."""
+
+    def pop(self, index: int = -1) -> Value:
+        """Remove and return item at `index` (default last)."""
+
+    def extend(self, arg: ValueList, /) -> None:
+        """Extend `self` by appending elements from `arg`."""
+
+    @overload
+    def __setitem__(self, arg0: int, arg1: Value, /) -> None: ...
+
+    @overload
+    def __setitem__(self, arg0: slice, arg1: ValueList, /) -> None: ...
+
+    @overload
+    def __delitem__(self, arg: int, /) -> None: ...
+
+    @overload
+    def __delitem__(self, arg: slice, /) -> None: ...
+
+class ValueMap:
+    @overload
+    def __init__(self) -> None:
+        """Default constructor"""
+
+    @overload
+    def __init__(self, arg: ValueMap) -> None:
+        """Copy constructor"""
+
+    @overload
+    def __init__(self, arg: dict[str, Value], /) -> None:
+        """Construct from a dictionary"""
+
+    def __len__(self) -> int: ...
+
+    def __bool__(self) -> bool:
+        """Check whether the map is nonempty"""
+
+    def __repr__(self) -> str: ...
+
+    @overload
+    def __contains__(self, arg: str, /) -> bool: ...
+
+    @overload
+    def __contains__(self, arg: object, /) -> bool: ...
+
+    def __iter__(self) -> Iterator[str]: ...
+
+    def __getitem__(self, arg: str, /) -> Value: ...
+
+    def __delitem__(self, arg: str, /) -> None: ...
+
+    def clear(self) -> None:
+        """Remove all items"""
+
+    def __setitem__(self, arg0: str, arg1: Value, /) -> None: ...
+
+    def update(self, arg: ValueMap, /) -> None:
+        """Update the map with element from `arg`"""
+
+    class ItemView:
+        def __len__(self) -> int: ...
+
+        def __iter__(self) -> Iterator[tuple[str, Value]]: ...
+
+    class KeyView:
+        @overload
+        def __contains__(self, arg: str, /) -> bool: ...
+
+        @overload
+        def __contains__(self, arg: object, /) -> bool: ...
+
+        def __len__(self) -> int: ...
+
+        def __iter__(self) -> Iterator[str]: ...
+
+    class ValueView:
+        def __len__(self) -> int: ...
+
+        def __iter__(self) -> Iterator[Value]: ...
+
+    def keys(self) -> ValueMap.KeyView:
+        """Returns an iterable view of the map's keys."""
+
+    def values(self) -> ValueMap.ValueView:
+        """Returns an iterable view of the map's values."""
+
+    def items(self) -> ValueMap.ItemView:
+        """Returns an iterable view of the map's items."""
+
+class ValueUnorderedMap:
+    @overload
+    def __init__(self) -> None:
+        """Default constructor"""
+
+    @overload
+    def __init__(self, arg: ValueUnorderedMap) -> None:
+        """Copy constructor"""
+
+    @overload
+    def __init__(self, arg: dict[str, Value], /) -> None:
+        """Construct from a dictionary"""
+
+    def __len__(self) -> int: ...
+
+    def __bool__(self) -> bool:
+        """Check whether the map is nonempty"""
+
+    def __repr__(self) -> str: ...
+
+    @overload
+    def __contains__(self, arg: str, /) -> bool: ...
+
+    @overload
+    def __contains__(self, arg: object, /) -> bool: ...
+
+    def __iter__(self) -> Iterator[str]: ...
+
+    def __getitem__(self, arg: str, /) -> Value: ...
+
+    def __delitem__(self, arg: str, /) -> None: ...
+
+    def clear(self) -> None:
+        """Remove all items"""
+
+    def __setitem__(self, arg0: str, arg1: Value, /) -> None: ...
+
+    def update(self, arg: ValueUnorderedMap, /) -> None:
+        """Update the map with element from `arg`"""
+
+    class ItemView:
+        def __len__(self) -> int: ...
+
+        def __iter__(self) -> Iterator[tuple[str, Value]]: ...
+
+    class KeyView:
+        @overload
+        def __contains__(self, arg: str, /) -> bool: ...
+
+        @overload
+        def __contains__(self, arg: object, /) -> bool: ...
+
+        def __len__(self) -> int: ...
+
+        def __iter__(self) -> Iterator[str]: ...
+
+    class ValueView:
+        def __len__(self) -> int: ...
+
+        def __iter__(self) -> Iterator[Value]: ...
+
+    def keys(self) -> ValueUnorderedMap.KeyView:
+        """Returns an iterable view of the map's keys."""
+
+    def values(self) -> ValueUnorderedMap.ValueView:
+        """Returns an iterable view of the map's values."""
+
+    def items(self) -> ValueUnorderedMap.ItemView:
+        """Returns an iterable view of the map's items."""
+
+def compute_global_node_transform(scene: Scene, node_idx: int) -> Annotated[ArrayLike, dict(dtype='float32', order='F', shape=(4, 4))]:
+    """
+    Compute the global transform associated with a node.
+
+    :param scene: The input node.
+    :param node_idx: The index of the taget node.
+
+    :returns: The global transform of the target node, which is the combination of transforms from this node all the way to the root.
+    """
+
+def mesh_to_simple_scene(mesh: lagrange.core.SurfaceMesh) -> SimpleScene3D:
+    """
+    Converts a single mesh into a simple scene with a single identity instance of the input mesh.
+
+    :param mesh: Input mesh to convert.
+
+    :return: Simple scene containing the input mesh.
+    """
+
+def meshes_to_simple_scene(meshes: SurfaceMeshList) -> SimpleScene3D:
+    """
+    Converts a list of meshes into a simple scene with a single identity instance of each input mesh.
+
+    :param meshes: Input meshes to convert.
+
+    :return: Simple scene containing the input meshes.
+    """
+
+def simple_scene_to_mesh(scene: SimpleScene3D, normalize_normals: bool = True, normalize_tangents_bitangents: bool = True, preserve_attributes: bool = True) -> lagrange.core.SurfaceMesh:
+    """
+    Converts a scene into a concatenated mesh with all the transforms applied.
+
+    :param scene: Scene to convert.
+    :param normalize_normals: If enabled, normals are normalized after transformation.
+    :param normalize_tangents_bitangents: If enabled, tangents and bitangents are normalized after transformation.
+    :param preserve_attributes: Preserve shared attributes and map them to the output mesh.
+
+    :return: Concatenated mesh.
+    """
```

## lagrange/lagrange/subdivision.pyi

```diff
@@ -1,75 +1,59 @@
-from typing import Any, Optional, overload, Typing, Sequence
-from enum import Enum
-import lagrange.subdivision
-
-class FaceVaryingInterpolation(Enum):
-    """
-    <attribute '__doc__' of 'FaceVaryingInterpolation' objects>
-    """
-
-    All: Any
-    
-    Boundaries: Any
-    
-    CornersOnly: Any
-    
-    CornersPlus1: Any
-    
-    CornersPlus2: Any
-    
-    Smooth: Any
-    
-class InterpolatedAttributesSelection(Enum):
-    """
-    <attribute '__doc__' of 'InterpolatedAttributesSelection' objects>
-    """
-
-    All: Any
-    
-    Empty: Any
-    
-    Selected: Any
-    
-class SchemeType(Enum):
-    """
-    <attribute '__doc__' of 'SchemeType' objects>
-    """
-
-    Bilinear: Any
-    
-    CatmullClark: Any
-    
-    Loop: Any
-    
-class VertexBoundaryInterpolation(Enum):
-    """
-    <attribute '__doc__' of 'VertexBoundaryInterpolation' objects>
-    """
-
-    EdgeAndCorner: Any
-    
-    EdgeOnly: Any
-    
-    NoInterpolation: Any
-    
-def subdivide_mesh(mesh: lagrange.core.SurfaceMesh, num_levels: int, scheme: Optional[lagrange.subdivision.SchemeType] = None, vertex_boundary_interpolation: lagrange.subdivision.VertexBoundaryInterpolation = lagrange.subdivision.VertexBoundaryInterpolation.EdgeOnly, face_varying_interpolation: lagrange.subdivision.FaceVaryingInterpolation = lagrange.subdivision.FaceVaryingInterpolation.Smooth, use_limit_surface: bool = False, interpolated_attributes_selection: lagrange.subdivision.InterpolatedAttributesSelection = lagrange.subdivision.InterpolatedAttributesSelection.All, interpolated_smooth_attributes: Optional[list[int]] = None, interpolated_linear_attributes: Optional[list[int]] = None, edge_sharpness_attr: Optional[int] = None, vertex_sharpness_attr: Optional[int] = None, face_hole_attr: Optional[int] = None, output_limit_normals: Optional[str] = None, output_limit_tangents: Optional[str] = None, output_limit_bitangents: Optional[str] = None) -> lagrange.core.SurfaceMesh:
-    """
-    Evaluates the subdivision surface of a polygonal mesh.
-    
-    :param mesh:                  The source mesh.
-    :param num_levels:            The number of levels of subdivision to apply.
-    :param scheme:                The subdivision scheme to use.
-    :param vertex_boundary_interpolation:  Vertex boundary interpolation rule.
-    :param face_varying_interpolation:     Face-varying interpolation rule.
-    :param use_limit_surface:      Interpolate all data to the limit surface.
-    :param edge_sharpness_attr:    Per-edge scalar attribute denoting edge sharpness. Sharpness values must be in [0, 1] (0 means smooth, 1 means sharp).
-    :param vertex_sharpness_attr:  Per-vertex scalar attribute denoting vertex sharpness (e.g. for boundary corners). Sharpness values must be in [0, 1] (0 means smooth, 1 means sharp).
-    :param face_hole_attr:         Per-face integer attribute denoting face holes. A non-zero value means the facet is a hole. If a face is tagged as a hole, the limit surface will not be generated for that face.
-    :param output_limit_normals:   Output name for a newly computed per-vertex attribute containing the normals to the limit surface. Skipped if left empty.
-    :param output_limit_tangents:  Output name for a newly computed per-vertex attribute containing the tangents (first derivatives) to the limit surface. Skipped if left empty.
-    :param output_limit_bitangents: Output name for a newly computed per-vertex attribute containing the bitangents (second derivative) to the limit surface. Skipped if left empty.
-    
-    :return: The subdivided mesh.
-    """
-    ...
-
+from collections.abc import Sequence
+import enum
+
+import lagrange.core
+
+
+class FaceVaryingInterpolation(enum.Enum):
+    Smooth = 0
+
+    CornersOnly = 1
+
+    CornersPlus1 = 2
+
+    CornersPlus2 = 3
+
+    Boundaries = 4
+
+    All = 5
+
+class InterpolatedAttributesSelection(enum.Enum):
+    All = 0
+
+    Empty = 1
+
+    Selected = 2
+
+class SchemeType(enum.Enum):
+    Bilinear = 0
+
+    CatmullClark = 1
+
+    Loop = 2
+
+class VertexBoundaryInterpolation(enum.Enum):
+    NoInterpolation = 0
+
+    EdgeOnly = 1
+
+    EdgeAndCorner = 2
+
+def subdivide_mesh(mesh: lagrange.core.SurfaceMesh, num_levels: int, scheme: SchemeType | None = None, vertex_boundary_interpolation: VertexBoundaryInterpolation = VertexBoundaryInterpolation.EdgeOnly, face_varying_interpolation: FaceVaryingInterpolation = FaceVaryingInterpolation.Smooth, use_limit_surface: bool = False, interpolated_attributes_selection: InterpolatedAttributesSelection = InterpolatedAttributesSelection.All, interpolated_smooth_attributes: Sequence[int] | None = None, interpolated_linear_attributes: Sequence[int] | None = None, edge_sharpness_attr: int | None = None, vertex_sharpness_attr: int | None = None, face_hole_attr: int | None = None, output_limit_normals: str | None = None, output_limit_tangents: str | None = None, output_limit_bitangents: str | None = None) -> lagrange.core.SurfaceMesh:
+    """
+    Evaluates the subdivision surface of a polygonal mesh.
+
+    :param mesh:                  The source mesh.
+    :param num_levels:            The number of levels of subdivision to apply.
+    :param scheme:                The subdivision scheme to use.
+    :param vertex_boundary_interpolation:  Vertex boundary interpolation rule.
+    :param face_varying_interpolation:     Face-varying interpolation rule.
+    :param use_limit_surface:      Interpolate all data to the limit surface.
+    :param edge_sharpness_attr:    Per-edge scalar attribute denoting edge sharpness. Sharpness values must be in [0, 1] (0 means smooth, 1 means sharp).
+    :param vertex_sharpness_attr:  Per-vertex scalar attribute denoting vertex sharpness (e.g. for boundary corners). Sharpness values must be in [0, 1] (0 means smooth, 1 means sharp).
+    :param face_hole_attr:         Per-face integer attribute denoting face holes. A non-zero value means the facet is a hole. If a face is tagged as a hole, the limit surface will not be generated for that face.
+    :param output_limit_normals:   Output name for a newly computed per-vertex attribute containing the normals to the limit surface. Skipped if left empty.
+    :param output_limit_tangents:  Output name for a newly computed per-vertex attribute containing the tangents (first derivatives) to the limit surface. Skipped if left empty.
+    :param output_limit_bitangents: Output name for a newly computed per-vertex attribute containing the bitangents (second derivative) to the limit surface. Skipped if left empty.
+
+    :return: The subdivided mesh.
+    """
```

## Comparing `lagrange_open-6.22.0.data/scripts/extract_texture.py` & `lagrange_open-6.23.0.data/scripts/extract_texture.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,74 +1,72 @@
-#!python
-
-#
-# Copyright 2024 Adobe. All rights reserved.
-# This file is licensed to you under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License. You may obtain a copy
-# of the License at http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software distributed under
-# the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
-# OF ANY KIND, either express or implied. See the License for the specific language
-# governing permissions and limitations under the License.
-#
-
-"""Extract texture from a mesh"""
-
-import argparse
-import lagrange
-from pathlib import Path
-from PIL import Image
-
-
-def parse_args():
-    parser = argparse.ArgumentParser(description=__doc__)
-    parser.add_argument("input", help="input mesh file")
-    parser.add_argument("output", help="output mesh file")
-    return parser.parse_args()
-
-
-def dump_texture(img, filename):
-    img.uri = filename
-    img_buffer = img.image
-    buffer = img_buffer.data.reshape(
-        (img_buffer.height, img_buffer.width, img_buffer.num_channels)
-    )
-    if img_buffer.num_channels == 4:
-        im = Image.fromarray(buffer, "RGBA")
-    elif img_buffer.num_channels == 3:
-        im = Image.fromarray(buffer, "RGB")
-    elif img_buffer.num_channels == 1:
-        im = Image.fromarray(buffer, "L")
-    else:
-        raise ValueError(f"Unsupported number of channels: {img_buffer.num_channels}")
-    im.save(filename)
-
-
-def main():
-    args = parse_args()
-    scene = lagrange.io.load_scene(args.input)
-
-    output_filename = Path(args.output)
-    basename = output_filename.stem
-    texture_count = 0
-    for node in scene.nodes:
-        for instance in node.meshes:
-            assert instance.mesh != lagrange.invalid_index
-            for mat_id in instance.materials:
-                mat = scene.materials[mat_id]
-                if mat.base_color_texture.index != lagrange.invalid_index:
-                    tex = scene.textures[mat.base_color_texture.index]
-                    assert tex.image != lagrange.invalid_index
-                    img = scene.images[tex.image]
-                    if len(img.image.data) != 0:
-                        texture_filename = output_filename.with_suffix(
-                            ".png"
-                        ).with_stem(f"{basename}_{texture_count:03}")
-                        dump_texture(img, texture_filename)
-                        texture_count += 1
-
-    lagrange.io.save_scene(args.output, scene)
-
-
-if __name__ == "__main__":
-    main()
+#!python
+
+#
+# Copyright 2024 Adobe. All rights reserved.
+# This file is licensed to you under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License. You may obtain a copy
+# of the License at http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software distributed under
+# the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
+# OF ANY KIND, either express or implied. See the License for the specific language
+# governing permissions and limitations under the License.
+#
+
+"""Extract texture from a mesh"""
+
+import argparse
+import lagrange
+from pathlib import Path
+from PIL import Image
+
+
+def parse_args():
+    parser = argparse.ArgumentParser(description=__doc__)
+    parser.add_argument("input", help="input mesh file")
+    parser.add_argument("output", help="output mesh file")
+    return parser.parse_args()
+
+
+def dump_texture(img, filename):
+    img.uri = filename
+    img_buffer = img.image
+    buffer = img_buffer.data.reshape((img_buffer.height, img_buffer.width, img_buffer.num_channels))
+    if img_buffer.num_channels == 4:
+        im = Image.fromarray(buffer, "RGBA")
+    elif img_buffer.num_channels == 3:
+        im = Image.fromarray(buffer, "RGB")
+    elif img_buffer.num_channels == 1:
+        im = Image.fromarray(buffer, "L")
+    else:
+        raise ValueError(f"Unsupported number of channels: {img_buffer.num_channels}")
+    im.save(filename)
+
+
+def main():
+    args = parse_args()
+    scene = lagrange.io.load_scene(args.input)
+
+    output_filename = Path(args.output)
+    basename = output_filename.stem
+    texture_count = 0
+    for node in scene.nodes:
+        for instance in node.meshes:
+            assert instance.mesh != lagrange.invalid_index
+            for mat_id in instance.materials:
+                mat = scene.materials[mat_id]
+                if mat.base_color_texture.index != lagrange.invalid_index:
+                    tex = scene.textures[mat.base_color_texture.index]
+                    assert tex.image != lagrange.invalid_index
+                    img = scene.images[tex.image]
+                    if len(img.image.data) != 0:
+                        texture_filename = output_filename.with_suffix(".png").with_stem(
+                            f"{basename}_{texture_count:03}"
+                        )
+                        dump_texture(img, texture_filename)
+                        texture_count += 1
+
+    lagrange.io.save_scene(args.output, scene)
+
+
+if __name__ == "__main__":
+    main()
```

## Comparing `lagrange_open-6.22.0.data/scripts/meshconvert.py` & `lagrange_open-6.23.0.data/scripts/meshconvert.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,62 +1,58 @@
-#!python
-
-import argparse
-import lagrange
-from pathlib import Path
-
-
-def parse_args():
-    parser = argparse.ArgumentParser(
-        description="Convert a mesh file to a different format."
-    )
-    parser.add_argument("input_mesh", help="input mesh file")
-    parser.add_argument("output_mesh", help="output mesh file")
-    parser.add_argument(
-        "--triangulate", "-t", action="store_true", help="triangulate the mesh"
-    )
-    parser.add_argument(
-        "--logging-level",
-        "-l",
-        default="info",
-        help="logging level",
-        choices=["debug", "info", "warning", "error", "critical"],
-    )
-    return parser.parse_args()
-
-
-def main():
-    args = parse_args()
-    lagrange.logger.setLevel(args.logging_level.upper())
-    input_suffix = Path(args.input_mesh).suffix
-    output_suffix = Path(args.output_mesh).suffix
-    if input_suffix in [".fbx", ".gltf", ".glb"]:
-        lagrange.logger.info(f"Loading input scene from {args.input_mesh}")
-        scene = lagrange.io.load_simple_scene(args.input_mesh)
-        if input_suffix in [".gltf", ".glb"]:
-            for i in range(scene.num_meshes):
-                mesh = scene.ref_mesh(i)
-                lagrange.remove_duplicate_vertices(mesh)
-
-        if args.triangulate:
-            for i in range(scene.num_meshes):
-                mesh = scene.ref_mesh(i)
-                lagrange.triangulate_polygonal_facets(mesh)
-
-        if output_suffix in [".gltf", ".glb"]:
-            lagrange.logger.info(f"Saving output scene in {args.output_mesh}")
-            lagrange.io.save_simple_scene(args.output_mesh, scene)
-        else:
-            lagrange.logger.info(f"Saving output mesh in {args.output_mesh}")
-            mesh = lagrange.scene.simple_scene_to_mesh(scene)
-            lagrange.io.save_mesh(args.output_mesh, mesh)
-    else:
-        lagrange.logger.info(f"Loading input mesh from {args.input_mesh}")
-        mesh = lagrange.io.load_mesh(args.input_mesh)
-        if not mesh.is_regular and args.triangulate:
-            lagrange.triangulate_polygonal_facets(mesh)
-        lagrange.logger.info(f"Saving output mesh in {args.output_mesh}")
-        lagrange.io.save_mesh(args.output_mesh, mesh)
-
-
-if __name__ == "__main__":
-    main()
+#!python
+
+import argparse
+import lagrange
+from pathlib import Path
+
+
+def parse_args():
+    parser = argparse.ArgumentParser(description="Convert a mesh file to a different format.")
+    parser.add_argument("input_mesh", help="input mesh file")
+    parser.add_argument("output_mesh", help="output mesh file")
+    parser.add_argument("--triangulate", "-t", action="store_true", help="triangulate the mesh")
+    parser.add_argument(
+        "--logging-level",
+        "-l",
+        default="info",
+        help="logging level",
+        choices=["debug", "info", "warning", "error", "critical"],
+    )
+    return parser.parse_args()
+
+
+def main():
+    args = parse_args()
+    lagrange.logger.setLevel(args.logging_level.upper())
+    input_suffix = Path(args.input_mesh).suffix
+    output_suffix = Path(args.output_mesh).suffix
+    if input_suffix in [".fbx", ".gltf", ".glb"]:
+        lagrange.logger.info(f"Loading input scene from {args.input_mesh}")
+        scene = lagrange.io.load_simple_scene(args.input_mesh)
+        if input_suffix in [".gltf", ".glb"]:
+            for i in range(scene.num_meshes):
+                mesh = scene.ref_mesh(i)
+                lagrange.remove_duplicate_vertices(mesh)
+
+        if args.triangulate:
+            for i in range(scene.num_meshes):
+                mesh = scene.ref_mesh(i)
+                lagrange.triangulate_polygonal_facets(mesh)
+
+        if output_suffix in [".gltf", ".glb"]:
+            lagrange.logger.info(f"Saving output scene in {args.output_mesh}")
+            lagrange.io.save_simple_scene(args.output_mesh, scene)
+        else:
+            lagrange.logger.info(f"Saving output mesh in {args.output_mesh}")
+            mesh = lagrange.scene.simple_scene_to_mesh(scene)
+            lagrange.io.save_mesh(args.output_mesh, mesh)
+    else:
+        lagrange.logger.info(f"Loading input mesh from {args.input_mesh}")
+        mesh = lagrange.io.load_mesh(args.input_mesh)
+        if not mesh.is_regular and args.triangulate:
+            lagrange.triangulate_polygonal_facets(mesh)
+        lagrange.logger.info(f"Saving output mesh in {args.output_mesh}")
+        lagrange.io.save_mesh(args.output_mesh, mesh)
+
+
+if __name__ == "__main__":
+    main()
```

## Comparing `lagrange_open-6.22.0.data/scripts/meshstat.py` & `lagrange_open-6.23.0.data/scripts/meshstat.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,196 +1,187 @@
-#!python
-"""Print basic information about a mesh file"""
-
-import argparse
-import lagrange
-import colorama
-import json
-import pathlib
-import numpy as np
-
-colorama.just_fix_windows_console()
-
-
-def print_header(message):
-    print(
-        colorama.Fore.YELLOW
-        + colorama.Style.BRIGHT
-        + message
-        + colorama.Style.RESET_ALL
-    )
-
-
-def print_green(message):
-    print(colorama.Fore.GREEN + message + colorama.Style.RESET_ALL)
-
-
-def print_red(message):
-    print(colorama.Fore.RED + message + colorama.Style.RESET_ALL)
-
-
-def print_section_header(val):
-    print_green("{:_^55}".format(val))
-
-
-def print_property(name, val, expected=None):
-    if expected is not None and val != expected:
-        print_red("{:-<48}: {}".format(name, val))
-    else:
-        print("{:-<48}: {}".format(name, val))
-
-
-def print_basic_info(mesh, info):
-    print_section_header("Basic information")
-    print("dim: {}".format(mesh.dimension))
-
-    # Vertex/facet/edge/corner count
-    num_vertices = mesh.num_vertices
-    num_facets = mesh.num_facets
-    num_edges = mesh.num_edges
-    num_corners = mesh.num_corners
-    info["num_vertices"] = num_vertices
-    info["num_facets"] = num_facets
-    info["num_edges"] = num_edges
-    info["num_corners"] = num_corners
-    print(
-        f"#v: {num_vertices:<10}#f: {num_facets:<10}#e: {num_edges:<10}#c: {num_corners:<10}"
-    )
-
-    # Mesh bbox
-    bbox_min = np.amin(mesh.vertices, axis=0)
-    bbox_max = np.amax(mesh.vertices, axis=0)
-    print(f"bbox min: [{bbox_min[0]:>10.3f} {bbox_min[1]:>10.3f} {bbox_min[2]:>10.3f}]")
-    print(f"bbox max: [{bbox_max[0]:>10.3f} {bbox_max[1]:>10.3f} {bbox_max[2]:>10.3f}]")
-
-    # vertex_per_facet
-    if mesh.is_regular:
-        if mesh.vertex_per_facet == 3:
-            print("facet type: triangles")
-        elif mesh.vertex_per_facet == 4:
-            print("facet type: quads")
-        else:
-            print(f"facet type: polygons ({mesh.vertex_per_facet})")
-
-        info["is_regular"] = True
-        info["vertex_per_facet"] = mesh.vertex_per_facet
-    else:
-        print_red(f"facet type: hybrid")
-        info["is_regular"] = True
-
-
-def print_extra_info(mesh, info):
-    # components
-    num_components = lagrange.compute_components(mesh)
-    print_property("num_components", num_components)
-    info["num_components"] = num_components
-
-    # manifold check
-    edge_manifold = lagrange.is_edge_manifold(mesh)
-    if edge_manifold:
-        vertex_manifold = lagrange.is_vertex_manifold(mesh)
-    else:
-        vertex_manifold = False
-    info["edge_manifold"] = edge_manifold
-    info["vertex_manifold"] = vertex_manifold
-    info["manifold"] = edge_manifold and vertex_manifold
-    print_property("manifold", info["manifold"], True)
-    print_property("vertex manifold", vertex_manifold, True)
-    print_property("edge manifold", edge_manifold, True)
-
-    # Degeneracy check
-    num_degenerate_facets = lagrange.detect_degenerate_facets(mesh)
-    info["degenerate_facets"] = num_degenerate_facets
-    print_property("num degenerate facets", len(num_degenerate_facets), 0)
-
-
-def usage_to_str(usage):
-    return str(usage).split(".")[-1]
-
-
-def element_to_str(element):
-    return str(element).split(".")[-1]
-
-
-def print_attributes(mesh):
-    for id in mesh.get_matching_attribute_ids():
-        name = mesh.get_attribute_name(id)
-        if name.startswith("@"):
-            continue
-        is_indexed = mesh.is_attribute_indexed(id)
-        if is_indexed:
-            attr = mesh.indexed_attribute(id)
-        else:
-            attr = mesh.attribute(id)
-        usage = usage_to_str(attr.usage)
-        element_type = element_to_str(attr.element_type)
-        num_channels = attr.num_channels
-
-        print(f"Attribute {colorama.Fore.GREEN}{name}{colorama.Style.RESET_ALL}")
-        print(
-            f"  id:{id:<5}usage: {usage:<10}elem: {element_type:<10}channels: {num_channels}"
-        )
-
-
-def load_info(mesh_file):
-    mesh_file = pathlib.Path(mesh_file)
-    info_file = mesh_file.with_suffix(".json")
-    info = {}
-    if info_file.exists():
-        with open(info_file, "r") as fin:
-            try:
-                info = json.load(fin)
-            except ValueError:
-                print_red("Cannot parse {}, overwriting it".format(info_file))
-    return info
-
-
-def save_info(mesh_file, info):
-    mesh_file = pathlib.Path(mesh_file)
-    info_file = mesh_file.with_suffix(".json")
-
-    with open(info_file, "w") as fout:
-        json.dump(info, fout, indent=4, sort_keys=True)
-
-
-def parse_args():
-    parser = argparse.ArgumentParser(description=__doc__)
-    parser.add_argument(
-        "--extended",
-        "-x",
-        action="store_true",
-        help="check for extended information such as number of components, manifoldness and more",
-    )
-    parser.add_argument(
-        "--attribute",
-        "-a",
-        action="store_true",
-        help="print attribute information",
-    )
-    parser.add_argument(
-        "--export", "-e", action="store_true", help="export stats into a .info file"
-    )
-    parser.add_argument("input_mesh", help="input mesh file")
-    return parser.parse_args()
-
-
-def main():
-    args = parse_args()
-    mesh = lagrange.io.load_mesh(args.input_mesh)
-    mesh.initialize_edges()
-    info = load_info(args.input_mesh)
-
-    header = "Summary of {}".format(args.input_mesh)
-    print_header("{:=^55}".format(header))
-    print_basic_info(mesh, info)
-
-    if args.extended:
-        print_extra_info(mesh, info)
-    if args.attribute:
-        print_attributes(mesh)
-
-    if args.export:
-        save_info(args.input_mesh, info)
-
-
-if __name__ == "__main__":
-    main()
+#!python
+"""Print basic information about a mesh file"""
+
+import argparse
+import lagrange
+import colorama
+import json
+import pathlib
+import numpy as np
+
+colorama.just_fix_windows_console()
+
+
+def print_header(message):
+    print(colorama.Fore.YELLOW + colorama.Style.BRIGHT + message + colorama.Style.RESET_ALL)
+
+
+def print_green(message):
+    print(colorama.Fore.GREEN + message + colorama.Style.RESET_ALL)
+
+
+def print_red(message):
+    print(colorama.Fore.RED + message + colorama.Style.RESET_ALL)
+
+
+def print_section_header(val):
+    print_green("{:_^55}".format(val))
+
+
+def print_property(name, val, expected=None):
+    if expected is not None and val != expected:
+        print_red("{:-<48}: {}".format(name, val))
+    else:
+        print("{:-<48}: {}".format(name, val))
+
+
+def print_basic_info(mesh, info):
+    print_section_header("Basic information")
+    print("dim: {}".format(mesh.dimension))
+
+    # Vertex/facet/edge/corner count
+    num_vertices = mesh.num_vertices
+    num_facets = mesh.num_facets
+    num_edges = mesh.num_edges
+    num_corners = mesh.num_corners
+    info["num_vertices"] = num_vertices
+    info["num_facets"] = num_facets
+    info["num_edges"] = num_edges
+    info["num_corners"] = num_corners
+    print(f"#v: {num_vertices:<10}#f: {num_facets:<10}#e: {num_edges:<10}#c: {num_corners:<10}")
+
+    # Mesh bbox
+    bbox_min = np.amin(mesh.vertices, axis=0)
+    bbox_max = np.amax(mesh.vertices, axis=0)
+    print(f"bbox min: [{bbox_min[0]:>10.3f} {bbox_min[1]:>10.3f} {bbox_min[2]:>10.3f}]")
+    print(f"bbox max: [{bbox_max[0]:>10.3f} {bbox_max[1]:>10.3f} {bbox_max[2]:>10.3f}]")
+
+    # vertex_per_facet
+    if mesh.is_regular:
+        if mesh.vertex_per_facet == 3:
+            print("facet type: triangles")
+        elif mesh.vertex_per_facet == 4:
+            print("facet type: quads")
+        else:
+            print(f"facet type: polygons ({mesh.vertex_per_facet})")
+
+        info["is_regular"] = True
+        info["vertex_per_facet"] = mesh.vertex_per_facet
+    else:
+        print_red(f"facet type: hybrid")
+        info["is_regular"] = True
+
+
+def print_extra_info(mesh, info):
+    # components
+    num_components = lagrange.compute_components(mesh)
+    print_property("num_components", num_components)
+    info["num_components"] = num_components
+
+    # manifold check
+    edge_manifold = lagrange.is_edge_manifold(mesh)
+    if edge_manifold:
+        vertex_manifold = lagrange.is_vertex_manifold(mesh)
+    else:
+        vertex_manifold = False
+    info["edge_manifold"] = edge_manifold
+    info["vertex_manifold"] = vertex_manifold
+    info["manifold"] = edge_manifold and vertex_manifold
+    print_property("manifold", info["manifold"], True)
+    print_property("vertex manifold", vertex_manifold, True)
+    print_property("edge manifold", edge_manifold, True)
+
+    # Degeneracy check
+    num_degenerate_facets = lagrange.detect_degenerate_facets(mesh)
+    info["degenerate_facets"] = num_degenerate_facets
+    print_property("num degenerate facets", len(num_degenerate_facets), 0)
+
+
+def usage_to_str(usage):
+    return str(usage).split(".")[-1]
+
+
+def element_to_str(element):
+    return str(element).split(".")[-1]
+
+
+def print_attributes(mesh):
+    for id in mesh.get_matching_attribute_ids():
+        name = mesh.get_attribute_name(id)
+        if name.startswith("@"):
+            continue
+        is_indexed = mesh.is_attribute_indexed(id)
+        if is_indexed:
+            attr = mesh.indexed_attribute(id)
+        else:
+            attr = mesh.attribute(id)
+        usage = usage_to_str(attr.usage)
+        element_type = element_to_str(attr.element_type)
+        num_channels = attr.num_channels
+
+        print(f"Attribute {colorama.Fore.GREEN}{name}{colorama.Style.RESET_ALL}")
+        print(f"  id:{id:<5}usage: {usage:<10}elem: {element_type:<10}channels: {num_channels}")
+
+
+def load_info(mesh_file):
+    mesh_file = pathlib.Path(mesh_file)
+    info_file = mesh_file.with_suffix(".json")
+    info = {}
+    if info_file.exists():
+        with open(info_file, "r") as fin:
+            try:
+                info = json.load(fin)
+            except ValueError:
+                print_red("Cannot parse {}, overwriting it".format(info_file))
+    return info
+
+
+def save_info(mesh_file, info):
+    mesh_file = pathlib.Path(mesh_file)
+    info_file = mesh_file.with_suffix(".json")
+
+    with open(info_file, "w") as fout:
+        json.dump(info, fout, indent=4, sort_keys=True)
+
+
+def parse_args():
+    parser = argparse.ArgumentParser(description=__doc__)
+    parser.add_argument(
+        "--extended",
+        "-x",
+        action="store_true",
+        help="check for extended information such as number of components, manifoldness and more",
+    )
+    parser.add_argument(
+        "--attribute",
+        "-a",
+        action="store_true",
+        help="print attribute information",
+    )
+    parser.add_argument(
+        "--export", "-e", action="store_true", help="export stats into a .info file"
+    )
+    parser.add_argument("input_mesh", help="input mesh file")
+    return parser.parse_args()
+
+
+def main():
+    args = parse_args()
+    mesh = lagrange.io.load_mesh(args.input_mesh)
+    mesh.initialize_edges()
+    info = load_info(args.input_mesh)
+
+    header = "Summary of {}".format(args.input_mesh)
+    print_header("{:=^55}".format(header))
+    print_basic_info(mesh, info)
+
+    if args.extended:
+        print_extra_info(mesh, info)
+    if args.attribute:
+        print_attributes(mesh)
+
+    if args.export:
+        save_info(args.input_mesh, info)
+
+
+if __name__ == "__main__":
+    main()
```

## Comparing `lagrange_open-6.22.0.dist-info/licenses/LICENSE` & `lagrange_open-6.23.0.dist-info/licenses/LICENSE`

 * *Ordering differences only*

 * *Files 15% similar despite different names*

```diff
@@ -1,201 +1,201 @@
-                                 Apache License
-                           Version 2.0, January 2004
-                        http://www.apache.org/licenses/
-
-   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
-
-   1. Definitions.
-
-      "License" shall mean the terms and conditions for use, reproduction,
-      and distribution as defined by Sections 1 through 9 of this document.
-
-      "Licensor" shall mean the copyright owner or entity authorized by
-      the copyright owner that is granting the License.
-
-      "Legal Entity" shall mean the union of the acting entity and all
-      other entities that control, are controlled by, or are under common
-      control with that entity. For the purposes of this definition,
-      "control" means (i) the power, direct or indirect, to cause the
-      direction or management of such entity, whether by contract or
-      otherwise, or (ii) ownership of fifty percent (50%) or more of the
-      outstanding shares, or (iii) beneficial ownership of such entity.
-
-      "You" (or "Your") shall mean an individual or Legal Entity
-      exercising permissions granted by this License.
-
-      "Source" form shall mean the preferred form for making modifications,
-      including but not limited to software source code, documentation
-      source, and configuration files.
-
-      "Object" form shall mean any form resulting from mechanical
-      transformation or translation of a Source form, including but
-      not limited to compiled object code, generated documentation,
-      and conversions to other media types.
-
-      "Work" shall mean the work of authorship, whether in Source or
-      Object form, made available under the License, as indicated by a
-      copyright notice that is included in or attached to the work
-      (an example is provided in the Appendix below).
-
-      "Derivative Works" shall mean any work, whether in Source or Object
-      form, that is based on (or derived from) the Work and for which the
-      editorial revisions, annotations, elaborations, or other modifications
-      represent, as a whole, an original work of authorship. For the purposes
-      of this License, Derivative Works shall not include works that remain
-      separable from, or merely link (or bind by name) to the interfaces of,
-      the Work and Derivative Works thereof.
-
-      "Contribution" shall mean any work of authorship, including
-      the original version of the Work and any modifications or additions
-      to that Work or Derivative Works thereof, that is intentionally
-      submitted to Licensor for inclusion in the Work by the copyright owner
-      or by an individual or Legal Entity authorized to submit on behalf of
-      the copyright owner. For the purposes of this definition, "submitted"
-      means any form of electronic, verbal, or written communication sent
-      to the Licensor or its representatives, including but not limited to
-      communication on electronic mailing lists, source code control systems,
-      and issue tracking systems that are managed by, or on behalf of, the
-      Licensor for the purpose of discussing and improving the Work, but
-      excluding communication that is conspicuously marked or otherwise
-      designated in writing by the copyright owner as "Not a Contribution."
-
-      "Contributor" shall mean Licensor and any individual or Legal Entity
-      on behalf of whom a Contribution has been received by Licensor and
-      subsequently incorporated within the Work.
-
-   2. Grant of Copyright License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      copyright license to reproduce, prepare Derivative Works of,
-      publicly display, publicly perform, sublicense, and distribute the
-      Work and such Derivative Works in Source or Object form.
-
-   3. Grant of Patent License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      (except as stated in this section) patent license to make, have made,
-      use, offer to sell, sell, import, and otherwise transfer the Work,
-      where such license applies only to those patent claims licensable
-      by such Contributor that are necessarily infringed by their
-      Contribution(s) alone or by combination of their Contribution(s)
-      with the Work to which such Contribution(s) was submitted. If You
-      institute patent litigation against any entity (including a
-      cross-claim or counterclaim in a lawsuit) alleging that the Work
-      or a Contribution incorporated within the Work constitutes direct
-      or contributory patent infringement, then any patent licenses
-      granted to You under this License for that Work shall terminate
-      as of the date such litigation is filed.
-
-   4. Redistribution. You may reproduce and distribute copies of the
-      Work or Derivative Works thereof in any medium, with or without
-      modifications, and in Source or Object form, provided that You
-      meet the following conditions:
-
-      (a) You must give any other recipients of the Work or
-          Derivative Works a copy of this License; and
-
-      (b) You must cause any modified files to carry prominent notices
-          stating that You changed the files; and
-
-      (c) You must retain, in the Source form of any Derivative Works
-          that You distribute, all copyright, patent, trademark, and
-          attribution notices from the Source form of the Work,
-          excluding those notices that do not pertain to any part of
-          the Derivative Works; and
-
-      (d) If the Work includes a "NOTICE" text file as part of its
-          distribution, then any Derivative Works that You distribute must
-          include a readable copy of the attribution notices contained
-          within such NOTICE file, excluding those notices that do not
-          pertain to any part of the Derivative Works, in at least one
-          of the following places: within a NOTICE text file distributed
-          as part of the Derivative Works; within the Source form or
-          documentation, if provided along with the Derivative Works; or,
-          within a display generated by the Derivative Works, if and
-          wherever such third-party notices normally appear. The contents
-          of the NOTICE file are for informational purposes only and
-          do not modify the License. You may add Your own attribution
-          notices within Derivative Works that You distribute, alongside
-          or as an addendum to the NOTICE text from the Work, provided
-          that such additional attribution notices cannot be construed
-          as modifying the License.
-
-      You may add Your own copyright statement to Your modifications and
-      may provide additional or different license terms and conditions
-      for use, reproduction, or distribution of Your modifications, or
-      for any such Derivative Works as a whole, provided Your use,
-      reproduction, and distribution of the Work otherwise complies with
-      the conditions stated in this License.
-
-   5. Submission of Contributions. Unless You explicitly state otherwise,
-      any Contribution intentionally submitted for inclusion in the Work
-      by You to the Licensor shall be under the terms and conditions of
-      this License, without any additional terms or conditions.
-      Notwithstanding the above, nothing herein shall supersede or modify
-      the terms of any separate license agreement you may have executed
-      with Licensor regarding such Contributions.
-
-   6. Trademarks. This License does not grant permission to use the trade
-      names, trademarks, service marks, or product names of the Licensor,
-      except as required for reasonable and customary use in describing the
-      origin of the Work and reproducing the content of the NOTICE file.
-
-   7. Disclaimer of Warranty. Unless required by applicable law or
-      agreed to in writing, Licensor provides the Work (and each
-      Contributor provides its Contributions) on an "AS IS" BASIS,
-      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
-      implied, including, without limitation, any warranties or conditions
-      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
-      PARTICULAR PURPOSE. You are solely responsible for determining the
-      appropriateness of using or redistributing the Work and assume any
-      risks associated with Your exercise of permissions under this License.
-
-   8. Limitation of Liability. In no event and under no legal theory,
-      whether in tort (including negligence), contract, or otherwise,
-      unless required by applicable law (such as deliberate and grossly
-      negligent acts) or agreed to in writing, shall any Contributor be
-      liable to You for damages, including any direct, indirect, special,
-      incidental, or consequential damages of any character arising as a
-      result of this License or out of the use or inability to use the
-      Work (including but not limited to damages for loss of goodwill,
-      work stoppage, computer failure or malfunction, or any and all
-      other commercial damages or losses), even if such Contributor
-      has been advised of the possibility of such damages.
-
-   9. Accepting Warranty or Additional Liability. While redistributing
-      the Work or Derivative Works thereof, You may choose to offer,
-      and charge a fee for, acceptance of support, warranty, indemnity,
-      or other liability obligations and/or rights consistent with this
-      License. However, in accepting such obligations, You may act only
-      on Your own behalf and on Your sole responsibility, not on behalf
-      of any other Contributor, and only if You agree to indemnify,
-      defend, and hold each Contributor harmless for any liability
-      incurred by, or claims asserted against, such Contributor by reason
-      of your accepting any such warranty or additional liability.
-
-   END OF TERMS AND CONDITIONS
-
-   APPENDIX: How to apply the Apache License to your work.
-
-      To apply the Apache License to your work, attach the following
-      boilerplate notice, with the fields enclosed by brackets "[]"
-      replaced with your own identifying information. (Don't include
-      the brackets!)  The text should be enclosed in the appropriate
-      comment syntax for the file format. We also recommend that a
-      file or class name and description of purpose be included on the
-      same "printed page" as the copyright notice for easier
-      identification within third-party archives.
-
-   Copyright 2020 Adobe
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright 2020 Adobe
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
```

## Comparing `lagrange_open-6.22.0.dist-info/licenses/NOTICE.txt` & `lagrange_open-6.23.0.dist-info/licenses/NOTICE.txt`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,251 +1,251 @@
-Lagrange
-========
-The following is a list of sources from which code was used/modified in this codebase.
-
--------------------------------------------------------------------------------
-This codebase contains a modified portion of code from Boost.Functional/Hash which can be obtained at:
-  * SOURCE:
-    * https://www.boost.org/doc/libs/1_64_0/boost/functional/hash/hash.hpp
-
-  * LICENSE:
-    * https://www.boost.org/LICENSE_1_0.txt
-
--------------------------------------------------------------------------------
-This codebase contains a modified portion of code from Christer Ericson, Real-Time Collision Detection which can be obtained at:
-  * SOURCE:
-    * https://doi.org/10.1201/b14581
-
-  * LICENSE:
-    This project contains code adapted from Real-Time Collision Detection by Christer
-    Ericson, published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc. Usage is
-    governed by the following license.
-
-    Software License Agreement
-
-    This Software License Agreement is a legal agreement between the Author and any person
-    or legal entity using or accepting any software governed by this Agreement. The software
-    is available on the CD-ROM in the Book, Real-Time Collision Detection, which is
-    published by Morgan Kaufmann Publishers. "The software" is comprised of all code
-    (fragments and pseudocode) presented in the book. No additional files are on the CD-ROM.
-
-    By installing, copying, or otherwise using the software, you agree to be bound by the
-    terms of this Agreement.
-
-    The parties agree as follows:
-
-    1. Grant of License. We grant you a nonexclusive license to use the software for any
-    purpose, commercial or non-commercial, as long as the following credit is included
-    identifying the original source of the software: "from Real-Time Collision Detection by
-    Christer Ericson, published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc".
-
-    2. Disclaimer of Warranty. We make no warranties at all.The software is transferred to
-    you on an "as is" basis. You use the software at your own peril. You assume all risk of
-    loss for all claims or controversies, now existing or hereafter, arising out of use of
-    the software. We shall have no liability based on a claim that your use or combination
-    of the software with products or data not supplied by us infringes any patent,
-    copyright, or proprietary right. All other warranties, expressed or implied, including,
-    without limitation, any warranty of merchantability or fitness for a particular purpose
-    are hereby excluded.
-
-    3. Limitation of Liability. We will have no liability for special, incidental or
-    consequential damages even if advised of the possibility of such damages. We will not be
-    liable for any other damages or loss in any way connected with the software.
-
--------------------------------------------------------------------------------
-This codebase contains a modified portion of code from CMake Scripts which can be obtained at:
-  * SOURCE:
-    * https://github.com/StableCoder/cmake-scripts
-
-  * LICENSE:
-    * https://github.com/StableCoder/cmake-scripts/blob/master/LICENSE
-
--------------------------------------------------------------------------------
-This codebase contains a modified portion of code from CPM which can be obtained at:
-  * SOURCE:
-    * https://github.com/cpm-cmake/CPM.cmake
-
-  * LICENSE:
-    * https://github.com/cpm-cmake/CPM.cmake/blob/master/LICENSE
-
--------------------------------------------------------------------------------
-This codebase contains a modified portion of code from e-maxx.ru which can be obtained at:
-  * SOURCE:
-    * https://e-maxx.ru/algo/duval_algorithm
-
-  * LICENSE:
-    * https://e-maxx.ru/about.php
-
--------------------------------------------------------------------------------
-This codebase contains a modified portion of code from Earcut which can be obtained at:
-  * SOURCE:
-    * https://github.com/mapbox/earcut.hpp
-
-  * LICENSE:
-    * https://github.com/mapbox/earcut.hpp/blob/master/LICENSE
-
--------------------------------------------------------------------------------
-This codebase contains a modified portion of code from Embree which can be obtained at:
-  * SOURCE:
-    * https://github.com/embree/embree/blob/ae029e2ff83bebbbe8742c88aba5b0521aba1a23/tutorials/closest_point/closest_point_device.cpp#L261-L341
-
-  * LICENSE:
-    * https://github.com/embree/embree/blob/master/LICENSE.txt
-
--------------------------------------------------------------------------------
-This codebase contains a modified portion of code from Floating-point exception handling example which can be obtained at:
-  * SOURCE:
-    * http://www-personal.umich.edu/~williams/archive/computation/fe-handling-example.c
-
-  * LICENSE:
-      Title:  Floating-point exception handling example
-     Author:  David N. Williams
-       File:  fe-handlng-example.c
-    License:  Public Domain
-    Version:  0.5.0
-    Started:  21-Sep-09
-    Revised:  22-Sep-09
-    Revised:  30-Sep-09 (comment typo)
-
--------------------------------------------------------------------------------
-This codebase contains a modified portion of code from function_ref which can be obtained at:
-  * SOURCE:
-    * https://github.com/TartanLlama/function_ref
-
-  * LICENSE:
-    * https://github.com/TartanLlama/function_ref/blob/master/COPYING
-
--------------------------------------------------------------------------------
-This codebase contains a modified portion of code from Geogram which can be obtained at:
-  * SOURCE:
-    * https://github.com/BrunoLevy/geogram
-
-  * LICENSE:
-    BSD 3-Clause License
-
-    Copyright (c) 2022, Bruno Levy
-    All rights reserved.
-
-    Redistribution and use in source and binary forms, with or without
-    modification, are permitted provided that the following conditions are met:
-
-    1. Redistributions of source code must retain the above copyright notice, this
-       list of conditions and the following disclaimer.
-
-    2. Redistributions in binary form must reproduce the above copyright notice,
-       this list of conditions and the following disclaimer in the documentation
-       and/or other materials provided with the distribution.
-
-    3. Neither the name of the copyright holder nor the names of its
-       contributors may be used to endorse or promote products derived from
-       this software without specific prior written permission.
-
-    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
-    FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-    DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-    OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
--------------------------------------------------------------------------------
-This codebase contains a modified portion of code from ImGui Progress Indicators which can be obtained at:
-  * SOURCE:
-    * https://github.com/ocornut/imgui/issues/1901
-
-  * LICENSE:
-    Copyright (c) 2018 Zelimir Fedoran
-
-    Permission is hereby granted, free of charge, to any person obtaining a copy
-    of this software and associated documentation files (the "Software"), to deal
-    in the Software without restriction, including without limitation the rights
-    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-    copies of the Software, and to permit persons to whom the Software is
-    furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included in all
-    copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-    SOFTWARE.
-
--------------------------------------------------------------------------------
-This codebase contains a modified portion of code from Libigl which can be obtained at:
-  * SOURCE:
-    * https://github.com/libigl/libigl
-
-  * LICENSE:
-    * https://github.com/libigl/libigl/blob/main/LICENSE.MPL2
-
--------------------------------------------------------------------------------
-This codebase contains a modified portion of code from scope_guard which can be obtained at:
-  * SOURCE:
-    * https://github.com/ricab/scope_guard/blob/master/scope_guard.hpp
-
-  * LICENSE:
-    * https://github.com/ricab/scope_guard/blob/master/LICENSE
-
--------------------------------------------------------------------------------
-This codebase contains a modified portion of code from Shewchuk's predicates which can be obtained at:
-  * SOURCE:
-    * https://www.cs.cmu.edu/~quake/robust.html
-
-  * LICENSE:
-    Routines for Arbitrary Precision Floating-point Arithmetic
-    and Fast Robust Geometric Predicates
-    (predicates.c)
-
-    May 18, 1996
-
-    Placed in the public domain by
-    Jonathan Richard Shewchuk
-    School of Computer Science
-    Carnegie Mellon University
-    5000 Forbes Avenue
-    Pittsburgh, Pennsylvania  15213-3891
-    jrs@cs.cmu.edu
-
-    This file contains C implementation of algorithms for exact addition
-      and multiplication of floating-point numbers, and predicates for
-      robustly performing the orientation and incircle tests used in
-      computational geometry.  The algorithms and underlying theory are
-      described in Jonathan Richard Shewchuk.  "Adaptive Precision Floating-
-      Point Arithmetic and Fast Robust Geometric Predicates."  Technical
-      Report CMU-CS-96-140, School of Computer Science, Carnegie Mellon
-      University, Pittsburgh, Pennsylvania, May 1996.  (Submitted to
-      Discrete & Computational Geometry.)
-
-    This file, the paper listed above, and other information are available
-      from the Web page http://www.cs.cmu.edu/~quake/robust.html.
-
--------------------------------------------------------------------------------
-This codebase contains a modified portion of code from small_vector which can be obtained at:
-  * SOURCE:
-    * https://github.com/KonanM/small_vector
-
-  * LICENSE:
-    * https://github.com/KonanM/small_vector/blob/master/LICENSE
-
--------------------------------------------------------------------------------
-This codebase contains a modified portion of code from smart_ptr which can be obtained at:
-  * SOURCE:
-    * https://github.com/X-czh/smart_ptr
-
-  * LICENSE:
-    * https://github.com/X-czh/smart_ptr/blob/master/LICENSE
-
--------------------------------------------------------------------------------
-This codebase contains a modified portion of code from valuable which can be obtained at:
-  * SOURCE:
-    * https://github.com/LoopPerfect/valuable
-
-  * LICENSE:
-    * https://github.com/LoopPerfect/valuable/blob/master/LICENSE
-
+Lagrange
+========
+The following is a list of sources from which code was used/modified in this codebase.
+
+-------------------------------------------------------------------------------
+This codebase contains a modified portion of code from Boost.Functional/Hash which can be obtained at:
+  * SOURCE:
+    * https://www.boost.org/doc/libs/1_64_0/boost/functional/hash/hash.hpp
+
+  * LICENSE:
+    * https://www.boost.org/LICENSE_1_0.txt
+
+-------------------------------------------------------------------------------
+This codebase contains a modified portion of code from Christer Ericson, Real-Time Collision Detection which can be obtained at:
+  * SOURCE:
+    * https://doi.org/10.1201/b14581
+
+  * LICENSE:
+    This project contains code adapted from Real-Time Collision Detection by Christer
+    Ericson, published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc. Usage is
+    governed by the following license.
+
+    Software License Agreement
+
+    This Software License Agreement is a legal agreement between the Author and any person
+    or legal entity using or accepting any software governed by this Agreement. The software
+    is available on the CD-ROM in the Book, Real-Time Collision Detection, which is
+    published by Morgan Kaufmann Publishers. "The software" is comprised of all code
+    (fragments and pseudocode) presented in the book. No additional files are on the CD-ROM.
+
+    By installing, copying, or otherwise using the software, you agree to be bound by the
+    terms of this Agreement.
+
+    The parties agree as follows:
+
+    1. Grant of License. We grant you a nonexclusive license to use the software for any
+    purpose, commercial or non-commercial, as long as the following credit is included
+    identifying the original source of the software: "from Real-Time Collision Detection by
+    Christer Ericson, published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc".
+
+    2. Disclaimer of Warranty. We make no warranties at all.The software is transferred to
+    you on an "as is" basis. You use the software at your own peril. You assume all risk of
+    loss for all claims or controversies, now existing or hereafter, arising out of use of
+    the software. We shall have no liability based on a claim that your use or combination
+    of the software with products or data not supplied by us infringes any patent,
+    copyright, or proprietary right. All other warranties, expressed or implied, including,
+    without limitation, any warranty of merchantability or fitness for a particular purpose
+    are hereby excluded.
+
+    3. Limitation of Liability. We will have no liability for special, incidental or
+    consequential damages even if advised of the possibility of such damages. We will not be
+    liable for any other damages or loss in any way connected with the software.
+
+-------------------------------------------------------------------------------
+This codebase contains a modified portion of code from CMake Scripts which can be obtained at:
+  * SOURCE:
+    * https://github.com/StableCoder/cmake-scripts
+
+  * LICENSE:
+    * https://github.com/StableCoder/cmake-scripts/blob/master/LICENSE
+
+-------------------------------------------------------------------------------
+This codebase contains a modified portion of code from CPM which can be obtained at:
+  * SOURCE:
+    * https://github.com/cpm-cmake/CPM.cmake
+
+  * LICENSE:
+    * https://github.com/cpm-cmake/CPM.cmake/blob/master/LICENSE
+
+-------------------------------------------------------------------------------
+This codebase contains a modified portion of code from e-maxx.ru which can be obtained at:
+  * SOURCE:
+    * https://e-maxx.ru/algo/duval_algorithm
+
+  * LICENSE:
+    * https://e-maxx.ru/about.php
+
+-------------------------------------------------------------------------------
+This codebase contains a modified portion of code from Earcut which can be obtained at:
+  * SOURCE:
+    * https://github.com/mapbox/earcut.hpp
+
+  * LICENSE:
+    * https://github.com/mapbox/earcut.hpp/blob/master/LICENSE
+
+-------------------------------------------------------------------------------
+This codebase contains a modified portion of code from Embree which can be obtained at:
+  * SOURCE:
+    * https://github.com/embree/embree/blob/ae029e2ff83bebbbe8742c88aba5b0521aba1a23/tutorials/closest_point/closest_point_device.cpp#L261-L341
+
+  * LICENSE:
+    * https://github.com/embree/embree/blob/master/LICENSE.txt
+
+-------------------------------------------------------------------------------
+This codebase contains a modified portion of code from Floating-point exception handling example which can be obtained at:
+  * SOURCE:
+    * http://www-personal.umich.edu/~williams/archive/computation/fe-handling-example.c
+
+  * LICENSE:
+      Title:  Floating-point exception handling example
+     Author:  David N. Williams
+       File:  fe-handlng-example.c
+    License:  Public Domain
+    Version:  0.5.0
+    Started:  21-Sep-09
+    Revised:  22-Sep-09
+    Revised:  30-Sep-09 (comment typo)
+
+-------------------------------------------------------------------------------
+This codebase contains a modified portion of code from function_ref which can be obtained at:
+  * SOURCE:
+    * https://github.com/TartanLlama/function_ref
+
+  * LICENSE:
+    * https://github.com/TartanLlama/function_ref/blob/master/COPYING
+
+-------------------------------------------------------------------------------
+This codebase contains a modified portion of code from Geogram which can be obtained at:
+  * SOURCE:
+    * https://github.com/BrunoLevy/geogram
+
+  * LICENSE:
+    BSD 3-Clause License
+
+    Copyright (c) 2022, Bruno Levy
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are met:
+
+    1. Redistributions of source code must retain the above copyright notice, this
+       list of conditions and the following disclaimer.
+
+    2. Redistributions in binary form must reproduce the above copyright notice,
+       this list of conditions and the following disclaimer in the documentation
+       and/or other materials provided with the distribution.
+
+    3. Neither the name of the copyright holder nor the names of its
+       contributors may be used to endorse or promote products derived from
+       this software without specific prior written permission.
+
+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+    FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+    DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+    OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+-------------------------------------------------------------------------------
+This codebase contains a modified portion of code from ImGui Progress Indicators which can be obtained at:
+  * SOURCE:
+    * https://github.com/ocornut/imgui/issues/1901
+
+  * LICENSE:
+    Copyright (c) 2018 Zelimir Fedoran
+
+    Permission is hereby granted, free of charge, to any person obtaining a copy
+    of this software and associated documentation files (the "Software"), to deal
+    in the Software without restriction, including without limitation the rights
+    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+    copies of the Software, and to permit persons to whom the Software is
+    furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice shall be included in all
+    copies or substantial portions of the Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+    SOFTWARE.
+
+-------------------------------------------------------------------------------
+This codebase contains a modified portion of code from Libigl which can be obtained at:
+  * SOURCE:
+    * https://github.com/libigl/libigl
+
+  * LICENSE:
+    * https://github.com/libigl/libigl/blob/main/LICENSE.MPL2
+
+-------------------------------------------------------------------------------
+This codebase contains a modified portion of code from scope_guard which can be obtained at:
+  * SOURCE:
+    * https://github.com/ricab/scope_guard/blob/master/scope_guard.hpp
+
+  * LICENSE:
+    * https://github.com/ricab/scope_guard/blob/master/LICENSE
+
+-------------------------------------------------------------------------------
+This codebase contains a modified portion of code from Shewchuk's predicates which can be obtained at:
+  * SOURCE:
+    * https://www.cs.cmu.edu/~quake/robust.html
+
+  * LICENSE:
+    Routines for Arbitrary Precision Floating-point Arithmetic
+    and Fast Robust Geometric Predicates
+    (predicates.c)
+
+    May 18, 1996
+
+    Placed in the public domain by
+    Jonathan Richard Shewchuk
+    School of Computer Science
+    Carnegie Mellon University
+    5000 Forbes Avenue
+    Pittsburgh, Pennsylvania  15213-3891
+    jrs@cs.cmu.edu
+
+    This file contains C implementation of algorithms for exact addition
+      and multiplication of floating-point numbers, and predicates for
+      robustly performing the orientation and incircle tests used in
+      computational geometry.  The algorithms and underlying theory are
+      described in Jonathan Richard Shewchuk.  "Adaptive Precision Floating-
+      Point Arithmetic and Fast Robust Geometric Predicates."  Technical
+      Report CMU-CS-96-140, School of Computer Science, Carnegie Mellon
+      University, Pittsburgh, Pennsylvania, May 1996.  (Submitted to
+      Discrete & Computational Geometry.)
+
+    This file, the paper listed above, and other information are available
+      from the Web page http://www.cs.cmu.edu/~quake/robust.html.
+
+-------------------------------------------------------------------------------
+This codebase contains a modified portion of code from small_vector which can be obtained at:
+  * SOURCE:
+    * https://github.com/KonanM/small_vector
+
+  * LICENSE:
+    * https://github.com/KonanM/small_vector/blob/master/LICENSE
+
+-------------------------------------------------------------------------------
+This codebase contains a modified portion of code from smart_ptr which can be obtained at:
+  * SOURCE:
+    * https://github.com/X-czh/smart_ptr
+
+  * LICENSE:
+    * https://github.com/X-czh/smart_ptr/blob/master/LICENSE
+
+-------------------------------------------------------------------------------
+This codebase contains a modified portion of code from valuable which can be obtained at:
+  * SOURCE:
+    * https://github.com/LoopPerfect/valuable
+
+  * LICENSE:
+    * https://github.com/LoopPerfect/valuable/blob/master/LICENSE
+
```

## Comparing `lagrange_open-6.22.0.dist-info/RECORD` & `lagrange_open-6.23.0.dist-info/RECORD`

 * *Files 21% similar despite different names*

```diff
@@ -1,21 +1,22 @@
-lagrange/__init__.py,sha256=eRlM9NO2phTqq22slQDKzRTbihWYjBoQu4jsoSmTPSc,730
-lagrange/_logging.py,sha256=7udw5A6ScpW2UW-W44Y5Qyf4l5GDXY74QaQsuhDDhfA,1857
-lagrange/lagrange/__init__.pyi,sha256=EG73Fyh7YiKKVP8U3HAS73-3twA6CI-xr_4FnoEsl6k,104
-lagrange/lagrange/core.pyi,sha256=2Ym3g_FJHyCEaZ5IP55JE7EgYjvSV0u6ccCFcM4IMX8,70317
-lagrange/lagrange/image.pyi,sha256=qxHgJgfolp_PPCdGS73SO4uLu1TjFZpbJvmL9scGdtg,994
-lagrange/lagrange/io.pyi,sha256=zKz3EegY0G7ahdd3jWu_UDElR89m6LkbavPd-ULnTbs,9564
-lagrange/lagrange/scene.pyi,sha256=vl3RgcbLzdVg73U3DEIyOD9bUyuHXOo7EKTskCB7jQA,46048
-lagrange/lagrange/subdivision.pyi,sha256=kRk2Z-XbwOQMia4gYbhtB23CIStNp7kmcqaSLHi7Swk,3627
-lagrange/lagrange.cp39-win_amd64.pyd,sha256=SzrK40hQQ7-t_cNlyh0OC0WxhmMg27yOAZTGLdmrB4A,8088576
-lagrange/py.typed,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-lagrange/tbb12.dll,sha256=n5_u1N0QMSzgAFnyEoOYKMGUww0ajeYWANAfrQFqCIM,321024
-lagrange/tbb12.lib,sha256=X4W5TQf81RcaxWrq0je4TF8HWJtG-JuVuzDJR_X0quM,44060
-lagrange_open-6.22.0.data/scripts/extract_texture.py,sha256=8ayqCNrW0zSxwWniSs7UkOgJq8zd9WIKfUCj6tfCuTY,2674
-lagrange_open-6.22.0.data/scripts/meshconvert.py,sha256=zuINoDmMcrg7Va2Q2udrsIuL6rXWETqXEB53AfCEhdE,2290
-lagrange_open-6.22.0.data/scripts/meshstat.py,sha256=v7BJHlNHnthyK8dk4kmSlMLH3PD0jW-GBgI7FAoVj_Y,5810
-lagrange_open-6.22.0.dist-info/METADATA,sha256=CPK3TRybxjcE2_turrs4aSoIFBCQitLi8E9dYWQb0bk,1961
-lagrange_open-6.22.0.dist-info/WHEEL,sha256=3aOdWM_7KOPfqQ-5vTX1Ct3p3DIlvh8-W8IK1a7zxP8,103
-lagrange_open-6.22.0.dist-info/entry_points.txt,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-lagrange_open-6.22.0.dist-info/licenses/LICENSE,sha256=V68Rm9DzW5gnETrkzOSlPFnXRlBwms0AlKuaB1AJxPw,11536
-lagrange_open-6.22.0.dist-info/licenses/NOTICE.txt,sha256=sjR8qjhWiWVRqy1Zx3-yABL8bCilvvOvyF31qe6welQ,11739
-lagrange_open-6.22.0.dist-info/RECORD,,
+lagrange_open-6.23.0.dist-info/RECORD,,
+lagrange_open-6.23.0.dist-info/WHEEL,sha256=4FmLNpgvftsyZK42I1KCdwjX0aeQZCQ3GrB2dPic3Ec,113
+lagrange_open-6.23.0.dist-info/entry_points.txt,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+lagrange_open-6.23.0.dist-info/METADATA,sha256=ezbT25a3Moh_u_LpQ_PepAbloodbjr-_9NYDSaAWr9U,2376
+lagrange_open-6.23.0.dist-info/licenses/LICENSE,sha256=hr3V2vq3dFEES2_W0u-rI-NBDOZY6wl_BMBPT1Su1i8,11335
+lagrange_open-6.23.0.dist-info/licenses/NOTICE.txt,sha256=_g9l7GrUGmfu_bWrnY9j5qXcivcwz8XCKzDulvKu95A,11488
+lagrange/_logging.py,sha256=ZuaP_CqrfCemQAfsObGGq7uSq3k2wjPbzQke2TWFuDg,1794
+lagrange/_version.py,sha256=x7QHQHDv5NHcbZi-p82w-pMsi7YAueN4RuNNYQLgFY0,20
+lagrange/libtbb.12.dylib,sha256=iiVE8-zLe6eFbN9W9-_3dBVqeEMVIwtsMYG6HHzfj64,305776
+lagrange/lagrange.cpython-310-darwin.so,sha256=aM9iVuZAmvrx_AQ6RSiyeosXs3eT2H5AD_GpinUTZ7g,17335200
+lagrange/__init__.py,sha256=Mf7I9k-_WFX0PnCDEN9utop1-EVOYHnrnf2nfhiTwMY,764
+lagrange/py.typed,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+lagrange/libtbb.12.11.dylib,sha256=iiVE8-zLe6eFbN9W9-_3dBVqeEMVIwtsMYG6HHzfj64,305776
+lagrange/libtbb.dylib,sha256=iiVE8-zLe6eFbN9W9-_3dBVqeEMVIwtsMYG6HHzfj64,305776
+lagrange/lagrange/subdivision.pyi,sha256=zCxQB26EQNWyBATyI1AcyVROI8RdCb5MZRQu0f1mvys,2955
+lagrange/lagrange/scene.pyi,sha256=hy5tEAU61xKKDyB2-5ZYSyUWY2KvMxJu8VfP_9gPmQI,44876
+lagrange/lagrange/image.pyi,sha256=6wdND4yBWRHNfhAUgej23iBGOIGTgqscPE7JLBrtw7I,674
+lagrange/lagrange/core.pyi,sha256=k7X9XQnxxTiHCUssh1p7rORC7vX_i58wORkQSRQanHQ,59170
+lagrange/lagrange/io.pyi,sha256=uN9MZ_agygvtk6EAGb_GSdCHYxlC4Fo0MCDQCjzGYsk,8222
+lagrange_open-6.23.0.data/scripts/meshstat.py,sha256=EN6gocC3zQ0XfzHun4793EziUN6ZcdjN4bgLW5h1fuo,5540
+lagrange_open-6.23.0.data/scripts/extract_texture.py,sha256=kIqiOkSKrq5y7Ui3rco0v33oAY6Q9m3l1Cs6aI5VMQc,2586
+lagrange_open-6.23.0.data/scripts/meshconvert.py,sha256=3qXCRu4E3uUtYlnKnczItpIc4LZkamwiNfWZIgDojlA,2200
```

