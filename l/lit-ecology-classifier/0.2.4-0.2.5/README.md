# Comparing `tmp/lit_ecology_classifier-0.2.4-py3-none-any.whl.zip` & `tmp/lit_ecology_classifier-0.2.5-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,23 +1,23 @@
-Zip file size: 24833 bytes, number of entries: 21
+Zip file size: 24881 bytes, number of entries: 21
 -rw-r--r--  2.0 unx        0 b- defN 24-May-28 11:43 lit_ecology_classifier/__init__.py
 -rw-r--r--  2.0 unx     3469 b- defN 24-May-29 08:00 lit_ecology_classifier/main.py
--rw-r--r--  2.0 unx     1827 b- defN 24-May-30 13:26 lit_ecology_classifier/predict.py
--rw-r--r--  2.0 unx     2270 b- defN 24-May-30 09:13 lit_ecology_classifier/test.py
+-rw-r--r--  2.0 unx     1852 b- defN 24-May-31 08:21 lit_ecology_classifier/predict.py
+-rw-r--r--  2.0 unx     2327 b- defN 24-May-30 14:25 lit_ecology_classifier/test.py
 -rw-r--r--  2.0 unx        0 b- defN 24-May-28 11:43 lit_ecology_classifier/data/__init__.py
--rw-r--r--  2.0 unx     8888 b- defN 24-May-30 13:26 lit_ecology_classifier/data/datamodule.py
--rw-r--r--  2.0 unx     7679 b- defN 24-May-30 10:03 lit_ecology_classifier/data/imagedataset.py
--rw-r--r--  2.0 unx     8038 b- defN 24-May-30 13:26 lit_ecology_classifier/data/tardataset.py
+-rw-r--r--  2.0 unx     8697 b- defN 24-May-31 08:46 lit_ecology_classifier/data/datamodule.py
+-rw-r--r--  2.0 unx     7710 b- defN 24-May-31 08:50 lit_ecology_classifier/data/imagedataset.py
+-rw-r--r--  2.0 unx     8016 b- defN 24-May-31 08:33 lit_ecology_classifier/data/tardataset.py
 -rw-r--r--  2.0 unx        0 b- defN 24-May-28 11:43 lit_ecology_classifier/helpers/__init__.py
 -rw-r--r--  2.0 unx     2654 b- defN 24-May-30 13:26 lit_ecology_classifier/helpers/argparser.py
 -rw-r--r--  2.0 unx     1145 b- defN 24-May-28 11:43 lit_ecology_classifier/helpers/calc_class_weights.py
--rw-r--r--  2.0 unx    11090 b- defN 24-May-30 13:26 lit_ecology_classifier/helpers/helpers.py
+-rw-r--r--  2.0 unx    11113 b- defN 24-May-31 08:52 lit_ecology_classifier/helpers/helpers.py
 -rw-r--r--  2.0 unx        0 b- defN 24-May-28 11:43 lit_ecology_classifier/models/__init__.py
--rw-r--r--  2.0 unx    11575 b- defN 24-May-30 13:26 lit_ecology_classifier/models/model.py
+-rw-r--r--  2.0 unx    11575 b- defN 24-May-31 08:24 lit_ecology_classifier/models/model.py
 -rw-r--r--  2.0 unx     2665 b- defN 24-May-30 13:26 lit_ecology_classifier/models/setup_model.py
--rw-r--r--  2.0 unx     1068 b- defN 24-May-30 13:30 lit_ecology_classifier-0.2.4.dist-info/LICENSE
--rw-r--r--  2.0 unx     3706 b- defN 24-May-30 13:30 lit_ecology_classifier-0.2.4.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 24-May-30 13:30 lit_ecology_classifier-0.2.4.dist-info/WHEEL
--rw-r--r--  2.0 unx       76 b- defN 24-May-30 13:30 lit_ecology_classifier-0.2.4.dist-info/entry_points.txt
--rw-r--r--  2.0 unx       23 b- defN 24-May-30 13:30 lit_ecology_classifier-0.2.4.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     2008 b- defN 24-May-30 13:30 lit_ecology_classifier-0.2.4.dist-info/RECORD
-21 files, 68273 bytes uncompressed, 21453 bytes compressed:  68.6%
+-rw-r--r--  2.0 unx     1068 b- defN 24-May-31 08:55 lit_ecology_classifier-0.2.5.dist-info/LICENSE
+-rw-r--r--  2.0 unx     3706 b- defN 24-May-31 08:55 lit_ecology_classifier-0.2.5.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 24-May-31 08:55 lit_ecology_classifier-0.2.5.dist-info/WHEEL
+-rw-r--r--  2.0 unx       76 b- defN 24-May-31 08:55 lit_ecology_classifier-0.2.5.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx       23 b- defN 24-May-31 08:55 lit_ecology_classifier-0.2.5.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     2008 b- defN 24-May-31 08:55 lit_ecology_classifier-0.2.5.dist-info/RECORD
+21 files, 68196 bytes uncompressed, 21501 bytes compressed:  68.5%
```

## zipnote {}

```diff
@@ -39,26 +39,26 @@
 
 Filename: lit_ecology_classifier/models/model.py
 Comment: 
 
 Filename: lit_ecology_classifier/models/setup_model.py
 Comment: 
 
-Filename: lit_ecology_classifier-0.2.4.dist-info/LICENSE
+Filename: lit_ecology_classifier-0.2.5.dist-info/LICENSE
 Comment: 
 
-Filename: lit_ecology_classifier-0.2.4.dist-info/METADATA
+Filename: lit_ecology_classifier-0.2.5.dist-info/METADATA
 Comment: 
 
-Filename: lit_ecology_classifier-0.2.4.dist-info/WHEEL
+Filename: lit_ecology_classifier-0.2.5.dist-info/WHEEL
 Comment: 
 
-Filename: lit_ecology_classifier-0.2.4.dist-info/entry_points.txt
+Filename: lit_ecology_classifier-0.2.5.dist-info/entry_points.txt
 Comment: 
 
-Filename: lit_ecology_classifier-0.2.4.dist-info/top_level.txt
+Filename: lit_ecology_classifier-0.2.5.dist-info/top_level.txt
 Comment: 
 
-Filename: lit_ecology_classifier-0.2.4.dist-info/RECORD
+Filename: lit_ecology_classifier-0.2.5.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## lit_ecology_classifier/predict.py

```diff
@@ -36,24 +36,24 @@
     pathlib.Path(args.outpath).mkdir(parents=True, exist_ok=True)
 
     # Initialize the Model
     model = LitClassifier.load_from_checkpoint(args.model_path)
 
     # Initialize the Data Module
     hparams = model.hparams # copy the hyperparameters from the model
-    model.hparams.batch_size *= 1
+    model.hparams.batch_size *= 2
     model.hparams.TTA = not args.no_TTA # set the TTA flag based on the argument
     model.hparams.outpath = args.outpath
     model.hparams.datapath = args.datapath
     data_module = DataModule(**model.hparams)
     data_module.setup("predict")
 
     model.load_datamodule(data_module)
 
     # Initialize the Trainer and Perform Predictions
     trainer = pl.Trainer(devices=torch.cuda.device_count() if not args.no_gpu else 0, strategy="ddp" if torch.cuda.device_count() > 1 else "auto",
-    enable_progress_bar=True, default_root_dir=args.outpath)
+    enable_progress_bar=True, default_root_dir=args.outpath,limit_predict_batches=10)
     trainer.predict(model, datamodule=data_module)
 
     # Calculate and log the total time taken for prediction
     total_secs = -1 if time_begin is None else (time() - time_begin)
     logging.info('Time taken for prediction (in secs): {}'.format(total_secs))
```

## lit_ecology_classifier/test.py

```diff
@@ -33,15 +33,15 @@
     parser = inference_argparser()
     args = parser.parse_args()
 
     # Create Output Directory if it doesn't exist
     pathlib.Path(args.outpath).mkdir(parents=True, exist_ok=True)
 
     # Initialize the Model
-    model = LitClassifier.load_from_checkpoint(args.model_path)
+    model = LitClassifier.load_from_checkpoint(args.model_path, num_classes=87, class_weights=None)
 
     # Initialize the Data Module
     hparams = model.hparams # copy the hyperparameters from the model
     model.hparams.batch_size *= 1
     model.hparams.TTA = not args.no_TTA # set the TTA flag based on the argument
     model.hparams.outpath = args.outpath
     model.hparams.datapath = args.datapath
@@ -50,15 +50,15 @@
     data_module = DataModule(**model.hparams)
     data_module.setup("predict")
 
     model.load_datamodule(data_module)
 
     # Initialize the Trainer and Perform Predictions
     trainer = pl.Trainer(devices=torch.cuda.device_count() if not args.no_gpu else 0, strategy="ddp" if torch.cuda.device_count() > 1 else "auto",
-        enable_progress_bar=True, default_root_dir=args.outpath)
+        enable_progress_bar=True, default_root_dir=args.outpath,limit_test_batches=2)
     trainer.test(model, datamodule=data_module)
 
     # Calculate and log the total time taken for prediction
     total_secs = -1 if time_begin is None else (time() - time_begin)
     logging.info('Time taken for prediction (in secs): {}'.format(total_secs))
     model.hparams.priority_classes="config/priority.json"
     with open(model.hparams.priority_classes, 'r') as file:
```

## lit_ecology_classifier/data/datamodule.py

```diff
@@ -67,16 +67,18 @@
 
             # Randomly split the dataset into train, validation, and test sets
             self.train_dataset, self.val_dataset, self.test_dataset = random_split(full_dataset, [train_size, val_size, test_size], generator=torch.Generator().manual_seed(42))
             # Set train flag to False for validation and test datasets
             self.val_dataset.train = False
             self.test_dataset.train = False
         else:
-
-            self.predict_dataset = TarImageDataset(self.datapath, self.class_map_path, self.priority_classes, TTA=self.TTA, train=False)
+            if self.datapath.find(".tar") == -1:
+                self.predict_dataset = ImageFolderDataset(self.datapath, self.class_map_path, self.priority_classes, TTA=self.TTA, train=False)
+            else:
+                self.predict_dataset = TarImageDataset(self.datapath, self.class_map_path, self.priority_classes, TTA=self.TTA, train=False)
 
             self.class_map = self.predict_dataset.class_map
             self.class_map_path = self.predict_dataset.class_map_path
         if not os.path.exists(self.class_map_path) and self.TTA:
             raise FileNotFoundError(f"Class map not found at {self.class_map_path}. The class map needs to exist for inference.")
     def train_dataloader(self):
         """
@@ -87,15 +89,15 @@
         # Use a distributed sampler if multiple GPUs are available and multi-processing is enabled
         sampler = DistributedSampler(self.train_dataset) if torch.cuda.device_count() > 1 and self.use_multi else None
         return DataLoader(
             self.train_dataset,
             batch_size=self.batch_size,
             shuffle=(sampler is None),
             sampler=sampler,
-            num_workers=os.cpu_count() // torch.cuda.device_count() if torch.cuda.device_count() > 0 else 4,
+            num_workers= 4,
             pin_memory=True,
             drop_last=True,
         )
 
     def val_dataloader(self):
         """
         Constructs the DataLoader for validation data.
@@ -104,26 +106,26 @@
         """
         sampler = DistributedSampler(self.val_dataset) if torch.cuda.device_count() > 1 and self.use_multi else None
         loader = DataLoader(
             self.val_dataset,
             batch_size=self.batch_size,
             shuffle=False,
             sampler=sampler,
-            num_workers=os.cpu_count() // torch.cuda.device_count() if torch.cuda.device_count() > 0 else 4,
+            num_workers= 4,
             pin_memory=True,
             drop_last=False,
         )
         if self.TTA:
             # Apply TTA collate function if TTA is enabled
             loader = DataLoader(
                 self.val_dataset,
                 batch_size=self.batch_size,
                 shuffle=False,
                 sampler=sampler,
-                num_workers=os.cpu_count() // torch.cuda.device_count() if torch.cuda.device_count() > 0 else 4,
+                num_workers= 4,
                 pin_memory=True,
                 drop_last=False,
                 collate_fn=TTA_collate_fn,
             )
         return loader
 
     def test_dataloader(self):
@@ -135,25 +137,25 @@
         sampler = DistributedSampler(self.test_dataset) if torch.cuda.device_count() > 1 and self.use_multi else None
         if self.TTA:
             loader = DataLoader(
                 self.test_dataset,
                 batch_size=self.batch_size,
                 shuffle=False,
                 sampler=sampler,
-                num_workers=os.cpu_count() // torch.cuda.device_count() if torch.cuda.device_count() > 0 else 4,
+                num_workers= 4,
                 pin_memory=True,
                 drop_last=False,
                 collate_fn=TTA_collate_fn,
             )
         else:
             loader = DataLoader(
                 self.test_dataset,
                 batch_size=self.batch_size,
                 shuffle=False,
-                num_workers=os.cpu_count() // torch.cuda.device_count() if torch.cuda.device_count() > 0 else 4,
+                num_workers= 4,
                 pin_memory=True,
                 drop_last=False,
             )
         return loader
 
     def predict_dataloader(self):
         """
```

## lit_ecology_classifier/data/imagedataset.py

```diff
@@ -43,25 +43,25 @@
         self.train = train
         self.class_map_path = class_map_path
         self.priority_classes = priority_classes
 
         # Load priority classes and adjust class map accordingly
         if self.priority_classes != []:
 
-
-            priority_postfix = "_".join(self.priority_classes)
+            logging.info(f"Priority classes not None. Loading priority classes from {self.priority_classes}")
+            priority_postfix = "_priority"
             logging.info(f"Priority classes loaded: {self.priority_classes}")
-            self.class_map_path = self.class_map_path.replace("class_map.json", f"class_map_{priority_postfix}.json")
+            self.class_map_path = self.class_map_path.replace("class_map.json", f"class_map{priority_postfix}.json")
             logging.info(f"Class map path set to {self.class_map_path}")
 
         # Load class map from JSON or create it from the folder structure if not present
         if not os.path.exists(self.class_map_path):
             if not train:
                 raise FileNotFoundError(f"Class map not found at {self.class_map_path}. Class map needs to be present for testing.")
-            logging.info(f"Class map not found at {self.class_map_path}. Creating class map from folder structure.")
+            logging.info(f"Class map not found at {self.class_map_path}. Extracting class map from folder structure.")
             self._create_class_map(image_folder_path)
             logging.info(f"Class map saved to {self.class_map_path}")
         else:
             logging.info(f"Loading class map from {self.class_map_path}")
             with open(self.class_map_path, "r") as json_file:
                 self.class_map = json.load(json_file)
             logging.info(f"Class map loaded.")
@@ -99,34 +99,34 @@
         Args:
             idx (int): The index of the image.
 
         Returns:
             tuple: A tuple containing the transformed image and its label.
         """
         image_info = self.image_infos[idx]
-        image = Image.open(image_info['path']).convert("RGB")
+        image = Image.open(image_info).convert("RGB")
         # Apply TTA transformations if enabled
         if self.TTA:
             image = {rot: self.val_transforms(self.rotations[rot](image)) for rot in self.rotations}
         elif self.train:
             image = self.train_transforms(image)
         else:
             image = self.val_transforms(image)
-        label = self.get_label_from_filename(image_info['path'])
+        label = self.get_label_from_filename(image_info)
         return image, label
 
     def _load_image_infos(self):
         """
         Load image information from the folder structure.
         """
         image_infos = []
         for root, _, files in os.walk(self.image_folder_path):
             for file in files:
                 if file.lower().endswith(("jpg", "jpeg", "png")):
-                    image_infos.append({'path': os.path.join(root, file), 'label': os.path.basename(root)})
+                    image_infos.append(os.path.join(root, file))
         return image_infos
 
     def _create_class_map(self, folder_path):
         """
         Creates the class map from the folder structure and saves it to a JSON file.
         """
         logging.info("Creating class map from folder structure.")
```

## lit_ecology_classifier/data/tardataset.py

```diff
@@ -46,18 +46,17 @@
         self.class_map_path = class_map_path
         self.priority_classes = priority_classes
 
         # Load priority classes and adjust class map accordingly
         if self.priority_classes != []:
 
             logging.info(f"Priority classes not None. Loading priority classes from {self.priority_classes}")
-
-            priority_postfix = "_".join(self.priority_classes)
+            priority_postfix = "_priority"
             logging.info(f"Priority classes loaded: {self.priority_classes}")
-            self.class_map_path = self.class_map_path.replace("class_map.json", f"class_map_{priority_postfix}.json")
+            self.class_map_path = self.class_map_path.replace("class_map.json", f"class_map{priority_postfix}.json")
             logging.info(f"Class map path set to {self.class_map_path}")
 
         # Load class map from JSON or extract it from the tar file if not present
         if not os.path.exists(self.class_map_path):
             if not train:
                 raise FileNotFoundError(f"Class map not found at {self.class_map_path}. Class map needs to be present for testing.")
             logging.info(f"Class map not found at {self.class_map_path}. Extracting class map from tar file.")
@@ -112,26 +111,26 @@
             # Apply TTA transformations if enabled
             if self.TTA:
                 image = {rot: self.val_transforms(self.rotations[rot](image)) for rot in self.rotations}
             elif self.train:
                 image = self.train_transforms(image)
             else:
                 image = self.val_transforms(image)
-            label = self.get_label_from_filename(image_info.name)
+            label = self.get_label_from_filename(image_info)
             return image, label
 
     def _load_image_infos(self):
         """
         Load image information from the tar file.
         """
         image_infos = []
         with tarfile.open(self.tar_path, "r") as tar:
             for member in tar.getmembers():
                 if member.isfile() and member.name.lower().endswith(("jpg", "jpeg", "png")):
-                    image_infos.append(member)
+                    image_infos.append(member.name)
         return image_infos
 
     def _extract_class_map(self, tar_path):
         """
         Extracts the class map from the contents of the tar file and saves it to a JSON file.
         """
         logging.info("Extracting class map from tar file.")
```

## lit_ecology_classifier/helpers/helpers.py

```diff
@@ -18,15 +18,15 @@
     Args:
         outpath (str): Output directory path.
         im_names (list): List of image filenames.
         labels (list): List of predicted labels.
     """
 
     labels = labels.tolist()
-    base_filename = f"{outpath}/predictions"
+    base_filename = f"{outpath}/predictions_lit_ecology_classifier"
     file_path = f"{base_filename}.txt"
     lines = [f"\n{img}------------------ {label}/{score}" for img, label,score in zip(im_names, labels,scores)]
     with open(file_path, "w") as f:
         f.writelines(lines)
 
 
 def gmean(input_x, dim):
```

## Comparing `lit_ecology_classifier-0.2.4.dist-info/LICENSE` & `lit_ecology_classifier-0.2.5.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `lit_ecology_classifier-0.2.4.dist-info/METADATA` & `lit_ecology_classifier-0.2.5.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: lit_ecology_classifier
-Version: 0.2.4
+Version: 0.2.5
 Summary: Image Classifier optimised for ecology use-cases
 Home-page: https://github.com/kaechb/lit_ecology_classifier
 Author: Benno Kaech
 Author-email: your.email@example.com
 Classifier: Programming Language :: Python :: 3
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Operating System :: OS Independent
```

## Comparing `lit_ecology_classifier-0.2.4.dist-info/RECORD` & `lit_ecology_classifier-0.2.5.dist-info/RECORD`

 * *Files 18% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 lit_ecology_classifier/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 lit_ecology_classifier/main.py,sha256=oye_MqYi8_Pnlq4E3Dy65VtXPW7JyBxecJW9cHEM6rw,3469
-lit_ecology_classifier/predict.py,sha256=jOBrowMkUv6PmV56nRlm_Mh_RryGMDWxZ21A-BHJHcY,1827
-lit_ecology_classifier/test.py,sha256=azEaeBGstFfe6Ijec64z0O_RQVtBoGdJNpV4mhjMowo,2270
+lit_ecology_classifier/predict.py,sha256=W5hRWxtBHRp-revjYCLZYow4BPxzyCC0xpvBWUBgQOY,1852
+lit_ecology_classifier/test.py,sha256=NCm4SGXD8Aa4ckt3bXqskH6XtDNSV2KPZ6BO938Oo0Q,2327
 lit_ecology_classifier/data/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-lit_ecology_classifier/data/datamodule.py,sha256=WFTNAd3c6Tzv1WxiJQ1sCJygjRRsoS0lRpYIoKrx8-c,8888
-lit_ecology_classifier/data/imagedataset.py,sha256=E1dVz2MhFlzpMYTe4MCeWPlIlGvob0v02BAZbDTGido,7679
-lit_ecology_classifier/data/tardataset.py,sha256=kYmecfDmhjxyD_YrHEen0OD-Y1loTI2bweOJDaCk-lc,8038
+lit_ecology_classifier/data/datamodule.py,sha256=JG60qcQkT2BBh2EzpwMKz-7i7rQA5jAGBQg_IME-HuE,8697
+lit_ecology_classifier/data/imagedataset.py,sha256=YblIo-n5LaVBzYuMu07b11Xy_fod_oZTnwGqLoYL4hs,7710
+lit_ecology_classifier/data/tardataset.py,sha256=HDxnCiJHuKUtgLJJslulhjXsC2KGnp8s_FUiQXbtXNI,8016
 lit_ecology_classifier/helpers/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 lit_ecology_classifier/helpers/argparser.py,sha256=8e8KKZcMJcj-f2tlVk6CuQt2EsFN8iMJRyy8ZZvPHaY,2654
 lit_ecology_classifier/helpers/calc_class_weights.py,sha256=fMzuX0jeRNXScX9IO8veOgKsxAnWI3VfjwDwAFOO6A4,1145
-lit_ecology_classifier/helpers/helpers.py,sha256=R2sWKulUW_cSKMXVKsU_NDCa4cW-FUJ_sDFI3zso1qU,11090
+lit_ecology_classifier/helpers/helpers.py,sha256=NM1c7rYsY0BGcyghoJvGOWfnrpt7OrkNEtlJfjuA310,11113
 lit_ecology_classifier/models/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 lit_ecology_classifier/models/model.py,sha256=HX2sC5ZEZNK2yf-bQNPj-FZGCNZaoKfDz1WOxNf-Cj4,11575
 lit_ecology_classifier/models/setup_model.py,sha256=sVULgitlYHlaVPNu3-IIMb_V5ZbA1-Vt3YPZ390ZmTs,2665
-lit_ecology_classifier-0.2.4.dist-info/LICENSE,sha256=otRPec6AwxKerM0zN-WiG66AnplxnmpbPaDyJd_QxE0,1068
-lit_ecology_classifier-0.2.4.dist-info/METADATA,sha256=er_pjTP6NkiRcjVz9vHsPUQeliUZTLxQbHkGycOCBqg,3706
-lit_ecology_classifier-0.2.4.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
-lit_ecology_classifier-0.2.4.dist-info/entry_points.txt,sha256=v3ZJ9RRS0_MjXgy4y3gPb2R7ANPKKyPQrRlEO384ITQ,76
-lit_ecology_classifier-0.2.4.dist-info/top_level.txt,sha256=PKi3Fm6NgOu2ej8D7-MCov1FmFYRFdfaTOAxYhDYJnw,23
-lit_ecology_classifier-0.2.4.dist-info/RECORD,,
+lit_ecology_classifier-0.2.5.dist-info/LICENSE,sha256=otRPec6AwxKerM0zN-WiG66AnplxnmpbPaDyJd_QxE0,1068
+lit_ecology_classifier-0.2.5.dist-info/METADATA,sha256=VqThUcaUo9eK17n8RcceZ0fo8B4MCeDGuAM7i6w_y_A,3706
+lit_ecology_classifier-0.2.5.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
+lit_ecology_classifier-0.2.5.dist-info/entry_points.txt,sha256=v3ZJ9RRS0_MjXgy4y3gPb2R7ANPKKyPQrRlEO384ITQ,76
+lit_ecology_classifier-0.2.5.dist-info/top_level.txt,sha256=PKi3Fm6NgOu2ej8D7-MCov1FmFYRFdfaTOAxYhDYJnw,23
+lit_ecology_classifier-0.2.5.dist-info/RECORD,,
```

